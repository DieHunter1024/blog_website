<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-___Hello___World</title><link>https://www.cnblogs.com/HelloWorld-Yu/</link><description /><language>zh-cn</language><lastBuildDate>Wed, 08 Dec 2021 15:49:18 GMT</lastBuildDate><pubDate>Wed, 08 Dec 2021 15:49:18 GMT</pubDate><ttl>60</ttl><item><title>Gitea+Jenkins能碰撞出怎样的火花？浅谈前端自动化部署</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/11/28/15665009.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sat, 27 Nov 2021 18:16:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/11/28/15665009.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" title="前言：">前言：</a></p> 
<p id="%E9%A6%96%E5%85%88%E6%98%AF%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0Git%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93-toc" style="margin-left:80px;"><a href="#%E9%A6%96%E5%85%88%E6%98%AF%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0Git%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93" title="首先是搭建一个本地Git代码仓库">首先是搭建一个本地Git代码仓库</a></p> 
<p id="%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%98%AFJenkins%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%98%AFJenkins%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE" title="接下来是Jenkins安装配置">接下来是Jenkins安装配置</a></p> 
<p id="%E8%87%AA%E7%94%B1%E9%A3%8E%E6%A0%BC%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%EF%BC%88window%E6%89%B9%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E7%94%B1%E9%A3%8E%E6%A0%BC%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%EF%BC%88window%E6%89%B9%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%89" title="自由风格项目构建（window批处理命令）">自由风格项目构建（window批处理命令）</a></p> 
<p id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA-toc" style="margin-left:80px;"><a href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA" title="流水线项目构建">流水线项目构建</a></p> 
<p id="%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E-toc" style="margin-left:80px;"><a href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E" title="写在最后">写在最后</a></p> 
<hr id="hr-toc">
<h3 id="%E5%89%8D%E8%A8%80%EF%BC%9A"><strong>前言</strong></h3> 
<p><strong>一个好的部署工具能帮助开发者提升效率，节省时间，本文将与大家分享私有化Git仓库搭建与Jenkins操作项目部署</strong></p> 
<p><strong>准备工作：</strong></p> 
<ul><li><a class="link-info" href="https://www.runoob.com/java/java-environment-setup.html" title="Java环境">Java环境</a></li><li><a class="link-info" href="https://blog.csdn.net/time_____/article/details/114024145" title="Node环境">Node环境</a></li><li><a class="link-info" href="https://gitea.io/zh-cn/" title="Gitea">Gitea</a></li><li><a class="link-info" href="https://www.jenkins.io/zh/" title="Jenkins">Jenkins</a></li><li><a class="link-info" href="https://blog.csdn.net/time_____/article/details/114750930" title="Nginx">Nginx</a>(部署前端页面)</li><li>服务器或者电脑（我这里是window系统+<a class="link-info" href="https://blog.csdn.net/time_____/article/details/114664920" title="公网映射">公网映射</a>搭建的本地服务器）</li></ul>
<h3 id="%E9%A6%96%E5%85%88%E6%98%AF%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0Git%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93"><strong>首先是搭建一个本地Git代码仓库</strong></h3> 
<p><strong>下载gitea并在需要安装的文件夹下打开，默认访问地址是127.0.0.1:3000</strong></p> 
<p><img alt="" height="129" src="https://img-blog.csdnimg.cn/d7f47672639740a59c0d31eca469b642.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="249"></p> 
<p><strong>打开后选择一下数据库，并在对应文件夹下生成db文件（新建空白txt文件，改后缀名为db）</strong></p> 
<p><img alt="" height="128" src="https://img-blog.csdnimg.cn/3ba4bb763c50461c968b6550dce953b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="273"></p> 
<p><strong>端口号和名称可以自定义改一下，最后点击安装，等待安装完成，再次进入，注册管理员账号就可以打开了，后面就和远程仓库操作方式一样了</strong></p> 
<p><img alt="" height="103" src="https://img-blog.csdnimg.cn/e1ee04fdb75b40348f7d69dcf2b45775.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="219"><img alt="" height="101" src="https://img-blog.csdnimg.cn/98c07ee92f9c407092b14fd640556f33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="215"><img alt="" height="100" src="https://img-blog.csdnimg.cn/3349472540fc4e63b7dcbef4d1ace8b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="212"></p> 
<h3 id="%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%98%AFJenkins%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE"><strong>接下来是Jenkins安装配置</strong></h3> 
<p><strong>下载Jenkins并打开，这一步配置本地服务，设置本地端口号（默认是8080</strong><strong>），我这里是10240</strong></p> 
<p><img alt="" height="239" src="https://img-blog.csdnimg.cn/a328ca98998e4d939a109b2c7239c6cd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_12,color_FFFFFF,t_70,g_se,x_16" width="308"><img alt="" height="236" src="https://img-blog.csdnimg.cn/28fd23c1a98d405ea8173c6a9fc30b4a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_12,color_FFFFFF,t_70,g_se,x_16" width="304"></p> 
<p><strong>选择Java的jdk路径，并点击下一步安装</strong></p> 
<p>&nbsp;<img alt="" height="248" src="https://img-blog.csdnimg.cn/102bbee908774cc48f967c8f7eb7b503.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_12,color_FFFFFF,t_70,g_se,x_16" width="319"><img alt="" height="243" src="https://img-blog.csdnimg.cn/32574d29dbaf45788486344cc7dfa1bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_12,color_FFFFFF,t_70,g_se,x_16" width="313"></p> 
<p><strong>完成后通过<a href="http://localhost:8000" title="http://localhost:8000">http://localhost:8000</a>进入主页，第一次进入Jenkins会进行初始化设置，直接复制本地地址用浏览器打开，然后输入到下面的输入框，点击继续（注意：如果考虑安装Jenkins数据的体积，可以新增环境变量JENKINS_HOME，值改为其他盘符路径，后续Jenkins的数据会保存在此）</strong></p> 
<p><img alt="" height="117" src="https://img-blog.csdnimg.cn/5ad300359a2c4db8abc93bef751c2b73.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="256"><img alt="" height="108" src="https://img-blog.csdnimg.cn/37e9c3ef083143fda20565a9ad199c05.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="236"></p> 
<p><strong>进入插件安装界面，建议先选择推荐插件，后续在插件管理中修改</strong></p> 
<p><img alt="" height="128" src="https://img-blog.csdnimg.cn/57ab16443acb400ca87bff4da97bec3e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="279"></p> 
<p><strong>插件全部安装完后，进入管理员用户创建页面，输入账号密码来创建第一个用户，也就是管理员</strong></p> 
<p><img alt="" height="129" src="https://img-blog.csdnimg.cn/80a9df12843641669b0d8ad8aedc1772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="281"></p> 
<p><strong>进入首页，发现部分文字没有汉化，此时参照<a class="link-info" href="https://blog.csdn.net/qq_37489565/article/details/104337073" title="这位博主">这位博主</a>的博客，安装Locale插件=&gt;设置语言为zh_US=&gt;重启=&gt;设置语言为zh_CN=&gt;刷新页面就可以了</strong></p> 
<p><img alt="" height="142" src="https://img-blog.csdnimg.cn/9d8026ebfa424db9b5f2fb398bc3b172.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="310"><img alt="" height="143" src="https://img-blog.csdnimg.cn/f5d4df3cbc07484faa26ea692f5afefa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="313"></p> 
<p><strong>如果不需要开机自启Jenkins，可以关闭自启软件，并且使用手动打开的方式：在Jenkins目录下输入java -jar jenkins.war --httpPort=10240，或者写成bat形式运行</strong></p> 
<p><strong>下面来说说</strong><strong>Jenkins的插件安装，在插件管理中安装Generic Webhook Trigger用于gitea构建触发器，Blue Ocean可以理解为Jenkins的一个皮肤（个人感觉界面看起来和操作使用很舒服）</strong></p> 
<p><img alt="" height="134" src="https://img-blog.csdnimg.cn/960705f34f6b4b319ffee20678ec81c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="293"><img alt="" height="136" src="https://img-blog.csdnimg.cn/9b6b671dfeb84fe4887221f283483b14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="297"></p> 
<p><strong>关于Jenkins准备工作，已经基本做完，下一步将使用gitea中的webhooks与Jenkins进行联系，达到代码自动部署的效果</strong></p> 
<p><strong>首先，我们先点新建任务，进入到任务列表，接下来，我将分享两种构建的方式，分别是批处理命令构建和pipeline流水线语法的方式构建</strong></p> 
<p><img alt="" height="132" src="https://img-blog.csdnimg.cn/977a8ca87afc4ba9b3284eb22fa1a00e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="288"><img alt="" height="131" src="https://img-blog.csdnimg.cn/8860c6dc1ec342f282eaa875aac00a08.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="286"></p> 
<h3 id="%E8%87%AA%E7%94%B1%E9%A3%8E%E6%A0%BC%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%EF%BC%88window%E6%89%B9%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%EF%BC%89">自由风格项目构建（<strong>window批处理命令</strong>）</h3> 
<p><strong>在任务配置中输入gitea clone的地址，并且点击新建验证方式，我这里用的是用户名密码</strong></p> 
<p><img alt="" height="159" src="https://img-blog.csdnimg.cn/d8bb2bb699274ecdb97c5cee0eb2231e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="347"><img alt="" height="149" src="https://img-blog.csdnimg.cn/d668908c75954ccfbf1bcae3e230e3f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="325"></p> 
<p><strong>在凭证配置中选择用户名密码，并输入gitea的用户名，密码，点击添加即可，添加后在源码管理中选择刚才添加的凭证方式</strong></p> 
<p><img alt="" height="141" src="https://img-blog.csdnimg.cn/e3079016d963486aa278846d9c33e13a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="307"><img alt="" height="140" src="https://img-blog.csdnimg.cn/b6f6eb357bc34ecc88b9001ce8b55204.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="306"></p> 
<p><strong>然后在构建中新增构建步骤，选择window批处理命令，并分别新建以下命令（npm i和npm run build一定要分开，否则在安装依赖时命令控制台会直接输入npm run build，此时是没有效果的，导致后面的命令不执行）</strong></p> 
<ol><li><strong>node -v<br> npm -v</strong></li><li><strong>npm i</strong></li><li><strong>npm run build</strong></li></ol>
<p><img alt="" height="94" src="https://img-blog.csdnimg.cn/f4555c79fb3048a48d3dedec1ee71294.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="205"><img alt="" height="94" src="https://img-blog.csdnimg.cn/b0680831bc2145cba20a6012712a4c9c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="205"><img alt="" height="94" src="https://img-blog.csdnimg.cn/26daf43376b846b4838f5a4766e6f473.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="204"></p> 
<p><strong>最后点保存，并在工作台运行测试一下</strong></p> 
<p><img alt="" height="93" src="https://img-blog.csdnimg.cn/e19284690a554fc4b1b5f6aad4575949.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="203"><img alt="" height="92" src="https://img-blog.csdnimg.cn/94ac638cbccd4176a2d0e283caf5d41c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="200"><img alt="" height="92" src="https://img-blog.csdnimg.cn/f231503fc4b944448961e0a1bc566b1c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="202"></p> 
<p><strong>运行完成后在对应路径下找到dist文件，就说明构建成功，我的项目路径是C:\Users\Administrator\.jenkins\workspace\，所以就去该文件夹中找对应的文件</strong></p> 
<p>&nbsp;<img alt="" height="162" src="https://img-blog.csdnimg.cn/7ced6f335d3947c982e0402c2878d08c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="353"><img alt="" height="154" src="https://img-blog.csdnimg.cn/26348470a92c461db88bcd1491289380.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_19,color_FFFFFF,t_70,g_se,x_16" width="278"></p> 
<p><strong>接下来，我们在gitea中添加webhooks用来触发Jenkins的构建</strong></p> 
<p><strong>先在Jenkins的任务配置中设置构建触发器，并且在下面的配置项中找到token配置，设置token并保存</strong></p> 
<p><img alt="" height="94" src="https://img-blog.csdnimg.cn/2b4dd831f84b474e98fdcb2399e27c93.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="205"><img alt="" height="94" src="https://img-blog.csdnimg.cn/a1b1a5b87d56474ebf50fe6901f7b56a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="205"></p> 
<p><strong>然后在仓库设置中添加web钩子，设置请求的地址，地址与Jenkins构建触发器中示例地址一致</strong></p> 
<p><img alt="" height="93" src="https://img-blog.csdnimg.cn/a9b7e1ee9dd1494c8a535f21eb682ed4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="204"><img alt="" height="93" src="https://img-blog.csdnimg.cn/e5dd04bc03ad456bbcf4e137f07328f3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="203"><img alt="" height="94" src="https://img-blog.csdnimg.cn/b980502186694299b96dba82219ca2da.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="206"></p> 
<p><strong>触发条件我选择的是推送，即当前仓库收到推送信息就会通过webhooks通知Jenkins构建项目，最后测试一下是否能正常请求，请求成功后就会执行构建</strong></p> 
<p><img alt="" height="104" src="https://img-blog.csdnimg.cn/3052689299bf4f258f55c82f61943514.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="227"><img alt="" height="98" src="https://img-blog.csdnimg.cn/1882cdea77d442a69de746bb4e6bfd20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="214"><img alt="" height="98" src="https://img-blog.csdnimg.cn/eadc088625294907ac5e192fbd716cfe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="214"></p> 
<p><strong>下面我贴出完整的前端部署命令供参考，整个流程是：推送代码后webhooks将触发Jenkins构建前端项目，构建完成后将项目复制到Nginx文件夹下并重启服务</strong></p> 
<pre><code class="language-bash">显示版本号
echo node version
node -v
echo npm version
npm -v</code></pre> 
<pre><code class="language-bash">安装依赖
npm i</code></pre> 
<pre><code class="language-bash">构建项目
npm run build</code></pre> 
<pre><code class="language-bash">复制构建好的项目至Nginx目录下
cd /d "D:\Soft\Nginx\project"
rd /s/q vue_vite
md vue_vite
xcopy "D:\Soft\Jenkins\jenkins\workspace\vue_vite_free_type\dist" "D:\Soft\Nginx\project\vue_vite" /E /Y</code></pre> 
<p><strong>不改变nginx配置的情况下，下面的可以不需要&nbsp;</strong></p> 
<pre><code class="language-bash">重启nginx服务
cd /d "D:\Soft\Nginx"
nginx -s reload
nginx -s quit
tasklist | find /i "nginx.exe" &gt;nul 2&gt;nul &amp;&amp; goto isAlive || goto isKilled
:isKilled
start nginx
:isAlive
taskkill /f /t /im nginx.exe
start nginx
</code></pre> 
<p><strong>以上就是使用window批处理命令构建前端的整个流程，下面是使用pipeline构建项目并部署的流程</strong></p> 
<h3 id="%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">流水线项目构建</h3> 
<p><strong>流水线配置和批处理命令一样，新建流水线任务，配置webhooks和token，pipeline的好处就是将每块步骤分开，直观的看到项目的构建过程</strong></p> 
<p><img alt="" height="98" src="https://img-blog.csdnimg.cn/8ba2bd513e6f466a9ec8503af23acf62.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="215"><img alt="" height="98" src="https://img-blog.csdnimg.cn/f192901dd95448898d0e4e202f288bcd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="214"><img alt="" height="93" src="https://img-blog.csdnimg.cn/ebdcc6f3a2b347a2ad20299f185edcd5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="203"></p> 
<p><strong>然后就是构建流水线脚本，这里放出我配置的一段供大家参考。</strong></p> 
<pre><code class="language-Groovy">
pipeline {
    agent any
   stages {
      stage('pull') {
         steps {
            echo 'pull code start'
            git branch: 'master',
                credentialsId: '7196d35f-xxxxxxxxxxxxxxxxxxxx-c7936ddd3dd4', 
                url: 'http://localhost:10241/xxxxxxx/vite--vue30.git'

         }
      }
      stage('build') {
         steps {
            echo "node version"
            bat "node -v"
            echo 'npm version'
            bat 'npm -v'
            echo 'install start......'
            bat "npm i"
            echo 'build start......'
            bat 'npm run build'
            echo 'build finish......'
         }
      }
      stage('deploy') {
         steps { 
            dir('d:/Soft/Nginx/project') {
                bat "rd /s/q vue_vite"
                bat "md vue_vite"
            }
            bat('xcopy "D:/Soft/Jenkins/jenkins/workspace/vue_vite_pipeline/dist" "D:/Soft/Nginx/project/vue_vite" /O /X /E /H /K')
            dir('d:/Soft/Nginx') {
                bat('start run.bat')
            }
            echo 'deploy success'
         }
         
      }
   }
}</code></pre> 
<p><strong>其中run.bat的内容如下：</strong></p> 
<pre><code class="language-bash">nginx -s reload
nginx -s quit
tasklist | find /i "nginx.exe" &gt;nul 2&gt;nul &amp;&amp; goto isAlive || goto isKilled
:isKilled
start nginx
:isAlive
taskkill /f /t /im nginx.exe
start nginx</code></pre> 
<p><strong>保存完成后来到流水线列表点击运行，程序就会开始运行。运行结束后界面会变成绿色，失败会变成红色</strong></p> 
<p><img alt="" height="99" src="https://img-blog.csdnimg.cn/9a47f0697f6f4fdd93686cb6444dbbdb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="218"><img alt="" height="99" src="https://img-blog.csdnimg.cn/3b4f03fda3e14fb1aa49239bf0727f68.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="217"><img alt="" height="100" src="https://img-blog.csdnimg.cn/db5b1e43482d4f45a22610476e058712.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="218"></p> 
<p><strong>最后输入网址就可以看到部署效果，至此，前端自动化部署就介绍这么多，有兴趣的小伙伴可以自己试试，此方法同样适用node项目部署（建议搭配<a class="link-info" href="https://pm2.keymetrics.io/">pm2</a>管理node进程），需要把build命令去掉即可。</strong></p> 
<p><img alt="" height="111" src="https://img-blog.csdnimg.cn/86ba2aee1e90435bbb7e2fada3b41798.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="242"></p> 
<h3 id="%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><strong>写在最后</strong></h3> 
<p><strong>gitee和github等远程仓库同样也支持webhooks或actions，有兴趣的小伙伴可以把Jenkins暴露在公网上配置远程服务，安利一波<a class="link-info" href="https://blog.csdn.net/time_____/article/details/114664920" title="内网穿透搭建">内网穿透搭建</a></strong></p> 
<p><strong>最后，感谢你阅读完这篇文章，如果这篇文章有帮助到你，请支持一下博主~你的支持就是博主分享文章的动力！</strong></p>
                ]]></description></item><item><title>联想Tab M10 FHD PLUS (TB-X606F)安卓10版本刷TWRP及Magisk</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/11/04/15542161.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 04 Nov 2021 08:54:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/11/04/15542161.html</guid><description><![CDATA[
                    <p><strong>感谢博友提供的参考文章：<a href="https://unofficialtwrp.com/twrp-3-5-0-root-lenovo-tb-x606f-x606fa/" title="unofficial twrp 3.5.0 Root Lenovo TB-X606F X606FA - twrp unofficial">unofficial twrp 3.5.0 Root Lenovo TB-X606F X606FA - twrp unofficial</a><br> 接上篇文章：<a href="https://blog.csdn.net/time_____/article/details/109294693" title="联想Tab M10 FHD PLUS (TB-X606F)解锁BL，获取root权限（无需第三方recovery），刷xp框架（太极-阳）适用大部分联发科CPU（国际版rom底包）_DieHunter1024的博客-CSDN博客">联想Tab M10 FHD PLUS (TB-X606F)解锁BL，获取root权限（无需第三方recovery），刷xp框架（太极-阳）适用大部分联发科CPU（国际版rom底包）_DieHunter1024的博客-CSDN博客</a></strong></p> 
<p><strong>前言：<span style="color:#fe2c24;">解答一些博友的刷机问题及分享一下最近刷安卓10及root的经历</span></strong></p> 
<ol><li><strong>无法解锁BL：需要登录联想账号并在开发者选项下勾选OEM解锁（国际版可能会被墙）</strong></li><li><strong>win10打开fastboot模式（电脑设备管理中）驱动感叹号，没办法执行解锁，一直显示waiting for driver ：我是直接在fastboot模式下用驱动人生安装驱动，<a class="link-info" href="https://gitee.com/DieHunter/myCode/blob/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo/%E5%AE%89%E5%8D%9310/Android%20ADB%20Interface_4.1.0.0_2021-11-04%2013%2040%2016.zip" title="我的仓库">我的仓库</a>里也有备份，驱动手动安装看这里：</strong><a href="https://forum.xda-developers.com/t/windows-10-mtk-vcom-usb-drivers-for-32-64-bit-driver-install-tutorial-m2.3267033/" title="Windows 10 MTK VCOM USB Drivers for 32 &amp; 64 bit + Driver install tutorial M2 | XDA Forums">Windows 10 MTK VCOM USB Drivers for 32 &amp; 64 bit + Driver install tutorial M2 | XDA Forums</a><strong>（嫌麻烦可以直接用驱动人生，或者直接用win7电脑进行）</strong></li><li><strong>刷完之后卡重启：很可能是因为包不兼容，建议选好机型后再刷，官方镜像地址：<a href="https://mirrors.lolinet.com/firmware/lenovo/Tab_M10_FHD_Plus_2nd_Gen/" title="lolinet mirrors - firmware, software, iso etc.">lolinet mirrors - firmware, software, iso etc.</a>（速度还行）</strong></li><li><strong>救砖时SP_Flash_Tool一直连不上：平板关机多试几次，也有可能是驱动没安装</strong></li></ol>
<p><strong>下面我会分享一下新版的镜像刷TWRP及Magisk的过程，线刷救砖，解锁BL参考这篇文章：<a href="https://blog.csdn.net/time_____/article/details/109294693" title="联想Tab M10 FHD PLUS (TB-X606F)解锁BL，获取root权限（无需第三方recovery），刷xp框架（太极-阳）适用大部分联发科CPU（国际版rom底包）_DieHunter1024的博客-CSDN博客">联想Tab M10 FHD PLUS (TB-X606F)解锁BL，获取root权限（无需第三方recovery），刷xp框架（太极-阳）适用大部分联发科CPU（国际版rom底包）_DieHunter1024的博客-CSDN博客</a></strong></p> 
<p><strong>准备工作：</strong></p> 
<ul><li><strong>电量充足的联想Tab M10 FHD PLUS平板</strong></li><li><strong>type-c数据线</strong></li><li><strong>电脑</strong></li><li><strong><a href="https://mirrors.lolinet.com/firmware/lenovo/Tab_M10_FHD_Plus_2nd_Gen/TB-X606F/" title="官方ROM">官方ROM</a>（我这用的是TB-X606F_S300376_210909_BMP）</strong></li><li><strong><a class="link-info" href="https://gitee.com/DieHunter/myCode/tree/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo/%E5%AE%89%E5%8D%9310/platform-tools" title="adb和fastboot工具">adb和fastboot工具</a>：platform-tools(里面已经集成了下面三个包)</strong></li><li><strong><a class="link-info" href="https://gitee.com/DieHunter/myCode/blob/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo/%E5%AE%89%E5%8D%9310/350%20Lenovo%20X606F%20X606FA.rar" title="TWRP包">TWRP包</a></strong></li><li><strong><a class="link-info" href="https://gitee.com/DieHunter/myCode/blob/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo/%E5%AE%89%E5%8D%9310/vbmeta.zip" title="vbmeta.img">vbmeta.img</a>（禁用引导验证镜像，改启动镜像）</strong></li><li><strong><a class="link-info" href="https://gitee.com/DieHunter/myCode/blob/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo/%E5%AE%89%E5%8D%9310/Magisk-v21.4.zip" title="Magisk">Magisk</a></strong></li></ul>
<p><strong>首先打开platform-tools，输入cmd，执行<span style="color:#fe2c24;">adb reboot bootloader</span>，重启平板电脑到BootLoader（fastboot）</strong></p> 
<p><strong>等待平板启动到fastboot输入<span style="color:#fe2c24;">fastboot flash recovery recovery.img</span><span style="color:#0d0016;">，刷入TWRP</span></strong></p> 
<p><img alt="" height="129" src="https://img-blog.csdnimg.cn/402ca9fbb33a47e097cdaf56afc14216.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p><strong>然后刷入&nbsp;<a class="link-info" href="https://gitee.com/DieHunter/myCode/blob/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo/%E5%AE%89%E5%8D%9310/vbmeta.zip" title="vbmeta.img">vbmeta.img</a>&nbsp;：<span style="color:#fe2c24;">fastboot flash vbmeta vbmeta.img，</span><span style="color:#0d0016;">这里碰到一个问题，刷入TWRP不生效，再刷一遍就好了</span></strong><img alt="" height="122" src="https://img-blog.csdnimg.cn/b57e8109372a483a96f9c540cfe11a0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="1200"></p> 
<p><strong><span style="color:#fe2c24;">fastboot format userdata</span>：清除用户数据</strong></p> 
<p></p> 
<p><img alt="" height="331" src="https://img-blog.csdnimg.cn/d80277de29d0497ebbf953c8f3f3869e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="1196"></p> 
<p><strong>完事之后直接进入recovery：<span style="color:#fe2c24;">fastboot reboot recovery</span><br><span style="color:#0d0016;">方法一：依次点击 ‘高级’ =&gt; ‘</span>adb sideload<span style="color:#0d0016;">’ =&gt; ‘滑动滑块’开启卡刷包推送模式，此时在</span>platform-tools中输入<span style="color:#fe2c24;">adb sideload Magisk-v21.4.zip（这种方法我没成功）</span></strong></p> 
<p></p> 
<p>&nbsp;<img alt="" height="259" src="https://img-blog.csdnimg.cn/adf7e1313cd04948937459d9f309cdc5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_13,color_FFFFFF,t_70,g_se,x_16" width="145"><img alt="" height="255" src="https://img-blog.csdnimg.cn/4fd39a454c914ca38e9527c06b825946.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_17,color_FFFFFF,t_70,g_se,x_16" width="181"><img alt="" height="249" src="https://img-blog.csdnimg.cn/8f2a0d0b9acc41fca871320fbebc67de.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="115"></p> 
<p><strong>方法二：开机状态下把<span style="color:#fe2c24;">Magisk-v21.4.zip</span><span style="color:#0d0016;">放在平板文件系统根目录，</span>进入recovery，点击安装，选择<span style="color:#fe2c24;">Magisk.</span>zip包，滑动刷入，最后安装完成，重启系统，就搞定了</strong></p> 
<p>&nbsp;<img alt="" height="379" src="https://img-blog.csdnimg.cn/f00fe340666e41f59f34f28bae3dc34d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_13,color_FFFFFF,t_70,g_se,x_16" width="213"><img alt="" height="379" src="https://img-blog.csdnimg.cn/006c362115754332aa92f6ba255fe5d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_13,color_FFFFFF,t_70,g_se,x_16" width="215"><img alt="" height="382" src="https://img-blog.csdnimg.cn/5650c4370efa49f5a38dbbc16dbe0f15.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_13,color_FFFFFF,t_70,g_se,x_16" width="215"></p> 
<p>&nbsp;<img alt="" height="440" src="https://img-blog.csdnimg.cn/b4cbaacf05714084872994ef0f359824.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="203"><img alt="" height="437" src="https://img-blog.csdnimg.cn/52c92a1f82e14879ad3b919582a1a1dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_16,color_FFFFFF,t_70,g_se,x_16" width="298"></p> 
<p><strong>&nbsp;最后，提醒各位，刷机一定要做好备份，如果这篇文章对你有帮助，请给个三连支持一下吧。附上<a class="link-info" href="https://gitee.com/DieHunter/myCode/tree/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo" title="仓库地址">仓库地址</a>，有任何问题都可以在评论区提出讨论</strong></p>
                ]]></description></item><item><title>从0到1，教你如何使用Tasker+Autojs实现自动打卡功能</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/10/24/15542162.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sun, 24 Oct 2021 02:24:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/10/24/15542162.html</guid><description><![CDATA[
                    <p><strong>你是否有上下班总会忘记打卡或者迟到的困扰，这篇文章将带你感受一下自动化工具+JS的魅力<br> 首先声明：<span style="color:#fe2c24;">本文章不针对任何第三方软件，文章中的脚本只做学习，不做商用，侵删</span><br> 准备工作：</strong></p> 
<ul><li><strong>安卓手机或模拟器，最好使用模拟器（推荐夜神模拟器安卓7的64位），因为手机条件会比较苛刻（需要root，和谷歌三件套）</strong></li><li><strong><a class="link-info" href="https://hyb1996.github.io/AutoJs-Docs/#/" title="Auto.js">Auto.js</a>软件，或者其衍生产品<a class="link-info" href="https://kkevsekk1.github.io/AutoXJs-Docs/#/" title="AutoX.js">AutoX.js</a></strong></li><li><strong>Tasker，<a class="link-info" href="https://taskerm.com/tasker-download" title="中文站">中文站</a>，<a class="link-info" href="https://tasker.joaoapps.com/download.html" title="原网站">原网站</a></strong></li><li><strong>需要自动执行的软件，我用的是 *人薪事</strong></li></ul>
<p><strong>首先，咱们熟悉一下Auto.js的调试，官方文档已经写的很清楚了，我主要概述一下抓取组件调试的过程</strong><br><strong>以AutoX.js为例，VScode安装<a class="link-info" href="https://marketplace.visualstudio.com/items?itemName=aaroncheng.auto-js-vsce-fixed" title="Auto.js-VSCodeExt-Fixed">Auto.js-VSCodeExt-Fixed</a>插件，按住ctrl+shift+p，输入auto即可进入插件的工具菜单，选择 ‘开启服务’，复制右下角服务ip及端口，就可以等待移动端连接了</strong></p> 
<p><img alt="" height="173" src="https://img-blog.csdnimg.cn/9bee191e758b4cd3b8ece0544e484de4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_19,color_FFFFFF,t_70,g_se,x_16" width="295"><img alt="" height="169" src="https://img-blog.csdnimg.cn/a2e5794c2b884ce78c5732ce2daeed2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="248"></p> 
<p><strong>如果是用手机连接，需要开启：开发者工具&gt;USB调试，模拟器则直接打开AutoXjs侧边栏的连接电脑，输入之前复制的服务ip及端口，开启调试模式</strong></p> 
<p><img alt="" height="166" src="https://img-blog.csdnimg.cn/d7def7bcb69c41dcb47f427a04296df4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="295"><img alt="" height="165" src="https://img-blog.csdnimg.cn/9a96b69954bd4ec8b6cef6f44995cc83.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="294"></p> 
<p><strong>&nbsp;打开悬浮窗，用于应用控件的抓取</strong></p> 
<p><img alt="" height="151" src="https://img-blog.csdnimg.cn/13ecdb82a57346b2a4b21882d18d1577.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="268"><img alt="" height="152" src="https://img-blog.csdnimg.cn/43ff76435efe44629fd688e038d39b12.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="268"></p> 
<p><strong>以Tasker为例，点击悬浮窗的 ‘布局分析’ ，选择布局范围分析，AutoXjs会将当前页面中的可操作控件列举出来，此时通过js代码进行事件操作即可实现自动化控制</strong></p> 
<p><img alt="" height="141" src="https://img-blog.csdnimg.cn/d4441224f8ae46ea9350cc6cb77e46f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="250"><img alt="" height="141" src="https://img-blog.csdnimg.cn/593c0cef5a2b4e8fa145f4b954f78997.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="250"><img alt="" height="142" src="https://img-blog.csdnimg.cn/de46bd76d2674710a28a023a39f64a36.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="252"><img alt="" height="140" src="https://img-blog.csdnimg.cn/8bad4952fe734da689c9c6df0a62f15d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="249"></p> 
<p><strong>&nbsp;以搜索框为例，我们实现一个 模拟搜索 的诉求</strong><br><img alt="" height="144" src="https://img-blog.csdnimg.cn/e152d9f9ac5c41f4969cbd40c898a8fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="255"><img alt="" height="147" src="https://img-blog.csdnimg.cn/91c5330f47c34588bded1cc98cfcb0cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="261"></p> 
<p><strong>根据官方文档，我们可以简单实现该功能</strong></p> 
<pre><code class="language-javascript">const appName = "Tasker",
  getSearchBtn = () =&gt; desc("搜索 Tasker"), //搜索按钮，desc文本查找控件
  getSearchInput = () =&gt; id("filter_text"), //输入框
  startSearchBtn = () =&gt; id("search"), //开始查询按钮
  str = "打卡";
console.log("launchApp:" + appName, launchApp(appName)); //打开Tasker app
console.log("getSearchBtn", getElem(getSearchBtn()).click()); //点击搜索按钮
console.log("getSearchInput", getElem(getSearchInput()).setText(str)); //输入关键字
console.log("startSearchBtn", getElem(startSearchBtn()).click()); //点击开始搜索按钮
function getElem(ele) {
  return ele.findOne();
}
</code></pre> 
<p><strong>效果如下：</strong><img alt="" height="626" src="https://img-blog.csdnimg.cn/7df4a701b77047858ea9285e91d4922e.gif" width="1200"></p> 
<p><strong>接着，咱们照葫芦画瓢，参照文档使用模拟动作实现操控其他软件的功能，比如每次执行脚本时，都会自动在打卡软件中打卡（源码放在结尾）</strong></p> 
<p><img alt="" height="626" src="https://img-blog.csdnimg.cn/d4a86752a9584193b0752bd2f0863537.gif" width="1200"></p> 
<p><strong>&nbsp;AutoX.js已经帮助我们实现了半自动打卡，距离我们的目标又近了一步</strong></p> 
<p><strong>下面我们需要使用Tasker配合AutoX.js达到触发某（些）条件时打卡即可</strong></p> 
<p><strong>打开tasker，新建任务test</strong></p> 
<p><img alt="" height="123" src="https://img-blog.csdnimg.cn/46f44558066445b5ab7201052b25aefd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="217"><img alt="" height="124" src="https://img-blog.csdnimg.cn/bc6be66ae5a14c139fcc7e0f06a5b9fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="220"><img alt="" height="128" src="https://img-blog.csdnimg.cn/ed1171dec93c4778a70a8d1389e07cb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="227"></p> 
<p><strong>在任务编辑中新建系统操作&gt;发送意图，这里我新建了一个android.intent.action.tasker的广播，用于和AutoX交互</strong></p> 
<p><img alt="" height="123" src="https://img-blog.csdnimg.cn/039cb576adaa42c8b4ed8d1559678da1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="218"><img alt="" height="120" src="https://img-blog.csdnimg.cn/0f6accab8a1d4cdeac7e7c686ce98f29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="214"><img alt="" height="117" src="https://img-blog.csdnimg.cn/67dc34fc45e94e43903bac91b2d85d04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="209"></p> 
<p><strong>我们在AutoX中新建一个脚本触发事件，当有应用触发android.intent.action.tasker时，执行这个打卡脚本</strong></p> 
<p><img alt="" height="102" src="https://img-blog.csdnimg.cn/48b46af346ca416d8dcc6292c4f531ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="180"><img alt="" height="103" src="https://img-blog.csdnimg.cn/d38d83d8995d455aabc5624497fb5a63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="183"><img alt="" height="102" src="https://img-blog.csdnimg.cn/a0103ebd96d04e39ad82e87e650c9517.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="180"><img alt="" height="100" src="https://img-blog.csdnimg.cn/cb4e781638cc41e49b5e64e529197309.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="178"></p> 
<p><strong>然后我们在Tasker中运行这个任务用来触发AutoX执行脚本</strong></p> 
<p>&nbsp;<img alt="" height="225" src="https://img-blog.csdnimg.cn/d5672eb6b10140a9b2acbe6b526ce069.gif" width="412"></p> 
<p><strong>至此，使用Tasker连接AutoX这块已经完成，接下来就是触发任务的条件了<br> 既然是自动打卡，肯定与时间地点有关系。所以，我们在Tasker的配置文件中新建配置，配置时间，和地点（需要谷歌三件套），并选择任务，当达到特定时间地点时，Tasker就会触发打卡脚本</strong></p> 
<p><img alt="" height="137" src="https://img-blog.csdnimg.cn/4264d57781be47dd85dd29b046198b9f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="244"><img alt="" height="137" src="https://img-blog.csdnimg.cn/cfe61ae900ee464a829c12517f835e75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGllSHVudGVyMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" width="244"></p> 
<p><strong>写在最后：</strong></p> 
<p><strong>使用Tasker+Autojs实现打卡固然好用，但是其对手机要求较高，如果你的手机恰好root，并装了谷歌三件套，使用起来会比较方便。其他同学推荐使用安卓模拟器实现。</strong></p> 
<p><strong>源码：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/AutoJs&amp;Tasker" title="myCode: 一些小案例 - Gitee.com">myCode: 一些小案例 - Gitee.com</a></p> 
<p><strong>如果这篇文章对你有帮助，请帮忙点个赞！感谢</strong></p>
                ]]></description></item><item><title>浅析MVVM原理，实现一个mini-vue</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/08/08/15215826.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sun, 08 Aug 2021 15:08:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/08/08/15215826.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:40px;"><a href="#main-toc">前言</a></p> 
<p id="MVVM-toc" style="margin-left:40px;"><a href="#MVVM">MVVM</a></p> 
<p id="%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">mini-vue实现</a></p> 
<p id="Compile%EF%BC%88%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90%EF%BC%89-toc" style="margin-left:80px;"><a href="#Compile%EF%BC%88%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90%EF%BC%89">Compile（指令解析）</a></p> 
<p id="updater-toc" style="margin-left:80px;"><a href="#updater">Updater（视图更新）</a></p> 
<p id="proxy-toc" style="margin-left:80px;"><a href="#proxy">Proxy（代理data）</a></p> 
<p id="observer-toc" style="margin-left:80px;"><a href="#observer">Observer（数据劫持）</a></p> 
<p id="dep-toc" style="margin-left:80px;"><a href="#dep">Dep（调度中心）</a></p> 
<p id="watcher-toc" style="margin-left:80px;"><a href="#watcher">Watcher（数据观察）</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E6%8E%A5">函数的连接</a></p> 
<p id="%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E-toc" style="margin-left:40px;"><a href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">写在最后</a></p> 
<hr id="hr-toc">
<h2><strong>前言</strong></h2> 
<p id="MVVM%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AFMVC%E7%9A%84%E6%94%B9%E8%BF%9B%E7%89%88%EF%BC%8C%E5%85%B6%E7%AB%8B%E8%B6%B3%E4%BA%8EMVP%E6%A1%86%E6%9E%B6%E3%80%82%E4%BD%BF%E7%94%A8Vue%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BC%9A%E4%BD%93%E4%BC%9A%E5%88%B0%E5%85%B6%E4%B8%8EReact%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%BB%91%E5%AE%9A%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E6%97%B6react%E5%AF%B9%E8%BE%93%E5%85%A5%E6%A1%86%E8%AF%BB%E5%86%99%E9%9C%80%E8%A6%81input%E4%BA%8B%E4%BB%B6%E8%AE%BE%E7%BD%AEstate%EF%BC%8C%E4%BB%A5%E5%8F%8Avalue%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%80%8Cvue%E5%88%99%E5%8F%AA%E9%9C%80%E5%B0%86%E6%95%B0%E6%8D%AE%E4%B8%8Emodel%E7%BB%91%E5%AE%9A%E5%8D%B3%E5%8F%AF%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%8D%B4%E4%B8%8E%E8%A7%86%E5%9B%BE%E8%A7%A3%E8%80%A6%E7%9A%84%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%BE%88%E6%96%B9%E4%BE%BF%E3%80%82%E4%B8%BA%E4%BA%86%E6%B7%B1%E5%85%A5%E4%BD%93%E9%AA%8Cmvvm%E7%9A%84%E9%AD%85%E5%8A%9B%EF%BC%8C%E6%88%91%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AAmini-vue%E3%80%82%E8%AF%9D%E4%B8%8D%E5%A4%9A%E8%AF%B4%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%BC%80%E5%A7%8B"><strong>MVVM实际上是MVC的改进版，其立足于MVP框架。使用Vue时，我们会体会到其与React的区别，绑定表单数据时react对输入框读写需要input事件设置state，以及value绑定，而vue则只需将数据与model绑定即可，这种数据驱动视图却与视图解耦的编程方式使用起来很方便。以前面试官问vue原理，若能说出双向绑定实现和Object.defineProperty就已经够了，现在随着对vue深入的学习，面试官已经不仅仅局限于此。所以，为了深入体验mvvm模式，我实现了一个mini-vue。</strong></p> 
<h2 id="MVVM"><strong>MVVM</strong></h2> 
<p><strong>在开始前，我们先试着参照下图实现一个简单的双向绑定案例</strong></p> 
<p>&nbsp;<img alt="" height="300" src="https://img-blog.csdnimg.cn/20210806143347529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="560"></p> 
<p><strong>DOM通过eventListener修改Model，Model通过修改data驱动视图</strong></p> 
<p><img alt="" height="122" src="https://img-blog.csdnimg.cn/20210806144123455.gif" width="468"></p> 
<p><strong>&nbsp;在html&gt;body中添加以下代码就可以实现</strong></p> 
<pre><code class="language-javascript">    &lt;input id="input-box" type="text"&gt;
    &lt;div id="show-text"&gt;&lt;/div&gt;
    &lt;script&gt;
        const showText = document.querySelector('#show-text')
        const inputBox = document.querySelector('#input-box')
        class VM {
            data = {
                value: ''
            }
            constructor() {
                Object.defineProperty(this.data, 'value', {
                    set(v) {
                        showText.textContent = v
                    },
                    get() {
                        return showText.textContent
                    }
                })
            }
        }

        const vm = new VM()
        inputBox.addEventListener('input', function (e) {
            vm.data.value = e.target.value
            console.log(vm.data.value)
        })
    &lt;/script&gt;</code></pre> 
<p><strong>在上述代码中，我们可以使用Object.defineProperty将data和textContent的值绑定，从而达到数据驱动视图的效果，那么这样就够了吗？</strong></p> 
<h2 id="%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">mini-vue实现</h2> 
<p><strong>下面是双向绑定的流程<br><img alt="" src="https://img-blog.csdnimg.cn/2021080611515858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70"></strong><br><strong>通过上图我们可以得知：new MVVM后会进行两步操作，<span style="color:#fe2c24;">一是compile指令解析</span>，将v-if,@click,{<!-- -->{&nbsp; }}解析出来，获取data中的数据，并且都与<span style="color:#fe2c24;">watcher</span>绑定，第一次初始化和<span style="color:#fe2c24;">watcher</span>监听到数据变化时会执行updater，重新渲染页面，<span style="color:#fe2c24;">二是observer数据劫持</span>，将data中的数据通过defineProperty添加读写监听，并将数据变化与<span style="color:#fe2c24;">watcher</span>绑定在一起，那么此时watcher就是连接数据变化和视图更新的枢纽。</strong></p> 
<p><strong>下面我们一步一步实现上述代码</strong></p> 
<h3 id="Compile%EF%BC%88%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90%EF%BC%89"><strong>Compile（</strong>指令解析<strong>）</strong></h3> 
<p><strong>我们回顾一下vue是如何使用的，标签中各种v-if，v-show，v-html，以及@click等等属性，绑定着data中的属性和methods中的函数</strong></p> 
<pre><code class="language-html">    &lt;div id="app"&gt;
        &lt;span v-text='title.name'&gt;&lt;/span&gt;
        &lt;div v-if='isRender'&gt;
            &lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;2&lt;/span&gt;
            &lt;span&gt;3&lt;/span&gt;
        &lt;/div&gt;
        &lt;ul&gt;
            &lt;li v-if='isRender'&gt;{<!-- -->{info.name}}---{<!-- -->{info.age}}---{<!-- -->{modelData}}---{<!-- -->{inputVal.item.value}}&lt;/li&gt;
            &lt;li v-show='isShow'&gt;{<!-- -->{info.age}}&lt;/li&gt;
            &lt;li v-if='isRender'&gt;{<!-- -->{modelData}}&lt;/li&gt;
            &lt;li v-show='isShow'&gt;{<!-- -->{inputVal.item.value}}&lt;/li&gt;
        &lt;/ul&gt;
        &lt;span v-text='inputVal.item.value'&gt;&lt;/span&gt;
        &lt;div v-html='htmlTemp'&gt;&lt;/div&gt;
        &lt;div v-show='isShow'&gt;world&lt;/div&gt;
        &lt;button v-on:click='handlerShow'&gt;点击显示&lt;/button&gt;
        &lt;button @click='handlerRender'&gt;点击渲染&lt;/button&gt;
        &lt;input v-model='modelData' type="text"&gt;
        &lt;input v-model='inputVal.item.value' type="text"&gt;
    &lt;/div&gt;</code></pre> 
<p><strong>而实例化vue则是将数据和函数初始化到vue中</strong></p> 
<pre><code class="language-javascript">        let vm = new Vue({
            el: '#app',
            data: {
                title: {
                    name: 'hello'
                },
                info: {
                    name: '张三',
                    age: 23,
                },
                isShow: true,
                isRender: true,
                modelData: 123,
                htmlTemp: '&lt;span style="color:red;"&gt;html&lt;/span&gt;',
                inputVal: {
                    item: {
                        value: 'abc'
                    }
                }
            },
            methods: {
                handlerShow() {
                    this.isShow = !this.isShow
                },
                handlerRender() {
                    this.isRender = !this.isRender
                }
            },
        })</code></pre> 
<p><strong>那么，我们要如何去让js识别这些指令并渲染视图呢<br> 首先，创建标签碎片，将Dom元素获取到DocumentFragment中，以便于解析指令及根据指令对视图响应，其次，将标签属性分离，每种指令对应一种响应方式（updater）。最后绑定watcher监听到数据变化时，再次触发updater<br><span style="color:#fe2c24;">以下是compile.js</span>，用来解析标签内容和属性</strong></p> 
<pre><code class="language-javascript">// 指令解析器
const textRegex = /\{\{(.+?)\}\}/g //解析{<!-- -->{}}的正则
class Compile {
    constructor(elem, vm) {
        this.elem = isElemNode(elem) === '1' ? elem : document.querySelector(elem)
        this.vm = vm
        const fragment = this.createFragment(this.elem)
        this.getTemp(fragment, this.vm)
        this.elem.appendChild(fragment);
    }
    // 递归子元素，查找所有元素
    getTemp(fragment, vm) {
        const fragmentChild = Array.from(fragment.childNodes)
        fragmentChild.forEach(item =&gt; {
            this.filterElem(item, vm)
            item.childNodes &amp;&amp; item.childNodes.length &amp;&amp; this.getTemp(item, vm)
        })
    }
    // 创建标签碎片，将dom元素添加到标签碎片中
    createFragment(elem) {
        const fragment = document.createDocumentFragment();
        while (elem.firstChild) {
            fragment.append(elem.firstChild)
        }
        return fragment
    }

    // 针对不同元素节点进行分离
    filterElem(elem, vm) {
        switch (isElemNode(elem)) {
            case 1: //元素节点
                this.renderNode(elem, vm)
                break;
            case 3: //文本节点
                this.renderText(elem, vm)
                break;
        }
    }
    // 渲染文本，主要解析‘{<!-- -->{}}’及多个‘{<!-- -->{}}’
    renderText(elem, vm) {
        textRegex.test(elem.textContent) &amp;&amp; updater(elem, vm, elem.textContent, 'text-content')
    }
    // 渲染标签
    renderNode(elem, vm) {
        //取出所有属性和值
        Array.from(elem.attributes).forEach(attr =&gt; {
            const {
                name,
                value
            } = attr;
            // 过滤‘v-’和‘@’操作，并移除标签属性
            name.startsWith('v-') ? (this.compileV_Command(elem, vm, name, value), removeAttr(elem, name)) : name.startsWith('@') ? (this.compileEventComment(elem, vm, name.split('@')[1], value), removeAttr(elem, name)) : null
        })
    }
    // v- 指令解析,指令
    compileV_Command(elem, vm, name, value) {
        const key = name.split('v-')
        const eventCommand = key[1] &amp;&amp; key[1].split(':')[1]
        // v-model事件
        key[1] === 'model' &amp;&amp; this.compileEventComment(elem, vm, 'input', value, e =&gt; {
            setDeepData(vm, value, e.target.value)
        })
        // 过滤指令是否为事件
        eventCommand ? this.compileEventComment(elem, vm, eventCommand, value) : updater(elem, vm, value, key[1])
    }
    // @ 指令解析,事件
    compileEventComment(elem, vm, name, value, fn) {
        !fn &amp;&amp; elem.addEventListener(name, vm.options.methods[value].bind(vm))
        fn &amp;&amp; elem.addEventListener(name, fn.bind(vm))
    }
}</code></pre> 
<h3 id="updater">Updater（视图更新）</h3> 
<p><strong>指令解析完后自然需要<span style="color:#fe2c24;">updater.js</span>，对当前元素进行下一步渲染，在此之前，我们的值需要从vue.data中取，这样才能将data数据绑定到标签中，lodash有两个函数一个是_.get()，另一个是_.set()，作用是获取和设置对象某一层某个值，所以我们需要在utils（工具函数）中实现一下</strong></p> 
<p><strong>utils.js</strong></p> 
<pre><code class="language-javascript">//lodash中的 _.get()，获取对象多级属性
function getDeepData(object, path, defaultValue) {
    const paths = path.split('.')
    for (const i of paths) { //逐层遍历path
        object = object[i]
        if (object === undefined) { //不能用 '!object' null，0，false等等会等于false
            return defaultValue
        }
    }
    return object
}
//lodash中的 _.set()，赋值对象某级属性
function setDeepData(object, path, value) {
    const paths = path.split('.')
    const last = paths[paths.length - 1]//为何要在length - 1时赋值：因为object的引用关系使得我们可以一级一级赋值，而当最后一项是基本类型时，无法将引用的值赋给原始的object
    let _obj = object
    for (const i of paths) {
        last === i &amp;&amp; (_obj[last] = value)
        _obj = _obj[i]
    }
}
// 移除属性值
function removeAttr(elem, key) {
    elem.removeAttribute(key)
}
// 获取标签类型
function isElemNode(elem) {
    return elem.nodeType
}</code></pre> 
<p><strong>updater.js&nbsp;</strong></p> 
<pre><code class="language-javascript">// 更新视图,标签中指令属性处理
function updater(elem, vm, value, type) {
    switch (type) {
        case 'text':
                elem.textContent = getDeepData(vm.data, value)
            break;
        case 'text-content':
                elem.textContent = value.replace(textRegex, (..._) =&gt; getDeepData(vm.data, _[1]))
            break;
        case 'html':
                elem.innerHTML = getDeepData(vm.data, value)
            break;
        case 'model':
                elem.value = getDeepData(vm.data, value)
            break;
        case 'if':
            const temp = document.createTextNode('')
            elem.parentNode.insertBefore(temp, elem);
                getDeepData(vm.data, value) ? temp.parentNode.insertBefore(elem, temp) : temp.parentNode.removeChild(elem)
            break;
        case 'show':
                elem.hidden = !getDeepData(vm.data, value)
            break;
    }
}</code></pre> 
<p><strong>完成这一步后，我们在vue.js中调用</strong></p> 
<pre><code class="language-javascript">class VueDemo {
    constructor(options) {
        this.options = options //配置信息
        this.data = options.data;
        // 判断options.el是否存在
        (this.el = options.el) &amp;&amp; Object.defineProperties(this, {
            compile: {
                value: new Compile(options.el, this) //指令解析器
            }
        })
    }
}</code></pre> 
<p><strong>效果出来了，指令被解析出来并且在页面中显示</strong></p> 
<p><img alt="" height="153" src="https://img-blog.csdnimg.cn/20210808210242262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="290"></p> 
<h3 id="proxy"><strong>Proxy（代理data）</strong></h3> 
<p><strong>我们虽然将vue.data中的数据渲染到了页面，但是还是需要通过this.data来获取数据，而vue可以中直接通过this来拿到数据，此时我们需要新建一个proxy.js将this.data代理到this上</strong></p> 
<pre><code class="language-javascript">// data数据代理到vue
class DataProxy {
    constructor(data, vm) {
        for (const key in data) {
            Object.defineProperty(vm, key, {
                get() {
                    return data[key];
                },
                set(val) {
                    data[key] = val;
                }
            })
        }
        return data
    }
}</code></pre> 
<p><strong>在vue.js中调用，并将updater.js&nbsp;中的vm.data改成vm</strong></p> 
<pre><code class="language-javascript">class VueDemo {
    constructor(options) {
        this.options = options //配置信息
        this.$data = options.data;
        // 判断options.el是否存在
        (this.el = options.el) &amp;&amp; Object.defineProperties(this, {
            proxy: {
                value: new DataProxy(options.data, this) //data代理到this
            },
            compile: {
                value: new Compile(options.el, this) //指令解析器
            }
        })
    }
}</code></pre> 
<p><strong>写到这里，compile和updater已经实现了，接下来将是数据劫持的实现方式</strong><br><img alt="" height="116" src="https://img-blog.csdnimg.cn/20210808211540592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="228"></p> 
<h3 id="observer">Observer（数据劫持）</h3> 
<p><strong>这一步的作用是将data中的数据都加上读写响应控制，给所有数据绑定可以更新视图的函数</strong></p> 
<pre><code class="language-javascript">// 发布模式
class Observer {
    constructor(data) {
        this.initObserver(data)
    }
    // 劫持所有数据
    initObserver(data) {
        if (data &amp;&amp; typeof data === 'object') {
            for (const key in data) {
                this.defineReactive(data, key, data[key])
            }
        }
    }
    // 响应拦截器，递归监听所有层级
    defineReactive(data, key, val) {
        this.initObserver(val) //劫持子项
        Object.defineProperty(data, key, {
            enumerable: true, // 允许枚举
            configurable: false, // 不能被定义
            get: _ =&gt;  val,//初始化获取值时对dep绑定
            set: newVal =&gt; val = newVal
        })
    }
}</code></pre> 
<h3 id="dep">Dep（调度中心）</h3> 
<p><strong>watcher的作用是将上面的observer与视图的刷新函数updater进行连接，当observer监测到数据变化时会通过dep告诉watcher，watcher就会执行updater更新视图，于是，我们需要先实现observer与watcher之间的观察者dep，我们先假定watcher中更新视图的函数名字叫compareVal，将watcher注册到调度中心中</strong></p> 
<pre><code class="language-javascript">// 调度中心（观察者模式）
class Dep {
    observerList = [] //调度中心,存放与属性绑定的事件
    //触发所有与该属性绑定的事件
    fireEvent() {
        this.observerList.forEach(target =&gt; {
            target.compareVal()
        })
    }
    //注册事件
    subscribe(target) {
        target.compareVal &amp;&amp; this.observerList.push(target)
    }
}</code></pre> 
<h3 id="watcher"><strong>Watcher（数据观察）</strong></h3> 
<p><strong>watcher的作用是连接observer和compile，使数据和视图绑定<br> 以下是watcher.js的实现</strong></p> 
<pre><code class="language-javascript">// 订阅模式(比较绑定值的变化)
class Watcher {
    constructor(vm, val, update) {
        this.vm = vm
        this.val = val;
        this.update = update
        this.oldVal = getDeepData(this.vm, this.val)
        update() //首次渲染初始化
    }
    // 对比数据，更新视图
    compareVal() {
        const newVal = getDeepData(this.vm, this.val);
        newVal !== this.oldVal &amp;&amp; (this.update(), this.oldVal = newVal) //更新视图后将新值赋到oldVal上
    }
}</code></pre> 
<h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E6%8E%A5"><strong>函数的连接</strong></h3> 
<p><strong>我们来回顾一下以上功能的实现</strong><br><img alt="" height="271" src="https://img-blog.csdnimg.cn/20210808220840105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="501"></p> 
<p><strong>整个流程中的函数部分已经全部实现，只剩下如何将他们联系在一起，这时如果你对整个功能实现还有些模糊，那请认真分析一下这张流程图，并继续看下去吧</strong></p> 
<p><strong>首先我们把watcher和指令解析以及updater之间的关系实现。<br> 在updater中给予每一个指令一个watcher，将更新视图操作绑定到watcher中，由compareVal来更新视图</strong></p> 
<pre><code class="language-javascript">// 更新视图,标签中指令属性处理
function updater(elem, vm, value, type) {
    switch (type) {
        case 'text':
            new Watcher(vm, value, _ =&gt; {
                elem.textContent = getDeepData(vm, value)
            })
            break;
        case 'text-content':
            value.replace(textRegex, (..._) =&gt; { //外面的content.replace获取所有{<!-- -->{}}中的属性
                new Watcher(vm, _[1], _ =&gt; { //里面的content.replace获取data中绑定的值
                    elem.textContent = value.replace(textRegex, (..._) =&gt; getDeepData(vm, _[1]))
                })
            })
            break;
        case 'html':
            new Watcher(vm, value, _ =&gt; {
                elem.innerHTML = getDeepData(vm, value)
            })
            break;
        case 'model':
            new Watcher(vm, value, _ =&gt; {
                elem.value = getDeepData(vm, value)
            })
            break;
        case 'if':
            const temp = document.createTextNode('')
            elem.parentNode.insertBefore(temp, elem);
            new Watcher(vm, value, _ =&gt; {
                getDeepData(vm, value) ? temp.parentNode.insertBefore(elem, temp) : temp.parentNode.removeChild(elem)
            })
            break;
        case 'show':
            new Watcher(vm, value, _ =&gt; {
                elem.hidden = !getDeepData(vm, value)
            })
            break;
    }
}</code></pre> 
<p><strong>那么如何告诉watcher数据发生了改变呢？<br> 在watcher中我们获取oldvalue时采用this.oldVal = getDeepData(this.vm, this.val)<br> 这个操作会使observer中data属性的get被触发，此时如果我们将watcher注册到dep中即可对所有数据变化进行监听，然鹅，在实现的时候，发现了一些问题，由于defineReactive将data所有属性都监听了，导致取属性时使用{<!-- -->{info.name}}时，data.info和data.info.name都会被劫持，而我们只需要info.name，所以，当dep注册watcher时需要设置一个开关，并且在observer中根据开关添加监听，修改的watcher和observer如下：<br> watcher.js</strong></p> 
<pre><code class="language-javascript">// 订阅模式(比较绑定值的变化)
class Watcher {
    constructor(vm, val, update) {
        this.vm = vm
        this.val = val;
        this.update = update
        this.oldVal = this.getOldVal() //获取初始值，触发observer中属性的get
        update() //首次渲染初始化
    }
    getOldVal() {
        Dep.target = this //将watcher暂存到Dep上，在Observer中通过dep.subscribe将watcher传到dep的observerList（调度中心）中，后续当值发送修改时通过fireEvent触发watcher.compareVal来更新视图
        const oldVal = getDeepData(this.vm, this.val) //触发Observer中的getter，将watcher注册到dep中
        Dep.target = null
        return oldVal
    }
    // 对比数据，更新视图
    compareVal() {
        const newVal = getDeepData(this.vm, this.val);
        newVal !== this.oldVal &amp;&amp; (this.update(), this.oldVal = newVal) //更新视图后将新值赋到oldVal上
    }

}</code></pre> 
<p><strong>observer.js中的defineReactive</strong></p> 
<pre><code class="language-javascript">    // 响应拦截器，递归监听所有层级
    defineReactive(data, key, val) {
        this.initObserver(val) //劫持子项
        const dep = new Dep() //将observer与watcher连接，当watcher触发数据变化后，将watcher中的回调函数注册到dep中
        Object.defineProperty(data, key, {
            enumerable: true, // 允许枚举
            configurable: false, // 不能被定义
            get: _ =&gt; {
                Dep.target &amp;&amp; dep.subscribe(Dep.target); //获取属性值时,将watcher中的回调函数注册到dep中（在页面初始化时调用）
                return val
            },
            set: newVal =&gt; newVal !== val &amp;&amp; (val = newVal) //设置属性时，对比新值和旧值有无差别
        })
    }</code></pre> 
<p><strong>现在，我们只剩下当数据发生改变时，如何通知watcher，因为上述的defineReactive中已经将watcher注册到了dep，此时我们只需在数据变化时也就是defineReactive的set中对数据更新进行响应，当某条数据被设置时，我们将dep中watcher触发即可</strong></p> 
<pre><code class="language-javascript">    // 响应拦截器，递归监听所有层级
    defineReactive(data, key, val) {
        this.initObserver(val) //劫持子项
        const dep = new Dep() //将observer与watcher连接，当watcher触发数据变化后，将watcher中的回调函数注册到dep中
        Object.defineProperty(data, key, {
            enumerable: true, // 允许枚举
            configurable: false, // 不能被定义
            get: _ =&gt; {
                Dep.target &amp;&amp; dep.subscribe(Dep.target); //获取属性值时,将watcher中的回调函数注册到dep中（在页面初始化时调用）
                return val
            },
            set: newVal =&gt; newVal !== val &amp;&amp; (val = newVal, this.initObserver(newVal), dep.fireEvent()) //设置属性时，对比新值和旧值有无差别，若修改的值是引用型时，将属性重新注册到dep中,并更新视图
        })
    }</code></pre> 
<p><strong>至此，流程图中的所有功能均已实现，让我们在vue.js中实例化observer试试效果</strong></p> 
<pre><code class="language-javascript">class VueDemo {
    constructor(options) {
        this.options = options //配置信息
        this.$data = options.data;
        // 判断options.el是否存在
        (this.el = options.el) &amp;&amp; Object.defineProperties(this, {
            //observer和compile的顺序不要错，否则监听不到compile中的数据
            observer: {
                value: new Observer(options.data) // 数据监听器
            },
            proxy: {
                value: new DataProxy(options.data, this) //data代理到this
            },
            compile: {
                value: new Compile(options.el, this) //指令解析器
            }
        })
    }
}</code></pre> 
<p><img alt="" height="236" src="https://img-blog.csdnimg.cn/20210808225030888.gif" width="452"></p> 
<h2 id="%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E">写在最后</h2> 
<p><strong>感谢你看到了最后，希望文章能对你有帮助，同时也欢迎你提出宝贵的建议</strong></p> 
<p><strong>最后附上<a href="https://gitee.com/DieHunter/myCode/tree/master/Vue%E5%8E%9F%E7%90%86">源码地址</a><br> 喜欢这篇文章别忘了点个赞，你的支持是作者创作的动力</strong></p>
                ]]></description></item><item><title>JS案例：支持PC端和Mobile端的Canvas电子签名功能</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/05/13/15215827.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 13 May 2021 10:33:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/05/13/15215827.html</guid><description><![CDATA[
                    <p><strong>前言：<br> 这段时间项目迭代时遇到了一个新需求，基于react实现一个Pc版电子签名功能，并生成图片上传。于是我想到了<a href="https://github.com/szimek/signature_pad/">signature_pad</a>，并且在项目使用了这个插件<br> 不得不说，用别人造的轮子是真的香，出于好奇，想用原生实现一下电子签名的功能</strong></p> 
<p><strong>以下是实现过程</strong></p> 
<p><strong>HTML和css可以参照<a href="https://gitee.com/DieHunter/myCode/tree/master/PrintPen">源码</a>，这里不过多介绍</strong></p> 
<p><strong>首先引入<a href="https://gitee.com/DieHunter/myCode/blob/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&amp;%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/PubSubPattern/js/eventBus.js">eventBus</a>，方便代码解耦<br> 然后实现Base基类存放公共方法和属性，后续有啥共用属性或方法可以往这加</strong></p> 
<pre><code class="language-javascript">//基类：公共方法和属性
import event from './eventBus.js'
export default class Base {
    constructor(canvasEle, dom = document) {
        this.event = event //注册发布订阅
        this.canvasEle = canvasEle //待操作的画布标签
        this.dom = dom //dom
        return this;
    }
}</code></pre> 
<p><strong>完成之后，我们先实现Pc版的电子签名功能，新建一个PcPrint继承自Base，参照之前写的<a href="https://blog.csdn.net/time_____/article/details/104444502">鼠标拖拽案例</a>，实现在canvas上拖拽功能，并将事件结果的坐标发布出去。<br> 其中clearDefaultEvent函数和getClient函数在Base类中实现</strong></p> 
<pre><code class="language-javascript">// PC端，鼠标事件
import Base from './base.js'
let that = null
export default class PcPrint extends Base {
    constructor(ele, dom) {
        super(ele, dom)
        that = this //注册全局this
        this.init()
        return this;
    }
    init() {
        that.canvasEle.addEventListener('mousedown', that.onMouseDown)
    }
    onMouseDown(e = event) {
        that.clearDefaultEvent(e)
        that.dom.addEventListener('mouseup', that.onMouseUp) //给dom添加mouseup避免产生鼠标点下时，移出画布造成其他的问题
        that.canvasEle.addEventListener('mousemove', that.onMouseMove)
        that.event.emitEvent('pointStart', that.getClient(e)) //触发开始签字事件
    }
    onMouseUp(e = event) {
        that.clearDefaultEvent(e)
        that.event.emitEvent('pointEnd') //触发结束签字事件
        that.canvasEle.removeEventListener('mousemove', that.onMouseMove) //移除移动事件
    }
    onMouseMove(e = event) {
        that.clearDefaultEvent(e)
        that.event.emitEvent('pointMove', that.getClient(e)) //触发签字事件
    }

}</code></pre> 
<p><strong>Base类添加以下代码：</strong></p> 
<pre><code class="language-javascript">    /**
     * 取消默认事件和事件冒泡
     * @param e 事件对象
     */
    clearDefaultEvent(e) {
        e.preventDefault()
        e.stopPropagation()
    }
    /**
     * 获取事件元素离body可视区域的坐标
     * @param target 事件目标
     */
    getClient(target) {
        return {
            x: target.clientX,
            y: target.clientY
        }
    }</code></pre> 
<p><strong>接着，我们对事件抛出的三个发布进行订阅，新建Print类，对获取的坐标通过canvas进行绘制</strong></p> 
<pre><code class="language-javascript">import Base from "./Base.js"
import PcPrint from './pc.js';
// import MobilePrint from './mobile.js';
let that = null
export default class Print extends Base {
    constructor(canvasEle, options, dom) {
        super(canvasEle, dom)
        that = this
        this.options = options //配置画笔颜色，粗细，是否开启移动端或PC端，
        this.init() //初始化属性,配置,注册发布订阅等
        this.initCanvas() //初始化画布
        return this
    }
    init() {
        //Pc和Mobile启用开关
        this.Pc = this.options.Pc ? (new PcPrint(this.canvasEle)) : null
        // this.Mobile = this.options.Mobile ? (new MobilePrint(this.canvasEle)) : null
        this.point = null //存储上一次坐标
        this.event.onEvent('pointMove', that.pointMove) //订阅签字事件
        this.event.onEvent('pointStart', that.pointStart) //订阅签字开始事件
        this.event.onEvent('pointEnd', that.pointEnd) //订阅签字结束事件
    }
    initCanvas() {
        this.clientRect = this.canvasEle.getBoundingClientRect() // 获取标签相对可视区域的偏移量
        this.canvasEle.width = this.canvasEle.parentNode.offsetWidth //设置为父元素的宽
        this.canvasEle.height = this.canvasEle.parentNode.offsetHeight //设置为父元素的高
        this.context = this.canvasEle.getContext('2d')
        this.context.strokeStyle = this.options.color; // 线条颜色
        this.context.lineWidth = this.options.weight; // 线条宽度
    }
    pointStart(point) {
        that.point = that.shiftingPosition(point, that.clientRect) //初始化起始位置
    }
    pointEnd() {
        that.point = null //清空起始位置
    }
    pointMove(point) {
        that.canvasDraw(that.shiftingPosition(point, that.clientRect)) //签字效果
    }
    canvasDraw(point) { //画布操作
        this.context.beginPath() //新建(重置)路径
        this.context.moveTo(this.point.x, this.point.y) //画布绘画起始点移动到前一个坐标
        this.context.lineTo(point.x, point.y) //画布从前一个坐标到当前坐标
        this.context.stroke() //从moveTo到lineTo进行绘制
        this.context.closePath() //创建从当前坐标回到前一个坐标的路径
        that.point = point //将此次坐标赋值给下一次移动时的前一个坐标
    }
}</code></pre> 
<p><strong>考虑到canvas的偏移问题，在Base中添加shiftingPosition函数，解决画布绘制时坐标偏移问题</strong></p> 
<pre><code class="language-javascript">   /**
     * 抵消画布偏移
     * @param point 当前坐标
     * @param shift 偏移量
     */
    shiftingPosition(point, shift) {
        return {
            x: point.x - shift.left,
            y: point.y - shift.top
        }
    }</code></pre> 
<p><strong>最后，在index中实例化电子签名</strong></p> 
<pre><code class="language-html">&lt;script type="module"&gt;
    import Print from "./js/print.js"
    new Print(printBox,{
        Pc:true,
        Mobile:true,
        color:'lightcoral',
        weight:5
    })
&lt;/script&gt;</code></pre> 
<p><strong>效果如下：</strong><br><img alt="" height="203" src="https://img-blog.csdnimg.cn/20210513181545194.gif" width="428"></p> 
<p><strong>Pc端实现完成之后是Mobile端，代码大同小异，除了事件类型不用之外，还一点就是移动端的多指触碰支持，touchevent支持双指事件，此时我们要判断是否单指输入</strong></p> 
<pre><code class="language-javascript">// Mobile端，触摸事件
import Base from './base.js'
let that = null
export default class MobilePrint extends Base {
    constructor(ele, dom) {
        super(ele, dom)
        that = this //注册全局this
        this.init()
        return this;
    }
    init() {
        that.canvasEle.addEventListener('touchstart', that.onTouchStart)
    }
    onTouchStart(e = event) {
        that.clearDefaultEvent(e)
        that.canvasEle.addEventListener('touchend', that.onTouchEnd) //没有像pc一样给dom添加touchend,因为touchmove是基于touchstart和touchend之间触发的，只要touchend触发，touchmove便失效
        that.canvasEle.addEventListener('touchmove', that.onTouchMove)
        that.event.emitEvent('pointStart', that.getClient(e.touches[0])) //这里可以做一个判断e.touches是否只有一个（e.touches表示有几个手指触碰）
    }
    onTouchEnd(e = event) {
        that.clearDefaultEvent(e)
        that.event.emitEvent('pointEnd')
        that.canvasEle.removeEventListener('touchmove', that.onTouchMove)
    }
    onTouchMove(e = event) {
        that.clearDefaultEvent(e)
        that.event.emitEvent('pointMove', that.getClient(e.touches[0]))
    }
}</code></pre> 
<p><strong>在移动端实现的效果：</strong></p> 
<p><img alt="" height="308" src="https://img-blog.csdnimg.cn/20210513182906294.gif" width="162"></p> 
<p><strong>最后：<br> 附上源码地址：<a href="https://gitee.com/DieHunter/myCode/tree/master/PrintPen">Gitee</a></strong></p> 
<p><strong>感谢你的阅读，如果这篇文章对你有帮助，希望三连支持一下，你的支持是我创作的动力，同时也欢迎大佬建议指正</strong></p>
                ]]></description></item><item><title>JS案例：将前端页面导出为PDF</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/04/28/15215828.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Wed, 28 Apr 2021 03:16:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/04/28/15215828.html</guid><description><![CDATA[
                    <p><strong>前言：<br> 记录一下最近的一个需求，产品需要打印表单凭证，需要实现将选中页面的元素或者是组件导出为PDF，方便打印<br> 使用到的JS库：<a href="http://html2canvas.hertzen.com/">html2canvas</a>（截取页面生成canvas），<a href="https://github.com/MrRio/jsPDF">jsPDF</a>（使用JS生成PDF）</strong></p> 
<p><strong>下面我针对该需求实现一个简单的Demo，并且分享一下遇到的问题</strong></p> 
<p><strong>首先，我选择了<a href="https://gitee.com/DieHunter/myCode/tree/master/%E7%80%91%E5%B8%83%E6%B5%81&amp;%E6%87%92%E5%8A%A0%E8%BD%BD/First">懒加载</a>的案例作为测试对象，因为图片可以检测截图效果，并且有滚动加载长页面<br> 我们把整个demo分为两部分，分别是使用上述两个插件实现基本功能</strong></p> 
<p><strong>使用html2canvas截屏生成canvas</strong></p> 
<pre><code class="language-javascript">        let printEle, //截图按钮
            pdfEle, //待截取标签
            canvasBox //canvas显示区域

        (function init(_win, _dom) {
            printEle = _dom.querySelector('#printEle')
            pdfEle = _dom.querySelector('#pdfEle')
            canvasBox = _dom.querySelector('#canvasBox')
            printEle.addEventListener('click', clickHandler) //点击按钮生成截屏
        })(window, document)

        async function clickHandler(e) {
            if (canvasBox.children.length) return //若canvas显示区域已经有标签则退出
            const canvas = await html2canvas(pdfEle, { //截取标签转换为canvas
                background: '#FFFFFF',
            })
            pdfEle.hidden = true //隐藏之前的元素，更好对比
            canvasBox.appendChild(canvas) //显示效果
        }</code></pre> 
<p><strong>原图&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;截图</strong></p> 
<p><img alt="" height="244" src="https://img-blog.csdnimg.cn/20210427184301420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="426"><img alt="" height="246" src="https://img-blog.csdnimg.cn/20210427184345303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="430"><br><strong>二者清晰度差距看上去好像不是很大，但是放大图片后会发现截图结果很模糊</strong><br><img alt="" height="176" src="https://img-blog.csdnimg.cn/20210427184648498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="375"><img alt="" height="179" src="https://img-blog.csdnimg.cn/20210427184545121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="313"></p> 
<p><strong>在网上找了一些方法，但是都不尽人意，用到最多的方法是修改配置项，在html2canvas异步函数中新增dpi和scale，但是在源码里搜索dpi字段并未找到，不知道是不是官方取消了，于是我找到另一种方法对canvas进行缩放，缓解失真</strong></p> 
<p><strong>好在html2canvas提供了自定义canvas的属性，用户可以自定义canvas属性达到效果</strong><br><img alt="" height="39" src="https://img-blog.csdnimg.cn/20210427190052751.png" width="605"></p> 
<p><strong>于是我们写一个新建canvas方法，对其进行缩放</strong></p> 
<pre><code class="language-javascript">        function createCanvas(target) { 
            //target是待截取的标签，我们通过target生成对应大小的canvas
            let canvas = document.createElement("canvas");
            let context = canvas.getContext("2d")
            canvas.width = target.offsetWidth * scale; // 画布实际宽度
            canvas.height = target.offsetHeight * scale; // 画布实际高度
            canvas.style.width = target.offsetWidth + 'px' // 浏览器上显示的宽度
            canvas.style.height = target.offsetHeight + 'px' //浏览器上显示的高度
            context.scale(scale, scale); //等比缩放
            return canvas
        }</code></pre> 
<p><strong>在新建截图时调用</strong></p> 
<pre><code class="language-javascript">            const canvas = await html2canvas(pdfEle, { //截取标签转换为canvas
                canvas: createCanvas(pdfEle),
                background: '#FFFFFF',
            })</code></pre> 
<p><strong>效果是这样的，清晰度的问题已经解决，但是打印canvas时会有Y轴上的距离偏移，由于本人对canvas不是很熟练，猜测是由于按钮的高度影响的，因为修改按钮高度（不超过待截屏的元素高度），偏移量相对应也发生同样长度的偏移</strong><br><img alt="" height="278" src="https://img-blog.csdnimg.cn/20210428090339296.gif" width="411"><br><strong>此时我们使用getBoundingClientRect()的方法获取待截取标签的位置相对于浏览器可视范围的偏移量，然后通过canvas的translate方式取反位移，即可解决该问题</strong></p> 
<pre><code class="language-javascript">        function createCanvas(target) { 
            //target是待截取的标签，我们通过target生成对应大小的canvas
            let canvas = document.createElement("canvas");
            let context = canvas.getContext("2d")
            let clientRect = target.getBoundingClientRect()// 获取标签相对可视区域的偏移量
            canvas.width = target.offsetWidth * scale; // 画布实际宽度
            canvas.height = target.offsetHeight * scale; // 画布实际高度
            canvas.style.width = target.offsetWidth + 'px' // 浏览器上显示的宽度
            canvas.style.height = target.offsetHeight + 'px' //浏览器上显示的高度
            context.scale(scale, scale); //等比缩放
            context.translate(-clientRect.left, -clientRect.top);//通过translate取反位移
            return canvas
        }</code></pre> 
<p><strong>效果如下，生成的图片要比之前的清晰很多，我们还可以通过修改scale来控制图片清晰度</strong></p> 
<p><img alt="" height="375" src="https://img-blog.csdnimg.cn/202104280948238.gif" width="876"></p> 
<p><strong>实现了将HTML页面通过canvas显示后，下一步我们就需要使用jsPDF生成PDF文件并下载了</strong></p> 
<pre><code class="language-javascript">        function downloadPdf(canvas) { //将canvas变成PDF并下载
            const size = [canvas.width / scale, canvas.height / scale] //pdf真实宽高
            //第一个参数表示横向与纵向，具体可看文档，我这里做了一个适配，宽比高长则是横向反之则是纵向
            const doc = new jsPDF(size[0] / size[1] &gt; 1 ? 'l' : 'p', 'px', size)
            doc.addImage(canvas.toDataURL('image/jpeg', 1.0), 'JPEG', 0, 0, ...size) //将canvas转换为图片并添加到jsPDF中
            doc.save("test.pdf"); //保存PDF
        }</code></pre> 
<p><strong>我们试试长截屏</strong><br><img alt="" height="221" src="https://img-blog.csdnimg.cn/20210428110835544.gif" width="451"><br><strong>最后附上完整代码，界面和样式可以直接在<a href="https://gitee.com/DieHunter/myCode/tree/master/HTML_To_PDF_Demo">仓库</a>中找到</strong></p> 
<pre><code class="language-javascript">        const {
            jsPDF
        } = jspdf, scale = 2 //缩放程度，清晰度，越大越清晰，图片也越大
        let printEle, //截图按钮
            pdfEle, //待截取标签
            canvasBox //canvas显示区域


        (function init(_dom) {
            printEle = _dom.querySelector('#printEle')
            pdfEle = _dom.querySelector('#pdfEle')
            canvasBox = _dom.querySelector('#canvasBox')
            printEle.addEventListener('click', clickHandler) //点击按钮生成截屏
        })(document)

        async function clickHandler(e) {
            if (canvasBox.children.length) return //若canvas显示区域已经有标签则退出
            const canvas = await html2canvas(pdfEle, { //截取标签转换为canvas
                canvas: createCanvas(pdfEle),
                background: '#FFFFFF'
            })
            downloadPdf(canvas)
            pdfEle.hidden = true //隐藏之前的元素，更好对比
            canvasBox.appendChild(canvas) //显示效果
        }

        function downloadPdf(canvas) { //将canvas变成PDF并下载
            const size = [canvas.width / scale, canvas.height / scale] //pdf真实宽高
            //第一个参数表示横向与纵向，具体可看文档，我这里做了一个适配，宽比高长则是横向反之则是纵向
            const doc = new jsPDF(size[0] / size[1] &gt; 1 ? 'l' : 'p', 'px', size)
            doc.addImage(canvas.toDataURL('image/jpeg', 1.0), 'JPEG', 0, 0, ...size) //将canvas转换为图片并添加到jsPDF中
            doc.save("test.pdf"); //保存PDF
        }

        function createCanvas(target) { //target是待截取的标签，我们通过target生成对应大小的canvas
            let canvas = document.createElement("canvas");
            let context = canvas.getContext("2d")
            let clientRect = target.getBoundingClientRect() // 获取标签相对可视区域的偏移量
            canvas.width = target.offsetWidth * scale; // 画布实际宽度
            canvas.height = target.offsetHeight * scale; // 画布实际高度
            canvas.style.width = target.offsetWidth + 'px' // 浏览器上显示的宽度
            canvas.style.height = target.offsetHeight + 'px' //浏览器上显示的高度
            context.scale(scale, scale); //等比缩放
            context.translate(-clientRect.left, -clientRect.top); //通过translate取反位移
            return canvas
        }</code></pre> 
<p><strong>希望这篇文章对你有帮助，欢迎提出建议与优化，谢谢！</strong></p>
                ]]></description></item><item><title>浅谈Vuex的使用</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/25/14599511.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 25 Mar 2021 02:22:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/25/14599511.html</guid><description><![CDATA[
                    <p><strong>正如Redux一样，当你不知道是否需要<a href="https://vuex.vuejs.org/zh/guide/">Vuex</a>那就是不需要。不要因为想用Vuex而使用它。<br> 用过Vue的人都知道，Vuex是Vue的一个全局状态管理模块，它的作用是多个组件共享状态及数据，当某个组件将全局状态修改时，在绑定了该状态的另一个组件也将响应。实际上可以将Vue理解为一个function，在Vue的作用域中有一个数据代理，在每个Vue的实例中都能对其读和写</strong></p> 
<p><strong>我们都知道Vue的数据驱动原理是用Object.defineProperty()进行数据代理，在setter中对数据绑定的view进行异步响应（vue3.0则是使用proxy）<br> 通过查看Vuex源码可知Vuex的核心原理就是在Vue的beforeCreate钩子前混入（mixin）Vuex，并在init中将$store属性注册到Vue中</strong><br><img alt="" height="172" src="https://img-blog.csdnimg.cn/20210320140007488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="249"><img alt="" height="172" src="https://img-blog.csdnimg.cn/20210320140245733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="342"></p> 
<p><strong>为了使案例更具体，我这还是简单使用脚手架搭了个项目（可参考<a href="https://blog.csdn.net/time_____/article/details/85227914">另一篇文章</a>），虽然只有两个组件，但是能清晰的理解其用法，我的src目录如下，除了最基础的App.vue和main.js外只有两个组件和一个store</strong><br><img alt="" height="254" src="https://img-blog.csdnimg.cn/20210320213311743.png" width="113"><br><strong>先说明一下两个组件的作用，第一个组件是输入框，在里面输入字符，在二个组件div中显示，就是这么简单<br> 首先我们使用常规方式(EventBus)实现一下，这里只需要在mainjs中创建一个vue实例，然后注册在vue中就可以通过事件emit和on来进行组件通信<br> main.js</strong></p> 
<pre><code class="language-javascript">import Vue
  from 'vue'
import App
  from './App'
Vue.prototype.$eventBus = new Vue()

new Vue({
  el: '#app',
  components: {App},
  template: '&lt;App/&gt;'
})
</code></pre> 
<p><strong>inputComp.vue</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;input type="text" @input="inputHandler" /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: "inputComp",
  methods: {
    inputHandler(e) {
      this.$eventBus.$emit('changeVal',e.target.value)//输入时通过eventBus发送消息
    },
  },
};
&lt;/script&gt;

&lt;style
  scoped&gt;
&lt;/style&gt;
</code></pre> 
<p><strong>divComp.vue</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    {<!-- -->{
      val
    }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "divComp",
  data () {
    return {
      val: ''
    }
  },
  mounted () {
    this.$eventBus.$on('changeVal', (e) =&gt; {//监听输入事件通过eventBus传递信息
      this.val = e
    })
  }
}
&lt;/script&gt;

&lt;style
  scoped&gt;

&lt;/style&gt;
</code></pre> 
<p><strong>效果如下：</strong><br><img alt="" height="105" src="https://img-blog.csdnimg.cn/20210320215408166.gif" width="156"><br><strong>下面我会逐级介绍Vuex在这个案例中如何使用</strong></p> 
<p><strong>首先我们先加入state用来存放数据值（类似于组件中的data），在store中添加一个state，并在main中引入store</strong></p> 
<pre><code class="language-javascript">import Vue
  from "vue";
import Vuex
  from "vuex";

Vue.use(Vuex);
const state = {
  val: ''
}
export default new Vuex.Store({
  state
})
</code></pre> 
<p><strong>然后在上面的inputHandler中将eventBus换成以下代码</strong></p> 
<pre><code class="language-javascript">inputHandler(e) {
      this.$store.state.val = e.target.value;
    }</code></pre> 
<p><strong>将div标签中的val换成this.$store.state.val，这就是最简单的Vuex使用，仅仅通过修改state从而达到全局状态的目的，如果你的项目并不复杂，这个简单的全局状态就足够了</strong></p> 
<p><strong>下一步，我们加入一个mutations，这里我们可以将mutations当成<a href="https://blog.csdn.net/time_____/article/details/113770950">发布/订阅</a>的调度中心，将函数写在mutations中相当于注册了一个事件，在页面中通过emit来触发<br> 在store中新增</strong><strong>mutations</strong></p> 
<pre><code class="language-javascript">const state = {
  val: ''
}

const mutations = {
  changeVal (state, _val) {
    state.val = _val
  }
}

export default new Vuex.Store({
  state,
  mutations
})</code></pre> 
<p><strong>在inputHandler中调用一下该函数，其中changeVal是mutations中的函数名，通过emit传参达到和发布\订阅效果</strong></p> 
<pre><code class="language-javascript">this.$store.commit('changeVal',e.target.value)</code></pre> 
<p><strong>了解了mutations，我们来看看getters，我们都知道Vue中有一个computed计算属性，当被代理的值发生变化时，它会被重新计算，Vuex中的派生属性getters会绑定state中的某个或某些值，通过传递参数，达到对该值过滤，修改的作用</strong></p> 
<p><strong>这里我们做个简单的计算，输入字符后计算其长度并拼接一下，inputHandler中操作不变，在store中新增getters</strong></p> 
<pre><code class="language-javascript">import Vue
  from "vue";
import Vuex
  from "vuex";

Vue.use(Vuex);
const state = {
  val: ''
}

const mutations = {
  changeVal (state, _val) {
    state.val = _val
  }
}

const getters = {
  getValueLength (state) {
    return `长度：${state.val.length}`
  }
}
export default new Vuex.Store({
  state,
  mutations,
  getters
})</code></pre> 
<p><strong>然后在div标签中的this.$store.state.val后面添加this.$store.getters.getValueLength</strong></p> 
<pre><code class="language-javascript"> &lt;div&gt;
    {<!-- -->{
      this.$store.state.val+this.$store.getters.getValueLength
    }}
  &lt;/div&gt;</code></pre> 
<p><strong>效果如下：</strong><br><img alt="" height="156" src="https://img-blog.csdnimg.cn/20210321155310181.gif" width="232"><br><strong>如果到这一步，你仍然感觉难度不大，那么恭喜你，Vuex的使用已经掌握了一大半了</strong></p> 
<p><strong>下面，我们来说说actions，在说actions之前，我们先回顾一下mutations，mutations中注册了一些事件，在组件中通过emit对事件进行触发，达到处理异步且解耦的效果，然而官方并不推荐我们直接对store进行操作<br> 官方对actions的说明是：</strong><span style="color:#f33b45;"><strong>Action 类似于 mutation，不同在于1.Action 提交的是 mutation，而不是直接变更状态。2.Action 可以包含任意异步操作。</strong></span></p> 
<p><strong>也就是说，我们要把组件中的emit操作放到actions中，而在组件中通过某些方式来触发actions中的函数间接调用emit，</strong><strong>此时，为了让action更直观，我们添加一个清除输入框字符的方法，当点击清除按钮时清除state.val</strong><br><strong>在输入框组件中将value绑定到state上</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;input type="text" @input="inputHandler" :value="this.$store.state.val" /&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "inputComp",
  methods: {
    inputHandler(e) {
      this.$store.dispatch("actionVal", e.target.value);
    },
  },
};
&lt;/script&gt;

&lt;style
  scoped&gt;
&lt;/style&gt;
</code></pre> 
<p><strong>在另一个显示数据的组件中新增删除按钮并绑定删除事件，通过dispatch告知store并通过emit操作state</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="clickHandler"&gt;清除&lt;/button&gt;
    &lt;span&gt;{<!-- -->{ this.$store.state.val + this.$store.getters.getValueLength }}&lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "divComp",
  methods: {
    clickHandler(){
      this.$store.dispatch('actionClearVal')
    }
  },
};
&lt;/script&gt;

&lt;style
  scoped&gt;
&lt;/style&gt;
</code></pre> 
<p><strong>最后在store中新建删除的actions和mutations</strong></p> 
<pre><code class="language-javascript">import Vue
from "vue";
import Vuex
from "vuex";

Vue.use(Vuex);
const state = {
  val: ''
}

const mutations = {
  changeVal(state, _val) {
    state.val = _val
  },
  clearVal(state, _val) {
    state.val = ''
  }
}
const actions = {
  actionVal(state, _val) {
    state.commit('changeVal', _val)
  },
  actionClearVal(state) {
    state.commit('clearVal')
  }
}
const getters = {
  getValueLength(state) {
    return `长度：${state.val.length}`
  }
}
export default new Vuex.Store({
  state,
  mutations,
  actions,
  getters
})
</code></pre> 
<p><strong>最终效果如下：</strong></p> 
<p><img alt="" height="156" src="https://img-blog.csdnimg.cn/20210324221759581.gif" width="232"><br><strong>到这里为止，Vuex的基本用法就介绍完毕了。<br> 然而除此之外，Vuex官方还提供了辅助函数（mapState,mapMutations,mapGetters,mapActions）和Modules（store的子模块，当有许多全局状态时，我们为了避免代码臃肿，就可以将各个store分割成模块）方便我们书写<br> 下面我们用辅助函数重新实现一下上述功能<br> 输入框：</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;input type="text" @input="inputHandler" :value="value" /&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState, mapMutations } from "vuex";
export default {
  name: "inputComp",
  computed: {
    ...mapState({ value: "val" }),
  },
  methods: {
    ...mapMutations({ sendParams: "changeVal" }), // sendParams用来传递参数,先把sendParams注册到mutations上，输入时触发sendParams
    inputHandler(e) {
      this.sendParams(e.target.value);
    },
  },
};
&lt;/script&gt;

&lt;style
  scoped&gt;
&lt;/style&gt;
</code></pre> 
<p><strong>显示框：</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="clickHandler"&gt;清除&lt;/button&gt;
    &lt;span&gt;{<!-- -->{ value + valueLength }}&lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState, mapGetters, mapActions } from "vuex";
export default {
  name: "divComp",
  computed: {
    ...mapState({ value: "val" }),
    ...mapGetters({ valueLength: "getValueLength" }),
  },
  methods: {
    ...mapActions({ clickHandler: "actionClearVal" }),
  },
};
&lt;/script&gt;

&lt;style
  scoped&gt;
&lt;/style&gt;
</code></pre> 
<p><strong>这里需要注意的一点就是mapActions和mapMutations的传参问题，这里我使用另一个函数接收参数并且注册到store中</strong></p> 
<p><strong>关于Modules的这里就不多做介绍，官方已给出了详细说明</strong></p> 
<p><strong>最后，附上<a href="https://gitee.com/DieHunter/myCode/tree/master/Vuex%E4%BD%BF%E7%94%A8">案例地址</a>，有需要可以自取，感谢你看到了最后，如果这篇文章有帮助到你，请帮忙支持一下，非常感谢！</strong><br> &nbsp;</p>
                ]]></description></item><item><title>没有云服务器？内网穿透了解一下</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/20/14599512.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sat, 20 Mar 2021 03:21:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/20/14599512.html</guid><description><![CDATA[
                    <p><strong>内网穿透又叫端口映射，用一句最简单的话来讲就是：将你的计算机所连接的私有网络映射到公网上，别人通过你给的域名或ip即可访问你本地的服务。具体的原理可参照<a href="https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/8597835">百度百科</a><br> 这么做可以实现各大厂商的云服务器（阿里云，腾讯云，百度云，华为云等）的效果，通过公网地址访问服务器</strong></p> 
<p><strong>这里分享一些提供内网穿透的网站，前三种是我用过的，感觉都还不错（仅供参考）：</strong></p> 
<ol><li><strong><a href="https://www.ngrok.cc/">Sunny-Ngrok</a>：免费版，带宽：10 Mbps，限速：128&nbsp;Kbps，限流：无限，隧道数量：每种协议1条</strong></li><li><strong><a href="https://www.natfrp.com/">SAKURA FRP</a>：免费版（需要支付一元实名认证），带宽：10 Mbps，限速：4 Mbps，限流：5 GiB+限速流量（进入该状态24小时后会进行流量重置并恢复限速至正常限速），隧道数量：5条</strong></li><li><strong><a href="https://www.nsloop.com/nattunnel">NATTUNNEL</a>：免费版（隧道每天停止），带宽：1&nbsp;Mbps，限速：不限，限流：无限，隧道数量：1条</strong></li><li><strong><a href="https://frp.cool/">浮居内网穿透</a>：免费版，带宽：5&nbsp;Mbps，限速：5&nbsp;Mbps，限流：5GiB，隧道数量：2条</strong></li><li><strong><a href="https://natapp.cn/">NATAPP</a>：免费版，带宽：1&nbsp;Mbps，限速：1&nbsp;Mbps，限流：不限，隧道数量：0条</strong></li><li><strong><a href="https://hsk.oray.com/">花生壳</a>：免费版，带宽：1&nbsp;Mbps，限速：1&nbsp;Mbps，限流：1GiB，隧道数量：2条</strong></li><li><strong><a href="http://www.neiwangchuantou.net/">网穿云</a>：免费版，带宽：3&nbsp;Mbps，限速：3&nbsp;Mbps，限流：7天不限流量,激活后流量限制每月/1G，隧道数量：1条</strong></li><li><strong><a href="https://www.cpolar.com/">cpolar</a>：免费版，带宽：不清楚，限速：不清楚，限流：不清楚，隧道数量：1条</strong></li><li><strong><a href="http://www.luyouxia.com/">路由侠</a>：免费版，带宽：1&nbsp;Mbps，限速：1&nbsp;Mbps，限流：1GiB，隧道数量：2条</strong></li><li><strong><a href="http://www.mofasuidao.cn/">魔法隧道</a>：积分兑换版，带宽：官网说100M，限速：不清楚，限流：不清楚，隧道数量：不清楚</strong></li></ol>
<p><strong>下面，我就<a href="https://www.ngrok.cc/">Sunny-Ngrok</a>来分享一下服务器搭建，其实都大同小异，照着官方文档来，慢慢的就会了</strong></p> 
<p><strong>这里我简单描述一下内网穿透的两个应用，一是服务器搭建，二是远程桌面的搭建</strong></p> 
<p><strong><span style="color:#f33b45;">首先是服务器搭建</span>，在此之前，我们得先开启本地服务器，这里以node为例，<a href="https://blog.csdn.net/time_____/article/details/114024145">环境搭建</a>，<a href="https://blog.csdn.net/time_____/article/details/114281583">静态文件服务</a>，<a href="https://blog.csdn.net/time_____/article/details/104439713">本地文件上线</a>，以及用到的<a href="https://blog.csdn.net/time_____/article/details/114326156">懒加载案例</a>在之前文章有说到，这里直接进入正题</strong></p> 
<p><strong>开启本地服务运行懒加载案例，通过127.0.0.1访问网页，我这里是运行在VSCode插件（live server）下，当然也可以参照<a href="https://blog.csdn.net/time_____/article/details/114281583">静态文件服务</a>把项目运行在node服务下，首先保证网页和接口可以在本地运行访问<br> 我的前端部分端口号是5500，后端接口端口号是1024</strong><br><img alt="" height="201" src="https://img-blog.csdnimg.cn/20210314140340632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="368"><img alt="" height="200" src="https://img-blog.csdnimg.cn/2021031414041957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="367"></p> 
<p><strong>但是<a href="https://www.ngrok.cc/">Sunny-Ngrok</a>免费版的对http协议只提供一个端口的隧道，此时我们就要用Nginx进行端口代理了，Nginx配置可以参考<a href="https://blog.csdn.net/time_____/article/details/114750930">Nginx文章</a>，我这里的配置如下</strong></p> 
<pre><code class="language-bash">    server {
        listen       10240;#监听端口
        server_name  localhost;
        location / {
            proxy_pass http://127.0.0.1:1024/;#反向代理后端接口
        }
        location /client {
            proxy_pass http://127.0.0.1:5500/;#反向代理前端页面
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
 
    }</code></pre> 
<p><strong>此时通过输入<a href="http://127.0.0.1:10240/client/lazyLoad.html">http://127.0.0.1:10240/client/</a>就会代理到<a href="http://127.0.0.1:5500/">http://127.0.0.1:5500/</a>下，输入<a href="http://127.0.0.1:10240/getList?len=1000">http://127.0.0.1:10240</a>/会被代理到<a href="http://127.0.0.1:10240/getList?len=1000">http://127.0.0.1:1024/</a>下</strong></p> 
<p><strong>下一步，注册<a href="https://www.ngrok.cc/">Sunny-Ngrok</a>账号，登录并购买免费服务器，配置服务器设置，最后下载穿透软件</strong><br><img alt="" height="173" src="https://img-blog.csdnimg.cn/20210312225657902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="355"><img alt="" height="170" src="https://img-blog.csdnimg.cn/20210312225843323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="349"><img alt="" height="165" src="https://img-blog.csdnimg.cn/20210314143154253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="339"><img alt="" height="163" src="https://img-blog.csdnimg.cn/20210314143431919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="335"></p> 
<p><strong>下载完成后点击启动工具，在隧道管理中复制刚才新建的隧道id，粘贴到隧道软件中，并回车，进入到连接界面</strong><br><img alt="" height="178" src="https://img-blog.csdnimg.cn/20210314144024175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="813"><br><img alt="" height="239" src="https://img-blog.csdnimg.cn/20210314143842729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="306"><img alt="" height="235" src="https://img-blog.csdnimg.cn/20210314144217617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="401"><img alt="" height="237" src="https://img-blog.csdnimg.cn/20210314144414400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="400"></p> 
<p><strong>此时刷新隧道管理界面，点击查看状态，可以看到，当前连接的ip，说明内网穿透成功</strong></p> 
<p><img alt="" height="132" src="https://img-blog.csdnimg.cn/20210314144528694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="844"><br><strong>下一步，我们在新页面中打开赠送域名加路径，如：<a href="http://example.com/client/lazyLoad.html">http://example.com/client/lazyLoad.html</a>(example.com是赠送域名)，打开后会提示输入账号密码。<br> 输入http验证用户名和密码即可</strong><br><img alt="" height="251" src="https://img-blog.csdnimg.cn/20210314145038500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="456"><img alt="" height="245" src="https://img-blog.csdnimg.cn/20210314150441896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="484"></p> 
<p><strong>但是此时懒加载请求的接口是本地的127.0.0.1，我们要修改为<a href="http://example.com/getList?len=1000">http://example.com/getList?len=1000</a>，最后打开<a href="http://example.com/client/lazyLoad.html">http://example.com/client/lazyLoad.html</a>，显示以下效果</strong><br><img alt="" height="188" src="https://img-blog.csdnimg.cn/2021031415095894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="294"><img alt="" height="189" src="https://img-blog.csdnimg.cn/20210314151909628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="514"><br><strong>做到这里，服务器内网穿透的服务器搭建就完成了。</strong></p> 
<p><span style="color:#f33b45;"><strong>接下来，我们来尝试搭建一下远程桌面</strong></span></p> 
<p><strong>和之前一样，购买新的免费服务器，并且配置tcp协议，这里有两点需要注意：</strong></p> 
<ol><li><strong>本地映射的ip不能使用127.0.0.1，而是使用局域网内的ip，通过ipconfig查看本机在局域网的ip并复制</strong></li><li><strong>远程桌面默认端口是3389</strong></li></ol>
<p><img alt="" height="199" src="https://img-blog.csdnimg.cn/20210314154208975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="246"></p> 
<p><strong>下面是我远程桌面的配置</strong><br><img alt="" height="127" src="https://img-blog.csdnimg.cn/20210314154305325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="461"><br><strong>隧道管理</strong><br><img alt="" height="41" src="https://img-blog.csdnimg.cn/20210314154549688.png" width="466"><br><strong>最后和上面一样，运行内网穿透软件即可（可能会一直出现<span style="color:#f33b45;">reconnecting</span>提示，原因在<a href="https://www.ngrok.cc/_book/error/ngrok.html">官网文档</a>中，我这的解决方法是在隧道管理中踢下线，然后多连几次）</strong><br><img alt="" height="146" src="https://img-blog.csdnimg.cn/20210314160549637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="247"><img alt="" height="148" src="https://img-blog.csdnimg.cn/20210314161635100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="249"></p> 
<p><strong>我们可以使用另一台电脑或者手机版的远程桌面连接当前电脑（手机版可以去酷安），下面是用手机连接的效果</strong><br><img alt="" height="111" src="https://img-blog.csdnimg.cn/20210314162219619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="239"><img alt="" height="110" src="https://img-blog.csdnimg.cn/20210314162253401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="238"><img alt="" height="109" src="https://img-blog.csdnimg.cn/20210314162343578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="235"></p> 
<p><strong>总结：内网穿透虽然比服务器要便宜，但是还要考虑自己电脑的电费和损耗，而且做服务器需要一直开着，所以，还是要对比，比较一下，选择适合自己的方案</strong></p> 
<p><strong>希望这篇文章能帮助你</strong></p>
                ]]></description></item><item><title>Nginx常用指令，基本配置，反向代理</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/16/14599513.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Tue, 16 Mar 2021 04:19:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/16/14599513.html</guid><description><![CDATA[
                    <p><strong>前言：近期公司整改项目，前端的项目和接口全部采用Nginx重新部署，这里就最近用到的Nginx服务器做一个知识点整理，推荐一个<a href="https://www.nginx.cn/doc/">Nginx中文文档</a>网站</strong></p> 
<p><strong>Nginx服务器就不多做介绍，直接进入正题，系统用的是window7 旗舰</strong></p> 
<p><strong>首先，下载<a href="http://nginx.org/en/download.html">Nginx</a>，这里我下载了1.18版本，解压后得到以下Nginx根目录，推荐把根目录放到环境变量中</strong><br><img alt="" height="135" src="https://img-blog.csdnimg.cn/20210313161631371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="296"><img alt="" height="135" src="https://img-blog.csdnimg.cn/20210313161905672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="186"><br><strong>然后，在根目录导航栏输入cmd并回车进入命令控制</strong><br><img alt="" height="159" src="https://img-blog.csdnimg.cn/20210313162218840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="210"><br><strong>常用命令：<br> nginx &nbsp;-t：检验配置文件<br> nginx &nbsp;-v：显示版本<br> start &nbsp;nginx：开启服务器<br> nginx &nbsp; -s &nbsp; stop：快速关闭服务器<br> nginx &nbsp; -s &nbsp; quit：正常关闭服务器<br> nginx &nbsp; -s &nbsp;reload：重载配置文件</strong></p> 
<p><strong>之后，我们输入nginx start，系统会闪过一个命令控制台然后自动关闭，此时打开任务管理器，在进程中找得到nginx.exe，说明开启成功，在浏览器中打开127.0.0.1或localhost就会显示nginx欢迎页说明运行成功</strong><br><img alt="" height="261" src="https://img-blog.csdnimg.cn/20210313164140215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="251"><img alt="" height="257" src="https://img-blog.csdnimg.cn/20210313164415616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="563"><br><strong>下面介绍一下基本配置<br> 打开根目录下的conf文件夹，用编辑器打开nginx.conf</strong><br><img alt="" height="228" src="https://img-blog.csdnimg.cn/20210313165533913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="314"><img alt="" height="226" src="https://img-blog.csdnimg.cn/20210313165550480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="310"></p> 
<p><strong>代理服务：</strong></p> 
<p><strong>以下代码可以修改代理网站的路径，访问默认的80端口会定向到html文件夹下的index.html文件，也就是nginx欢迎页，达到代理效果</strong></p> 
<pre><code>    server {
        listen       80;#监听端口
        server_name  localhost;#监听域名访问

        location / {
            root   html;#代理文件夹
            index  index.html index.htm;#代理文件
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }</code></pre> 
<p><strong>反向代理：</strong></p> 
<p><strong>使用上面的代码稍作修改，实现反向代理功能，输入<a href="http://127.0.0.1:1024/baidu">http://127.0.0.1:1024/baidu</a>即可访问百度</strong><br> &nbsp;</p> 
<pre><code>server {
        
        listen       1024;#监听端口
        server_name   localhost;
        location /baidu {
            proxy_pass https://www.baidu.com/;#反向代理baidu网址
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }</code></pre> 
<p><img alt="" height="220" src="https://img-blog.csdnimg.cn/2021031317553334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="411"></p> 
<p><strong>https服务搭建可参考之前的<a href="https://blog.csdn.net/time_____/article/details/108050452">搭建一个线上版远程视频聊天</a>中的https搭建</strong></p> 
<p><strong>以上就是我对nginx基础知识的整理，希望会对你有帮助</strong></p>
                ]]></description></item><item><title>WebSocket使用及优化（心跳机制与断线重连）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/13/14599514.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sat, 13 Mar 2021 12:40:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/13/14599514.html</guid><description><![CDATA[
                    <p><strong>WebSocket在2008年被提出，其通信协议于2011被制定为标准<br> 与http不同，websocket支持全双工通信（即：在客户端和服务之间双向通信）在websocket问世之前，客户端与服务器通常采用http轮询和Comet等方式保持长链接<br> 然而，这么做无疑会对服务端造成资源消耗，因为HTTP请求包含较长的头文件，只传递了少许的有用信息，十分消耗资源。<br> 于是websocket便诞生了，它不仅节省资源和带宽，更是能实现长链接作用，只需客户端主动与服务端握手一次，即可进行实时通信，实现推送技术。</strong></p> 
<p><strong>之前我也写过相关的文章：<a href="https://blog.csdn.net/time_____/article/details/86748679">Socket聊天室</a>，<a href="https://blog.csdn.net/time_____/article/details/104801205">使用JS+socket.io+WebRTC+nodejs+express搭建一个简易版远程视频聊天</a>，但是用到的模块都是socket.io，而且没有深入优化，在平时工作上真正用到时发现事情并不简单。有时前端或者后端会断线而对方不知道，像弱网或者后端服务器重启时，前端并不能保证一直连接</strong><br><strong>所以这篇文章，我们就来使用websocket做一个简单的demo，并且加上心跳和断线重连功能</strong></p> 
<p><strong>首先是服务端，采用node+<a href="https://github.com/websockets/ws">ws模块</a>搭建websocket服务，在server文件夹下新建server.js，并在npm初始化后，下载ws模块</strong></p> 
<pre><code>npm init -y
npm i ws
</code></pre> 
<p><strong>引入ws模块，并搭建一个简单的websocket服务</strong></p> 
<pre><code class="language-javascript">const WebSocket = require('ws');
const port = 1024//端口
const pathname = '/ws/'//访问路径

new WebSocket.Server({port}, function () {
    console.log('websocket服务开启')
}).on('connection', connectHandler)

function connectHandler (ws) {
    console.log('客户端连接')
    ws.on('error', errorHandler)
    ws.on('close', closeHandler)
    ws.on('message', messageHandler)
}

function messageHandler (e) {
    console.info('接收客户端消息')
    this.send(e)
}

function errorHandler (e) {
    console.info('客户端出错')
}

function closeHandler (e) {
    console.info('客户端已断开')
}</code></pre> 
<p><strong>前端部分也搭建个ws访问客户端</strong></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="module"&gt;
    const name = 'test'//连接用户名
    let wsUrl = 'ws://127.0.0.1:1024/ws/?name=' + name
    const ws = new WebSocket(wsUrl)
    ws.onopen = function (e) {
        console.log('开启')
        ws.send(JSON.stringify({
            ModeCode: "message",
            msg: 'hello'
        }))
    }//连接上时回调
    ws.onclose = function (e) {
        console.log('关闭')
    }//断开连接时回调
    ws.onmessage = function (e) {
        let data = JSON.parse(e.data)
        console.log('收到消息' + data.msg)
        ws.close()
    }//收到服务端消息
    ws.onerror = function (e) {
        console.log('出错')
    }//连接出错
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>前端打印结果：</strong><br><img alt="" height="75" src="https://img-blog.csdnimg.cn/20210309165409626.png" width="376"><br><strong>服务端打印结果：</strong><br><img alt="" height="74" src="https://img-blog.csdnimg.cn/20210309165448717.png" width="144"><br><strong>有以上效果说明一个最简单的ws连接就实现了，下面，我们优化一下，为了降低耦合，我们先引入<a href="https://blog.csdn.net/time_____/article/details/113770950">eventBus</a>发布订阅，然后新建一个websocket类继承自原生WebSocket，因为，我们要在里面做心跳和重连<br> 在服务端，我们先把server完善一下，通过http的upgrade过滤验证ws连接<br> 在原有的服务端增加http服务并做好路径验证</strong></p> 
<pre><code class="language-javascript">const http = require('http');
const server = http.createServer()

server.on("upgrade", (req, socket, head) =&gt; {//通过http.server过滤数据
    let url = new URL(req.url, `http://${req.headers.host}`)
    let name = url.searchParams.get('name')//获取连接标识
    if(!checkUrl(url.pathname, pathname)) {//未按标准
        socket.write('未按照标准访问');
        socket.destroy();
        return;
    }
})
server.listen(port, () =&gt; {
    console.log('服务开启')
})

//验证url标准
function checkUrl (url, key) {//判断url是否包含key
    return - ~ url.indexOf(key)
}</code></pre> 
<p><strong>完成httpServer后，我们再完善一下websocket服务，将每一个连接的用户都通过代理保存并实现增删，得到以下完整的服务端</strong></p> 
<pre><code class="language-javascript">const http = require('http');
const WebSocket = require('ws');
const port = 1024//端口
const pathname = '/ws/'//访问路径
const server = http.createServer()

class WebSocketServer extends WebSocket.Server {
    constructor () {
        super(...arguments);
        this.webSocketClient = {}//存放已连接的客户端
    }

    set ws (val) {//代理当前的ws，赋值时将其初始化
        this._ws = val
        val.t = this;
        val.on('error', this.errorHandler)
        val.on('close', this.closeHandler)
        val.on('message', this.messageHandler)
    }

    get ws () {
        return this._ws
    }

    messageHandler (e) {
        console.info('接收客户端消息')
        let data = JSON.parse(e)
        switch(data.ModeCode) {
            case 'message':
                console.log('收到消息' + data.msg)
                this.send(e)
                break;
            case 'heart_beat':
                console.log(`收到${this.name}心跳${data.msg}`)
                this.send(e)
                break;
        }
    }

    errorHandler (e) {
        this.t.removeClient(this)
        console.info('客户端出错')
    }

    closeHandler (e) {
        this.t.removeClient(this)
        console.info('客户端已断开')
    }

    addClient (item) {//设备上线时添加到客户端列表
        if(this.webSocketClient[item['name']]) {
            console.log(item['name'] + '客户端已存在')
            this.webSocketClient[item['name']].close()
        }
        console.log(item['name'] + '客户端已添加')
        this.webSocketClient[item['name']] = item
    }

    removeClient (item) {//设备断线时从客户端列表删除
        if(!this.webSocketClient[item['name']]) {
            console.log(item['name'] + '客户端不存在')
            return;
        }
        console.log(item['name'] + '客户端已移除')
        this.webSocketClient[item['name']] = null
    }
}

const webSocketServer = new WebSocketServer({noServer: true})
server.on("upgrade", (req, socket, head) =&gt; {//通过http.server过滤数据
    let url = new URL(req.url, `http://${req.headers.host}`)
    let name = url.searchParams.get('name')//获取连接标识
    if(!checkUrl(url.pathname, pathname)) {//未按标准
        socket.write('未按照标准访问');
        socket.destroy();
        return;
    }
    webSocketServer.handleUpgrade(req, socket, head, function (ws) {
        ws.name = name//添加索引，方便在客户端列表查询某个socket连接
        webSocketServer.addClient(ws);
        webSocketServer.ws = ws
    });
})
server.listen(port, () =&gt; {
    console.log('服务开启')
})

//验证url标准
function checkUrl (url, key) {//判断url是否包含key
    return - ~ url.indexOf(key)
}</code></pre> 
<p><strong>当连接断开时，只有客户端主动访问服务端才能实现重连，所以客户端的功能要比服务端更多一些，我们把客户端的websocket完善优化一下，添加一些简单的控制功能（连接，发消息，断开）的按钮，这里有一点需要注意：在下次连接之前一定要先关闭当前连接，否则会导致多个客户端同时连接，消耗性能</strong></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button id="connect"&gt;
    连接
&lt;/button&gt;
&lt;button disabled
        id="sendMessage"&gt;
    发送
&lt;/button&gt;
&lt;button disabled
        id="destroy"&gt;
    关闭
&lt;/button&gt;
&lt;script type="module"&gt;
    const name = 'test'//连接用户名
    let connect = document.querySelector('#connect'),//连接按钮
        sendMessage = document.querySelector('#sendMessage'),//发送按钮
        destroy = document.querySelector('#destroy'),//关闭按钮
        wsUrl = 'ws://127.0.0.1:1024/ws/?name=' + name,//连接地址
        ws;

    connect.addEventListener('click', connectWebSocket)
    sendMessage.addEventListener('click', function (e) {
        ws.send(JSON.stringify({
            ModeCode: "message",
            msg: 'hello'
        }))
    })
    destroy.addEventListener('click', function (e) {
        ws.close()
        ws = null
    })

    function connectWebSocket () {
        if(!ws) {//第一次执行，初始化或ws断开时可执行
            ws = new WebSocket(wsUrl)
            initWebSocket()
        }
    }

    function initWebSocket () {
        ws.onopen = function (e) {
            setButtonState('open')
            console.log('开启')
        }//连接上时回调
        ws.onclose = function (e) {
            setButtonState('close')
            console.log('关闭')
        }//断开连接时回调
        ws.onmessage = function (e) {
            let data = JSON.parse(e.data)
            console.log('收到消息' + data.msg)
        }//收到服务端消息
        ws.onerror = function (e) {
            setButtonState('close')
            console.log('出错')
        }//连接出错
    }

    /*
  * 设置按钮是否可点击
  * @param state：open表示开启状态，close表示关闭状态
  */
    function setButtonState (state) {
        switch(state) {
            case 'open':
                connect.disabled = true
                sendMessage.disabled = false
                destroy.disabled = false
                break;
            case 'close':
                connect.disabled = false
                sendMessage.disabled = true
                destroy.disabled = true
                break;
        }
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>效果如下：</strong><br><img alt="" height="430" src="https://img-blog.csdnimg.cn/2021030920045814.gif" width="668"></p> 
<p><strong>到了这一步，我们websocket的demo已经可以手动运行，在此基础上，我们将其封装一下，并且通过eventBus对外进行通信就可以用了，具体流程将与接下来的心跳一起实现<br> websocket心跳机制：顾名思义，就是客户端每隔一段时间向服务端发送一个特有的心跳消息，每次服务端收到消息后只需将消息返回，此时，若二者还保持连接，则客户端就会收到消息，若没收到，则说明连接断开，此时，客户端就要主动重连，完成一个周期<br> 心跳的实现也很简单，只需在第一次连接时用回调函数做延时处理，此时还需要设置一个心跳超时时间，若某时间段内客户端发送了消息，而服务端未返回，则认定为断线。下面，我就来实现一下心跳</strong></p> 
<pre><code class="language-javascript">    //this.heartBeat  ---&gt;  time：心跳时间间隔 timeout：心跳超时间隔
    /*
     * 心跳初始函数
     * @param time：心跳时间间隔
     */
    function startHeartBeat (time) {
        setTimeout(() =&gt; {
            this.sendMsg({
                ModeCode: ModeCode.HEART_BEAT,
                msg: new Date()
            })
            this.waitingServer()
        }, time)
    }
    //延时等待服务端响应，通过webSocketState判断是否连线成功
    function waitingServer () {
        this.webSocketState = false//在线状态
        setTimeout(() =&gt; {
            if(this.webSocketState) {
                this.startHeartBeat(this.heartBeat.time)
                return
            }
            console.log('心跳无响应，已断线')
            this.close()
            //重连操作
        }, this.heartBeat.timeout)
    }</code></pre> 
<p><strong>心跳实现完成后，只需要在ws.onopen中调用即可，效果如下：</strong><br><img alt="" height="319" src="https://img-blog.csdnimg.cn/20210309202721940.gif" width="482"><br><br><strong>然后是重连部分，其实只需要新建一个延时回调，与心跳相似，只不过它是在连接失败时使用的，这里就不多做说明。以下是完整版的代码：<br> websocket部分：</strong></p> 
<pre><code class="language-javascript">import eventBus
    from "./eventBus.js"

const ModeCode = {//websocket消息类型
    MSG: 'message',//普通消息
    HEART_BEAT: 'heart_beat'//心跳
}

export default class MyWebSocket extends WebSocket {
    constructor (url, protocols) {
        super(url, protocols);
        return this
    }

    /*
     * 入口函数
     * @param heartBeatConfig  time：心跳时间间隔 timeout：心跳超时间隔 reconnect：断线重连时间间隔
     * @param isReconnect 是否断线重连
     */
    init (heartBeatConfig, isReconnect) {
        this.onopen = this.openHandler//连接上时回调
        this.onclose = this.closeHandler//断开连接时回调
        this.onmessage = this.messageHandler//收到服务端消息
        this.onerror = this.errorHandler//连接出错
        this.heartBeat = heartBeatConfig
        this.isReconnect = isReconnect
        this.reconnectTimer = null//断线重连时间器
        this.webSocketState = false//socket状态 true为已连接
    }

    openHandler () {
        eventBus.emitEvent('changeBtnState', 'open')//触发事件改变按钮样式
        this.webSocketState = true//socket状态设置为连接，做为后面的断线重连的拦截器
        this.heartBeat &amp;&amp; this.heartBeat.time ? this.startHeartBeat(this.heartBeat.time) : ""//是否启动心跳机制
        console.log('开启')
    }

    messageHandler (e) {
        let data = this.getMsg(e)
        switch(data.ModeCode) {
            case ModeCode.MSG://普通消息
                console.log('收到消息' + data.msg)
                break;
            case ModeCode.HEART_BEAT://心跳
                this.webSocketState = true
                console.log('收到心跳响应' + data.msg)
                break;
        }
    }

    closeHandler () {//socket关闭
        eventBus.emitEvent('changeBtnState', 'close')//触发事件改变按钮样式
        this.webSocketState = false//socket状态设置为断线
        console.log('关闭')
    }

    errorHandler () {//socket出错
        eventBus.emitEvent('changeBtnState', 'close')//触发事件改变按钮样式
        this.webSocketState = false//socket状态设置为断线
        this.reconnectWebSocket()//重连
        console.log('出错')
    }

    sendMsg (obj) {
        this.send(JSON.stringify(obj))
    }

    getMsg (e) {
        return JSON.parse(e.data)
    }

    /*
     * 心跳初始函数
     * @param time：心跳时间间隔
     */
    startHeartBeat (time) {
        setTimeout(() =&gt; {
            this.sendMsg({
                ModeCode: ModeCode.HEART_BEAT,
                msg: new Date()
            })
            this.waitingServer()
        }, time)
    }

    //延时等待服务端响应，通过webSocketState判断是否连线成功
    waitingServer () {
        this.webSocketState = false
        setTimeout(() =&gt; {
            if(this.webSocketState) {
                this.startHeartBeat(this.heartBeat.time)
                return
            }
            console.log('心跳无响应，已断线')
            try {
                this.close()
            } catch(e) {
                console.log('连接已关闭，无需关闭')
            }
            this.reconnectWebSocket()
        }, this.heartBeat.timeout)
    }

    //重连操作
    reconnectWebSocket () {
        if(!this.isReconnect) {
            return;
        }
        this.reconnectTimer = setTimeout(() =&gt; {
            eventBus.emitEvent('reconnect')
        }, this.heartBeat.reconnect)
    }
}</code></pre> 
<p><strong>index.html部分：</strong></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button id="connect"&gt;
    连接
&lt;/button&gt;
&lt;button disabled
        id="sendMessage"&gt;
    发送
&lt;/button&gt;
&lt;button disabled
        id="destroy"&gt;
    关闭
&lt;/button&gt;
&lt;script type="module"&gt;
    import eventBus
        from "./js/eventBus.js"
    import MyWebSocket
        from './js/webSocket.js'

    const name = 'test'//连接用户名
    let connect = document.querySelector('#connect')
    let sendMessage = document.querySelector('#sendMessage')
    let destroy = document.querySelector('#destroy')
    let myWebSocket,
        wsUrl = 'ws://127.0.0.1:1024/ws/?name=' + name

    eventBus.onEvent('changeBtnState', setButtonState)//设置按钮样式
    eventBus.onEvent('reconnect', reconnectWebSocket)//接收重连消息
    connect.addEventListener('click', reconnectWebSocket)
    sendMessage.addEventListener('click', function (e) {
        myWebSocket.sendMsg({
            ModeCode: "message",
            msg: 'hello'
        })
    })
    destroy.addEventListener('click', function (e) {
        myWebSocket.close()
    })

    function reconnectWebSocket () {
        if(!myWebSocket) {//第一次执行，初始化
            connectWebSocket()
        }
        if(myWebSocket &amp;&amp; myWebSocket.reconnectTimer) {//防止多个websocket同时执行
            clearTimeout(myWebSocket.reconnectTimer)
            myWebSocket.reconnectTimer = null
            connectWebSocket()
        }
    }

    function connectWebSocket () {
        myWebSocket = new MyWebSocket(wsUrl);
        myWebSocket.init({//time：心跳时间间隔 timeout：心跳超时间隔 reconnect：断线重连时
            time: 30 * 1000,
            timeout: 3 * 1000,
            reconnect: 10 * 1000
        }, true)
    }

    /*
     * 设置按钮是否可点击
     * @param state：open表示开启状态，close表示关闭状态
     */
    function setButtonState (state) {
        switch(state) {
            case 'open':
                connect.disabled = true
                sendMessage.disabled = false
                destroy.disabled = false
                break;
            case 'close':
                connect.disabled = false
                sendMessage.disabled = true
                destroy.disabled = true
                break;
        }
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>最终实现的效果如下，即使后端服务关闭，或者是断网状态，客户端都能保持重连状态</strong><br><img alt="" height="462" src="https://img-blog.csdnimg.cn/20210309210551664.gif" width="698"><br><strong>最后，感谢你看到了这里，文章有任何问题欢迎大佬指出与讨论<br> 附上源码：<a href="https://gitee.com/DieHunter/myCode/tree/master/WebSocket">Gitee</a></strong></p> 
<div id="gtx-trans"> 
 <div>
  &nbsp;
 </div> 
</div>
                ]]></description></item><item><title>JS案例：触底懒加载</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/09/14599515.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Tue, 09 Mar 2021 11:13:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/09/14599515.html</guid><description><![CDATA[
                    <p><strong>接着上篇文章：<a href="https://blog.csdn.net/time_____/article/details/114311580">ajax获取图片列表</a>，我们来实现一下JS的经典案例，懒加载</strong></p> 
<p><strong>在web应用中，系统的响应速度对用户体验十分重要，其最主要的影响来源于服务端数据库查询，以及DOM渲染。<br> 数据库查询数据量大的情况下，我们可以进行分页配合前端分页或者懒加载进行优化，而这篇文章主要讲的是如何处理后端百万级数据对DOM渲染造成的影响，当然这也是大厂常问的题。</strong></p> 
<p><strong>在实现功能前，我们先了解一下懒加载，这是我之前实现的<a href="https://blog.csdn.net/time_____/article/details/84639454">懒加载</a>，懒加载也就是现在先加载一小部分，当某些条件触发时（触底，触及可视区，滚动条高度到了某个条件），进行延迟加载，解决大量资源同时加载缓慢导致用户体验下降。</strong></p> 
<p><strong>这里我将使用ajax获取图片列表的流程，从后端一次性传递几万几十万甚至上百万张图片信息（一般情况下后端会做分页处理，这样对服务端性能损耗很大），前端采取触底加载与分页处理解决DOM渲染问题。</strong></p> 
<p><strong>下面就来实现一下</strong></p> 
<p><strong>在服务端需要实现两个功能：</strong></p> 
<ul><li><strong>根据有限数组根据随机索引取某个单项（图片数量有限，暂时先使用几张图片循环出一定数量的随机图片列表）</strong></li><li><strong>服务端接收前端发送的参数决定传递几条数据（这样做就可以不需要修改后端，直接在前端看效果）</strong></li></ul>
<p><strong>首先新建图片path，一共5张图片</strong></p> 
<pre><code class="language-javascript">const picList = ['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg']
</code></pre> 
<p><strong>编写随机数方法，传入数字n产生1-n之间的随机数</strong></p> 
<pre><code class="language-javascript">function random (count) {
    return Math.floor(Math.random() * count)
}</code></pre> 
<p><strong>编写生成图片列表函数，传入数字n，产生长度为n的随机图片数组</strong></p> 
<pre><code class="language-javascript">function createPicList (len) {
    let _list = []
    for(let i = 0; i &lt; len; i ++) {
        _list.push(picList[random(picList.length)])
    }
    return _list
}</code></pre> 
<p><strong>然后在getList接口中将该值返回至前端（通过前端参数使长度可控）</strong></p> 
<pre><code class="language-javascript">res.write(JSON.stringify(createPicList(data.len)));</code></pre> 
<p><strong>最后，打开server，在浏览器中输入<a href="http://127.0.0.1:1024/getList?len=10">http://127.0.0.1:1024/getList?len=10</a>，传递10条，服务端就会返回10条随机图片地址</strong><br><img alt="" height="33" src="https://img-blog.csdnimg.cn/20210304100430568.png" width="470"></p> 
<p><strong>此时，服务端就算是大功告成，下面来客户端测试一下性能，修改ajax参数为1000，并添加时间戳记录运行时间</strong></p> 
<pre><code class="language-javascript">    let date = new Date(),
        serverDate,
        domDate;
    utils.myAjax({
        url: baseUrl + '/getList',
        method: 'get',
        data: {len: 1000},//传递长度为多少的列表（加载几张图片）
        timeout: 10 * 1000
    }).then((data) =&gt; {
        serverDate = new Date()
        loadPic.create(loadBox, data)
        domDate = new Date()
        //其他问题损耗时间暂时忽略不计
        console.log('收到请求：', (serverDate - date) / 1000)//后端运行速度+传输速度等等（单位/秒）
        console.log('DOM渲染：', (domDate - serverDate) / 1000)//DOM渲染速度（单位/秒）
    }).catch((err) =&gt; {
        console.log(err)
    })</code></pre> 
<p><strong>1000张图片，无论是加载速度还是DOM渲染速度都是很可观的</strong><br><img alt="" height="41" src="https://img-blog.csdnimg.cn/20210304102242973.png" width="500"></p> 
<p><strong>图片数量升到10000张，后端变化不是很大，但是Dom渲染明显慢了很多</strong><br><img alt="" height="34" src="https://img-blog.csdnimg.cn/20210304102315164.png" width="501"><br><strong>把图片数量升至100000，好家伙，CPU和内存直接飚升</strong><br><img alt="" height="23" src="https://img-blog.csdnimg.cn/20210304102802264.png" width="281"><img alt="" height="18" src="https://img-blog.csdnimg.cn/20210304102857672.png" width="328"><br><strong>最后，我作死尝试一下1000000张图片，差点没裂开，后端貌似挺稳健，DOM足足渲染了70秒</strong><br><img alt="" height="22" src="https://img-blog.csdnimg.cn/20210304103512812.png" width="276"><img alt="" height="18" src="https://img-blog.csdnimg.cn/20210304103553529.png" width="324"></p> 
<p><strong>这说明在后端百万级数据数据传递可控条件下，我们得在前端做好优化</strong></p> 
<p><strong>首先，我们引入之前造的轮子：<a href="https://blog.csdn.net/time_____/article/details/113770950">发布/订阅busEvent</a>（不引入也行，可以使用回调函数，主要作用是通知渲染view），这里我们需要将node中使用的</strong><strong>module.exports&nbsp;=&nbsp;EventBus.Instance()修改为当前适用的export default EventBus.Instance()</strong></p> 
<p><strong>然后新建LazyLoad类如下：</strong></p> 
<pre><code class="language-javascript">import eventBus
    from './eventBus.js'
import Utils
    from './utils.js'

const utils = new Utils()
export default class LazyLoad {
    constructor (pageConfig, ele, data) {
        Object.defineProperties(this, {
            //前端分页功能的分页配置
            'pageConfig': {
                value: pageConfig,
                writable: true
            },
            //待监听滚动的元素
            'ele': {
                value: ele,
                writable: false
            },
            //所有数据，图片列表
            'data': {
                value: data,
                writable: false
            }
        });
        this.init()
    }

    /**
     * 对总列表分页后截取start到end数据，并通知渲染页面
     * @param val  截取的数据
     */
    set pagingData (val) {
        //是否清除上一页
        this.pageConfig.clear ? (utils.clearEle(this.ele), this.ele.scrollTop = 0) : ""
        eventBus.emitEvent('lazyLoadStep', val)//数据翻页后通知渲染层，并将截取的数据传递过去
    }

    /*
     * 初始化函数
     */
    init () {
        this.scrollLoadPage(this.ele)
        this.nextPage()//获取第一页
    }

    /*
     * 翻页功能，若大于总页数则跳出
     */
    nextPage () {
        if(this.pageConfig.page &gt; this.pageConfig.totalPage) {
            console.log('到底了！')
            return
        }
        this.pagingData = this.paging(this.pageConfig, this.data)
        this.pageConfig.page ++
    }

    /*
     * 滚动事件
     */
    scrollLoadPage (ele) {
        ele.addEventListener('scroll', this.loadHandler.bind(this))
    }
    /*
     * 滚动事件回调
     */
    loadHandler (e) {
        if(
            e.target.scrollHeight - e.target.scrollTop &lt;= e.target.clientHeight
        ) {
            this.nextPage()
        }
    }
    /*
     * 分页功能,截取数据
     * @param pageConfig  分页配置属性（page：第几页，pageSize；单页大小，totalPage：总页数,第一页无此属性）
     * @param data 总数据
     * @return data 当前页面截取的数据
     */
    paging (pageConfig, data) {
        let {
            page,
            pageSize
        } = pageConfig
        pageConfig.totalPage = Math.ceil(data.length / pageConfig.pageSize)
        let startIndex = page * pageSize - pageSize
        let endIndex = page * pageSize
        return data.slice(startIndex, endIndex)
    }
}</code></pre> 
<p><strong>最后在HTML页面中引入eventBus和lazyLoad，并将之前的loadPic.create函数替换为new LazyLoad(pageConfig, loadBox, data)，并且将loadPic.create放在eventBus的异步处理中便可以得到以下代码：</strong></p> 
<pre><code class="language-javascript">    import Utils
        from "./js/utils.js"
    import LoadPic
        from './js/loadPic.js'
    import LazyLoad
        from "./js/lazyLoad.js";
    import eventBus
        from './js/eventBus.js'

    let pageConfig = {
        page: 1,//第几页
        pageSize: 30,//每页大小
        clear: false//翻页时是否清空上一页
    }
    let baseUrl = 'http://127.0.0.1:1024'//请求地址
    let picPath = '/static/'//静态文件路径
    let utils = new Utils()
    let loadBox = document.querySelector('#loadBox')//需要进行懒加载的元素
    let loadPic = new LoadPic()
    let lazyLoad;
    let serverDate=new Date(),//服务器响应时间
        domDate;//view渲染时间
    loadPic.baseUrl = baseUrl + picPath
    eventBus.onEvent('lazyLoadStep', function (e) {//监听翻页动作，渲染页面
        domDate = new Date()//初始化view渲染时间
        loadPic.create(loadBox, e)
        console.log('DOM渲染：', (new Date() - domDate) / 1000)//DOM渲染速度（单位/秒）
    })
    utils.myAjax({
        url: baseUrl + '/getList',
        method: 'get',
        data: {len: 1000},//传递长度为多少的列表（加载几张图片）
        timeout: 10 * 1000//请求超时时间
    }).then((data) =&gt; {
        console.log('收到请求：', (new Date() - serverDate) / 1000)//后端运行速度+传输速度等等（单位/秒）
        lazyLoad = new LazyLoad(pageConfig, loadBox, data)//初始化懒加载
    }).catch((err) =&gt; {
        console.log(err)
    })</code></pre> 
<p><strong>至此，一个简单的Ajax请求后端并获取图片列表，并对列表进行分页懒加载图片的小案例完成，我们试试效果</strong><br><img alt="" height="222" src="https://img-blog.csdnimg.cn/20210304153651847.gif" width="381"><br><strong>如果把pageConfig中的清空上一页改为true，那就变成了只能看到下一页的懒加载了，但是这么做的好处能减少dom元素较多导致后续内存升高问题</strong><br><img alt="" height="220" src="https://img-blog.csdnimg.cn/20210304154108442.gif" width="378"></p> 
<p><strong>最后，感谢看到了最后的你，附上<a href="https://gitee.com/DieHunter/myCode/tree/master/%E7%80%91%E5%B8%83%E6%B5%81&amp;%E6%87%92%E5%8A%A0%E8%BD%BD/Third">源码地址</a>，希望对你有所帮助。</strong></p>
                ]]></description></item><item><title>JS案例：ajax获取图片列表</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/04/14482712.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 04 Mar 2021 07:55:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/04/14482712.html</guid><description><![CDATA[
                    <p><strong>AJAX是个啥？有什么作用？如何实现AJAX？如何使用AJAX？这几个问题我在前端JS的面试题中，遇见了不少，对于前后端分离，单页面渲染流行的今日，ajax似乎变得很重要。</strong></p> 
<p><strong>那么什么是Ajax？<br> Ajax（Asynchronous JavaScript and XML），又被称为异步 JavaScript 和 XML，它不是一门语言，而是web应用的一门技术。要知道，如果在2009年你了解前端的dom操作，ajax技术和一点点JS语法，你就已经可以找到一份不错的web前端的工作了。也正是Ajax技术将前后端分离和单页面渲染流行度提升了很大的空间</strong></p> 
<p><strong>Ajax有什么作用？<br> ajax的作用用官话来讲就是：在不需要刷新页面的情况下，就可以产生局部刷新的效果，也就是在页面不刷新的情况下实现局部渲染，使前后端数据传输得到提升。ajax实现了在浏览器与服务器之间进行http传输（只需要获得少量数据，而不用渲染整个页面），使web程序更快，更小。</strong></p> 
<p><strong>如何实现AJAX？<br> 在<a href="https://www.w3school.com.cn/ajax/index.asp">W3School</a>上有详细文档<br> 有几点需要注意：</strong></p> 
<ul><li><strong>IE低版本浏览器与其他浏览器兼容性问题</strong></li><li><strong>GET与POST请求方式的写法问题（GET需要将参数拼接在URL中并且不需要传data，而POST需要传data不需要拼接URL）</strong></li><li><strong>同步与异步方式中的请求超时timeout（异步可以填写timeout，而同步会报错）</strong></li></ul>
<p><strong>这里我也简单实现一下：<br> 首先，我们写个将对象属性拼接到url中的函数，方便get方式请求时调用</strong></p> 
<pre><code class="language-javascript">    /*
     * 将对象属性拼接到url中
     * @param url：接口地址
     * @param obj：需要操作的对象
     * @return string:拼接结果
     */
    function urlJoin (url, obj) {
        let list = []
        for(let key in obj) {
            if(obj.hasOwnProperty(key)) {
                list.push(`${key}=${obj[key]}`)
            }
        }
        return `${url}?${list.join('&amp;')}`
    }</code></pre> 
<p><strong>然后就是ajax的基本写法（这里对ajax响应做了一个Promise操作，当然也可以改为回调或者事件监听）</strong></p> 
<pre><code class="language-javascript">    /*
     * ajax请求方法
     * @param config method：请求类型 url：接口地址 data：输入参数 timeout：超时时间
     * @return Promise:Promise异步处理
     */
    function myAjax (config) {
        let xhr;
        if(window.ActiveXObject) { //ie浏览器
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        } else if(window.XMLHttpRequest) { //其他浏览器
            xhr = new XMLHttpRequest();
        }
        config.method === 'get' ? (function () {//判断get与post等请求方式
            config.url = urlJoin(config.url, config.data);
            config.data = null
        }()) : "";
        //open(请求方式|string，请求路径|string，是否异步|bool)异步一般选择true，false代表同步，选false则会使请求不堵塞,不会等待请求结果,此时的timeout也无意义
        xhr.open(config.method, config.url, config.async || true);
        xhr.send(config.data ? config.data : {})
        config.async ? xhr.timeout = config.timeout || 10 * 1000 : ''//ajax请求超时，默认10秒
        return new Promise((resolve, reject) =&gt; {
            xhr.addEventListener('timeout', function () {//超时抛错
                reject(this)
                throw Error('request timeout')
            })
            xhr.addEventListener('load', function () {
                if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) {//请求成功
                    resolve(JSON.parse(this.response))
                } else {
                    reject(this)
                }
            })
        })
    }</code></pre> 
<p><strong>实现完成后得点个题啊，文章的目的是获取图片列表，接着上篇文章的<a href="https://blog.csdn.net/time_____/article/details/114281583">nodejs搭建静态目录服务</a>继续往下整<br> 在上篇文章的其他接口中，新增一个获取图片列表的接口getList</strong><br><img alt="" height="151" src="https://img-blog.csdnimg.cn/2021030315423597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="239"><br><strong>这里我优化了一下，处理跨域，摒弃了node旧模块而使用了URL类，于是得到以下代码</strong></p> 
<pre><code class="language-javascript">let server = http.createServer((req, res) =&gt; {
    res.setHeader('Access-Control-Allow-Origin', '*')//设置响应头解决跨域
    let url = new URL(req.url, `http://${req.headers.host}`)//解析请求的地址
    let data = urlSplit(url.href)//获取参数
    if(req.url.indexOf('/static/') !== - 1) {
        console.log('获取静态文件')
        readFile('.' + req.url).then((data) =&gt; {
            res.write(data, "binary");
            res.end();
        })
    } else {
        switch(url.pathname) {
            case '/getList':
                console.log('获取列表')
                res.write(JSON.stringify(['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg']));
                res.end();
                break;
            default:
                res.writeHead(404, {'Content-Type': 'text/plain'})
                res.write("not find");
                res.end();
                break;
        }
    }
})</code></pre> 
<p><strong>通过访问<a href="http://127.0.0.1:1024/getList">http://127.0.0.1:1024/getList</a>就可以获取到列表</strong><br><img alt="" height="36" src="https://img-blog.csdnimg.cn/20210303164839769.png" width="306"><br><strong>于是我们就可以开始实现view的渲染，新建一个loadPic类，功能是获取静态资源路径并渲染图片（其中utils类是工具类，包括ajax在内，后续在完整项目中可以看到）</strong></p> 
<pre><code class="language-javascript">import Utils
    from './utils.js';

let utils = new Utils()
export default class LoadPic {
    //静态资源路径
    set baseUrl (val) {
        this._baseUrl = val
    }

    get baseUrl () {
        return this._baseUrl
    }

    //根据数据渲染图片
    create (ele, data) {
        for(let i = 0; i &lt; data.length; i ++) {
            let liBox = utils.createEle('li', {listStyle: 'none'}, {}, ele)
            utils.createEle('img', null, {
                src: `${this.baseUrl}${data[i]}`
            }, liBox)
        }
    }
}</code></pre> 
<p><strong>然后我们在JS中使用ajax来获取数据并加载图片</strong></p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;
        lazyLoad&lt;/title&gt;
    &lt;style&gt;
        li, li &gt; img {
            float: left;
            height: 200px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;ul id="loadBox"&gt;&lt;/ul&gt;
&lt;script type="module"&gt;
    import Utils
        from "./js/utils.js"
    import LoadPic
        from './js/loadPic.js'

    let baseUrl = 'http://127.0.0.1:1024'
    let picPath = '/static/'
    let utils = new Utils()
    let loadBox = document.querySelector('#loadBox')
    let loadPic = new LoadPic()
    loadPic.baseUrl = baseUrl + picPath
    utils.myAjax({
        url: baseUrl + '/getList',
        method: 'get',
        data: {len: 100},
        timeout: 3 * 1000
    }).then((data) =&gt; {
        loadPic.create(loadBox, data)
        console.log(data)
    }).catch((err) =&gt; {
        console.log(err)
    })

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>列表效果与之前一样，图片也加载出来了</strong><br><img alt="" height="86" src="https://img-blog.csdnimg.cn/2021030316525169.png" width="425"><img alt="" height="89" src="https://img-blog.csdnimg.cn/20210303171604984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="244"><br><strong>最后附上源码：<a href="https://gitee.com/DieHunter/myCode/tree/master/Ajax%E8%AF%B7%E6%B1%82node%E6%8E%A5%E5%8F%A3">gitee地址，</a>希望对各位有所帮助</strong></p>
                ]]></description></item><item><title>原生Node实现静态目录</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/02/14482713.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Tue, 02 Mar 2021 06:20:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/03/02/14482713.html</guid><description><![CDATA[
                    <p><strong>一个朋友让我实现静态资源托管，之前写的都是直接通过Express或Koa框架实现的，一行代码就可以解决</strong></p> 
<pre><code class="language-javascript">app.use('/img', express.static(path.join(__dirname, './img')));</code></pre> 
<p><strong>恰好最近在看原生node，于是我自己试着实现了一个简单的静态资源托管，同时也为下篇懒加载文章做铺垫</strong></p> 
<p><strong>首先，项目需要在node环境下运行服务器，搭建配置node参照<a href="https://blog.csdn.net/time_____/article/details/114024145">这篇文章</a></strong></p> 
<p><strong>新建server.js文件执行node代码，在server.js中引入等会要用到的模块http和fs（filesystem）</strong></p> 
<pre><code class="language-javascript">const http = require('http');
const fs = require('fs');</code></pre> 
<p><strong>在server中创建http服务并且监听1024端口</strong></p> 
<pre><code class="language-javascript">let server = http.createServer((req, res) =&gt; {
    
})
server.listen(1024, () =&gt; {
    console.log('服务开启！')
})</code></pre> 
<p><strong>然后新增方法同步读取文件内容并返回读取结果</strong></p> 
<pre><code class="language-javascript">function readFile (filePath) {
    return new Promise((resolve, reject) =&gt; {
        fs.readFile(filePath, "binary", (err, data) =&gt; {
            if(err) {
                reject(err);
                return
            }
            resolve(data)
        })
    })
}</code></pre> 
<p><strong>最后，在http服务中对请求的url做判断，并调用读取文件的函数</strong></p> 
<pre><code class="language-javascript">    if(req.url.indexOf('/static/') !== - 1) {//判断请求路径是否包含static目录（简单判断）
        console.log('获取静态文件')
        readFile('.' + req.url).then((data) =&gt; {
            res.write(data, "binary");
            res.end();
        })
    } else {
        console.log('其他接口')
        res.write("other");
        res.end();
    }</code></pre> 
<p><strong>完整的server.js文件</strong></p> 
<pre><code class="language-javascript">const http = require('http');
const fs = require('fs');
let server = http.createServer((req, res) =&gt; {
    if(req.url.indexOf('/static/') !== - 1) {
        console.log('获取静态文件')
        readFile('.' + req.url).then((data) =&gt; {
            res.write(data, "binary");
            res.end();
        })
    } else {
        console.log('其他接口')
        res.write("other");
        res.end();
    }
})

function readFile (filePath) {
    return new Promise((resolve, reject) =&gt; {
        fs.readFile(filePath, "binary", (err, data) =&gt; {
            if(err) {
                reject(err);
                return
            }
            resolve(data)
        })
    })
}

server.listen(1024, () =&gt; {
    console.log('服务开启！')
})</code></pre> 
<p><strong>server.js完成后，在server目录下创建img文件夹，并放几个静态文件</strong><br><img alt="" height="97" src="https://img-blog.csdnimg.cn/20210302141256926.png" width="139"><br><strong>通过node server.js或node server启动服务器</strong><br><img alt="" height="85" src="https://img-blog.csdnimg.cn/20210302141442565.png" width="398"><br><strong>在浏览器输入框输入url，我这里是：<a href="http://127.0.0.1:1024/static/1.jpg">http://127.0.0.1:1024/static/1.jpg</a>和<a href="http://127.0.0.1:1024/static/1.txt">http://127.0.0.1:1024/static/1.txt</a></strong><br><img alt="" height="128" src="https://img-blog.csdnimg.cn/20210302141627402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="239"><img alt="" height="127" src="https://img-blog.csdnimg.cn/20210302141659812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="237"><br><strong>显示出相关资源后就算完成了</strong></p>
                ]]></description></item><item><title>TypeScript学习笔记（一）TS介绍，环境安装与运行</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/02/25/14482714.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 25 Feb 2021 07:34:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/02/25/14482714.html</guid><description><![CDATA[
                    <h3><strong>介绍：</strong></h3> 
<p><strong>TypeScript是JavaScript的超集，扩展了JavaScript的语法，因此现有的JavaScript代码可与TypeScript一起工作无需任何修改，TypeScript通过类型注解提供编译时的静态类型检查。其源于JavaScript（JS的拓展），终于JavaScript（编译成JS）<br> TypeScript 起源于使用JavaScript开发的大型项目 。由于JavaScript语言本身的局限性，难以胜任和维护大型项目开发。因此微软开发了TypeScript ，使得其能够胜任开发大型项目。</strong></p> 
<h3><strong>环境安装：</strong></h3> 
<p><strong>首先安装node与npm，参考<a href="https://blog.csdn.net/time_____/article/details/114024145">这篇文章</a><br> 打开cmd，运行以下命令安装TypeScript</strong></p> 
<pre><code>npm install -g typescript
</code></pre> 
<p><strong>安装完成后输入 tsc -v 查看安装是否成功，然而有时会碰上下图问题，系统禁止执行脚本</strong><br><img alt="" height="89" src="https://img-blog.csdnimg.cn/20210224220356608.png" width="505"><br><strong>首先输入get-ExecutionPolicy来获取是否允许脚本执行状态，显示Restricted说明脚本不被允许执行，此时我们输入&nbsp;set-ExecutionPolicy RemoteSigned即可</strong><br><img alt="" height="164" src="https://img-blog.csdnimg.cn/2021022422055293.png" width="471"><br><strong>网上还有一种方式是删除ts依赖下的tsc.ps1文件，亲测有效，副作用尚未发现</strong><br><img alt="" height="40" src="https://img-blog.csdnimg.cn/20210224221040298.png" width="653"></p> 
<h3>IDE推荐：</h3> 
<p><strong>微软官方的Visual Studio Code（简称VS Code）:做开发以来使用的最舒服的轻量级IDE，支持ts开发，之前用的sublime和atom总感觉缺点什么，这款编辑器插件丰富，界面简洁，如今支持配置同步，让开发得心应手<br> JetBrains公司旗下的WebStorm：作为一款重量级web编辑器，功能可以说是非常齐全，在编辑ts时可以配置自动编译，如果说VScode轻量简洁开发舒服，Webstorm可以说是功能强大，专为web开发而生的神器</strong></p> 
<h3><strong>开发与运行：</strong></h3> 
<p><strong>以VS-Code为例：<br> 在目录下新建app.ts文件，输入以下代码</strong></p> 
<pre><code class="language-TypeScript">class HelloWorld {
    constructor() { }
    say() {
        console.log('hello world')
    }
}
new HelloWorld().say()</code></pre> 
<p><strong>将cmd打开于当前目录下，输入tsc app.ts或者简写tsc app，ts会编译一个app.js文件生成在目录下，编译结果如下</strong></p> 
<pre><code class="language-javascript">var HelloWorld = /** @class */ (function () {
    function HelloWorld() {
    }
    HelloWorld.prototype.say = function () {
        console.log('hello world');
    };
    return HelloWorld;
}());
new HelloWorld().say();
</code></pre> 
<p><strong>这就是我们熟悉的JS原生代码，我们使用node app.js或者简写node app执行app.js，控制台会输出hello world</strong><br><img alt="" height="77" src="https://img-blog.csdnimg.cn/20210225152057132.png" width="447"><br><strong>然而每次都需要编译ts并在node执行调试有点麻烦，这里推荐一个插件<a href="https://www.npmjs.com/package/ts-node">ts-node</a>，在cmd中全局安装依赖</strong></p> 
<pre><code>npm i ts-node -g</code></pre> 
<p><strong>安装完成之后在cmd中执行 ts-node app，会直接编译并在node中执行，打印hello world（注意：该操作不会生成app.js文件，而是直接自动编译直接执行）</strong><br><img alt="" height="36" src="https://img-blog.csdnimg.cn/20210225152709909.png" width="397"></p> 
<p><strong>当然，在webstorm中，打开设置，将TS的自动编译打开，也会节省不少事</strong><br><img alt="" height="237" src="https://img-blog.csdnimg.cn/20210225153104157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="321"></p> 
<h3><strong>总结：</strong></h3> 
<p><strong>以上就是TypeScript起步的介绍，环境安装与运行及注意事项</strong></p>
                ]]></description></item><item><title>Nodejs安装配置与npm配置</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/02/24/14482715.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Wed, 24 Feb 2021 12:38:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/02/24/14482715.html</guid><description><![CDATA[
                    <h3>前言：</h3> 
<p><strong>该片文章主要介绍一下node环境的安装流程及排雷，为下篇TypeScript文章做铺垫</strong></p> 
<h3><strong>环境安装：</strong></h3> 
<p><strong>这里我使用的是nvm（node管理工具）对node进行安装，直接一步到位，省去一些配置<br><a href="https://gitee.com/DieHunter/myCode/tree/master/Nvm%E5%B7%A5%E5%85%B7">我的gitee上的nvm托管地址</a><br> 当然也可以去<a href="https://github.com/coreybutler/nvm-windows/releases">GitHub</a>或者<a href="https://gitee.com/mirrors/nvm">码云托管</a>上下载nvm</strong></p> 
<p><strong>下载好安装包后双击安装nvm，选择我同意，并点击下一步</strong><br><img alt="" height="258" src="https://img-blog.csdnimg.cn/2021022415321390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="334"><br><strong>选择安装路径，点击下一步</strong><br><img alt="" height="256" src="https://img-blog.csdnimg.cn/20210224153246499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="332"><br><strong>选择安装好后，node快捷方式的路径</strong><br><img alt="" height="253" src="https://img-blog.csdnimg.cn/20210224153421927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="328"><br><strong>最后点击安装，途中若杀毒软件提示应用修改环境变量点击允许即可</strong><br><img alt="" height="248" src="https://img-blog.csdnimg.cn/20210224153536972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="321"><br><strong>安装完成后在环境变量中多出以下变量，并且在cmd中输入nvm -version显示下图，说明安装成功</strong></p> 
<p><img alt="" height="37" src="https://img-blog.csdnimg.cn/20210224154223333.png" width="309"><br><img alt="" height="228" src="https://img-blog.csdnimg.cn/20210224154515847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="349"><br><strong>下一步，我们设置一下nvm的下载镜像，提升其下载node的速度<br> 我们进入到nvm安装目录下，打开settings.txt，并在最后一行添加淘宝镜像路径，替换原始的下载地址</strong></p> 
<pre><code class="language-javascript">node_mirror: https://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/</code></pre> 
<p><strong>替换完成后，我们就可以进行下一步的操作</strong><br><img alt="" height="334" src="https://img-blog.csdnimg.cn/20210224155119979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="409"><br><strong>再次打开cmd，输入以下命令用于安装nodejs指定版本（注：win7不支持node v12版本以上的，win8、win10支持高版本的node，我的电脑是win7系统，所以至今为止，我能安装的最高版本是12.20.2）</strong></p> 
<pre><code>nvm install node@12.20.2</code></pre> 
<p><strong>显示以下结果就说明安装node和nvm成功了</strong><br><img alt="" height="171" src="https://img-blog.csdnimg.cn/20210224160250765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="323"><br><strong>我们输入nvm use node版本号即可切换当前使用的node版本<br> 如：&nbsp;nvm use 12.20.2，控制台提示Now using node v12.20.2 (64-bit)说明切换成功</strong><br><strong>​​​​此时我们运行node即可进入node环境，在node环境中连续按两次ctrl+c即可退出node</strong><br><img alt="" height="144" src="https://img-blog.csdnimg.cn/20210224160758258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="294"></p> 
<p><strong>node也可以正常运行后，我们来配置一下npm的一些属性<br> 打开cmd，输入npm -v，显示出版本号说明npm安装成功（npm一般是自动随node一起安装的）<br> 输入以下命令设置npm全局安装路径及缓存路径，具体根据自己需要进行配置，这里最好不要配置在node文件夹中，因为node版本会变化，下次又要重新配置</strong></p> 
<pre><code>全局依赖安装路径：npm config set prefix "D:\soft\nvm\global"
npm缓存路径：npm config set cache "D:\soft\nvm\cache"
</code></pre> 
<p><strong>设置完成后，之后安装的全局依赖包都会在global文件夹下</strong><br><img alt="" height="308" src="https://img-blog.csdnimg.cn/20210224162743695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="388"><br><strong>最后，我们设置npm镜像，有两种方式提速：第一种是使用cnpm（可以理解为下载速度更快的npm），第二种是设置npm代理淘宝镜像<br> cnpm：打开cmd输入以下命令</strong></p> 
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre> 
<p><strong>后续可以使用cnpm进行依赖安装，如cnpm -i axios，但是如果项目一开始就使用cnpm，那么后续操作就必须都使用cnpm，不能换成npm下载，反之亦然</strong></p> 
<p><strong>设置npm镜像：个人比较推荐这种方式，解决npm在国内对于某些包下载比较慢的问题<br> 同样打开cmd输入以下命令</strong></p> 
<pre><code>npm config set registry https://registry.npm.taobao.org</code></pre> 
<p><strong>至此，nodejs安装配置以及npm配置已经全部结束</strong></p>
                ]]></description></item><item><title>JS案例：Observer Pattern(观察者模式)和Publisher-Subscriber Pattern(发布者/订阅者模式)</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/02/11/14482717.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 11 Feb 2021 07:02:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2021/02/11/14482717.html</guid><description><![CDATA[
                    <h3><strong>发布/订阅模式和观察者模式一样吗？</strong></h3> 
<p><strong>在许多地方我们都能见到基于这二者或者说基于某种设计模式的框架，函数或插件</strong></p> 
<p><strong>在浏览器中使用addEventListener(type,fn)对dom元素进行事件委托，事件监听用户的异步操作<br> Android中也有一个事件发布/订阅的轻量级框架：EventBus，原理与web相似<br> Socket.io的许多方法也是基于此类模式，监听与触发事件，批量广播等<br> 在Node中同样也有一个events事件触发器解决异步操作的同步响应</strong></p> 
<p><strong>那么其二者有什么区别吗，下面两张图可以简单描述他们的过程（发布者/订阅者模式我直接用事件的侦听（addeventlistener）与事件的派遣（dispatchevent）来形容帮助理解）</strong><br><img alt="" height="243" src="https://img-blog.csdnimg.cn/20210209212521379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="515"><img alt="" height="242" src="https://img-blog.csdnimg.cn/20210209221110581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="514"></p> 
<h3><strong>Observer Pattern(观察者模式)：</strong></h3> 
<p><strong>Subject(主题，或者叫被观察者)：当状态发送变化时，需要通知队列中关联对象<br> Observer(观察者)：当Subject发送消息时，通过回调获得信息<br> Observer(观察者)将事件（记做fn回调）丢给Subject(被观察者)，然后就开始监视着他的一举一动，当Subject(被观察者)的（异步）任务完成后，同步触发事件fn回调将消息传输给Observer(观察者)后，完成一个完整的周期</strong></p> 
<p><strong>实现过程：<br> Observer.js：</strong></p> 
<pre><code class="language-javascript">module.exports = class Observer { //定义观察者类，每个实例化后的观察者拥有订阅（subscribe）功能
    constructor() {}
    /**
     * 订阅
     * @param target 被观察者Subject的实例对象
     * @param fn 订阅注册的回调
     */
    subscribe(target, fn) {
        target.observerList.push(fn)
    }
}</code></pre> 
<p><strong>&nbsp;Subject.js：</strong></p> 
<pre><code class="language-javascript">module.exports = class Subject { //定义被观察者类，每个实例化后拥有注册的观察者回调的列表（observerList）和触发回调（fireEvent）功能
    constructor() {
        this.observerList = []
    }
    /**
     * 触发
     * @param e 被观察者传递给观察者的参数
     */
    fireEvent(e) {
        this.observerList.forEach(item =&gt; {
            item(e)
        })
    }
}</code></pre> 
<p><strong>main.js（使用场景）&nbsp;</strong></p> 
<pre><code class="language-javascript">const Observer = require('./js/observer');
const Subject = require('./js/subject')

class MyObserver extends Observer {}
class MySubject extends Subject {}

// 实例化两个观察者，同时对一个subject进行监听
const observer = new MyObserver()
const observer2 = new MyObserver()
const subject = new MySubject()

observer.subscribe(subject, (e) =&gt; {
    console.log(e) //hello world
})
observer2.subscribe(subject, (e) =&gt; {
    console.log(e) //hello world
})
// 延时激活观察者注册的函数，传递参数
setTimeout(subject.fireEvent.bind(subject, 'hello world'), 1000)</code></pre> 
<h3><strong>Publisher-Subscriber Pattern(发布者/订阅者模式)：</strong></h3> 
<p><strong>Subscriber(订阅者)：将事件注册到事件调度中心（Event Channel或者可以看做EventBus(事件总线)）<br> Publisher(发布者)：触发调度中心的事件<br> Event Channel(调度中心)，与Vue和Android中的EventBus(事件总线)相似：得到Publisher(发布者)的消息后，统一处理Subscriber(订阅者)注册的事件<br> Subscriber(订阅者)通过on将事件注册到Event Channel(调度中心)，并与Event Channel通过回调进行数据传递，当Subscriber(订阅者)触发Event Channel(调度中心)的事件并将数据传递至其中时，调度中心会激活之前与Subscriber(订阅者)建立的联系，通过emit发送数据，订阅者收到数据后完成一个周期</strong></p> 
<p><strong>实现过程：<br> eventBus.js</strong></p> 
<pre><code class="language-javascript">// 发布/订阅设计模式(Pub/Sub)
class EventBus {
    constructor() {
        this._eventList = {} //调度中心列表
    }

    static Instance() { //返回当前类的实例的单例
        if (!EventBus._instance) {
            Object.defineProperty(EventBus, "_instance", {
                value: new EventBus()
            });
        }
        return EventBus._instance;
    }
    /**
     * 注册事件至调度中心
     * @param type 事件类型，特指具体事件名
     * @param fn 事件注册的回调
     */
    onEvent(type, fn) { //订阅者
        if (!this.isKeyInObj(this._eventList, type)) { //若调度中心未找到该事件的队列，则新建某个事件列表（可以对某个类型的事件注册多个回调函数）
            Object.defineProperty(this._eventList, type, {
                value: [],
                writable: true,
                enumerable: true,
                configurable: true
            })
        }
        this._eventList[type].push(fn)
    }
    /**
     * 触发调度中心的某个或者某些该事件类型下注册的函数
     * @param type 事件类型，特指具体事件名
     * @param data 发布者传递的参数
     */
    emitEvent(type, data) { //发布者
        if (this.isKeyInObj(this._eventList, type)) {
            for (let i = 0; i &lt; this._eventList[type].length; i++) {
                this._eventList[type][i] &amp;&amp; this._eventList[type][i](data)
            }
        }
    }
    offEvent(type, fn) { //销毁监听
        for (let i = 0; i &lt; this._eventList[type].length; i++) {
            if (this._eventList[type][i] &amp;&amp; this._eventList[type][i] === fn) {
                this._eventList[type][i] = null
            }
        }
    }
    /**
     * 检查对象是否包含该属性，除原型链
     * @param obj 被检查对象
     * @param key 被检查对象的属性
     */
    isKeyInObj(obj, key) {
        if (Object.hasOwnProperty.call(obj, key)) {
            return true
        }
        return false
    }
}

module.exports = EventBus.Instance()</code></pre> 
<p><strong>main.js</strong></p> 
<pre><code class="language-javascript">const EventBus = require('./js/eventBus')
let list = [], //记录异步操作
    count = 0, //计数器
    timeTick = setInterval(function () {
        if (count++ &gt; 3) { //当执行到一定时间时，销毁事件、定时器
            EventBus.offEvent('finish', eventHandler)
            clearInterval(timeTick)
        }
        list.push(count)
        EventBus.emitEvent('finish', {
            list
        })
    }, 1000)

EventBus.onEvent('finish', eventHandler)

function eventHandler(e) {
    console.log(e)
    // { list: [ 1 ] }
    // { list: [ 1, 2 ] }
    // { list: [ 1, 2, 3 ] }
    // { list: [ 1, 2, 3, 4 ] }
}</code></pre> 
<p><strong>总结：发布者/订阅者模式实际上是基于观察者模式上优化实现的，然而其二者的区别还是有的</strong></p> 
<p><strong>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新<br> 优点：观察者和被观察者是抽象耦合的，其二者建立了一套触发机制，松耦合<br> 缺点：二者之间循环依赖，如果关系复杂，如观察者数量过多，还是会造成性能问题，解决方式是避免同步执行造成线程阻塞</strong></p> 
<p><strong>发布者/订阅者模式：与观察者模式类似，但是核心区别是发布者与订阅者互相无耦合，并不知道通知与被通知的对方的具体身份，而是将注册的函数放在统一的调度中心进行管理<br> 优点：发布者/订阅者完全解耦，可扩展性高，常应用在分布式，紧耦合服务中<br> 缺点：发布者解耦订阅者，这点既是主要优点，亦是缺点，打个比方，在Socket中，倘若服务端发送消息给客户端，不会在意是否发送成功，此时需要客户端返回接收到了消息才能算是保证了代码的可靠性和可用性</strong></p> 
<p><strong>相关源码：<a href="https://gitee.com/DieHunter/myCode/tree/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&amp;%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F">码云地址</a></strong></p> 
<div id="gtx-trans"> 
 <div class="gtx-trans-icon">
  &nbsp;
 </div> 
</div>
                ]]></description></item><item><title>React（前端面试题整合）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/12/16/14290012.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Wed, 16 Dec 2020 01:03:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/12/16/14290012.html</guid><description><![CDATA[
                    <p><strong><span style="color:#f33b45;">谈谈对react的理解</span></strong></p> 
<p><strong>react是基于v（视图层）层的一款框架，虚拟dom和diff算法<br> react特点：<br> 声明式设计<br> 高效，其中高效以现在虚拟dom，最大限度减少与dom的交互和diff算法<br> 灵活，体现在可以与已知的框架或库很好的配合<br> JSX，是js语法的扩展<br> 组件化，构建组件，是代码的更容易得到复用，比较建议在大型项目的开发<br> 单项数据，实现单项数流，从而减少代码复用</strong></p> 
<p><span style="color:#f33b45;"><strong>react有哪几个生命周期</strong></span></p> 
<p><strong><a href="https://blog.csdn.net/time_____/article/details/85253541">自己的总结</a></strong></p> 
<p><strong>分为三个阶段，初始，运行中，销毁</strong></p> 
<p><strong>初始化： </strong></p> 
<ul><li><strong>执行getDefaultProps钩子函数，执行一次，挂载属性props（无Dom元素，有组件相关的this但是无法获取数据，组件想要拥有默认属性可以通过这个钩子函数设置）</strong></li><li><strong>执行getInitialState钩子函数，初始化自身状态state（同上，无Dom元素，有组件相关的this，但是无法获取数据，组件想要拥有状态只能通过这个钩子函数） </strong></li><li><strong>componentWillMount（）挂载前（类似于Vue的created加beforeMount阶段，可以进行数据请求（ajax），做一些初始数据的获取和设置，并且在这里更改数据不会触发运行阶段的钩子函数，在这里还可以更改this的指向问题） </strong></li><li><strong>render(构建组件的虚拟DOM结构进行编译)</strong></li><li><strong><strong>componentDidMount（）挂载完成（有Dom元素，数据准备完毕，这里可以操作DOM，并且可以访问已经渲染的DOM，在这个钩子函数里面也可以进行对数据的获取） </strong></strong></li></ul>
<p><strong>运行中： </strong></p> 
<ul><li><strong>componentWillReceiveProps函数：当props发生变化时调用（当接收到的属性发生变化时触发，可以在这里更改改变后的属性去做一些事情，比如更改自己的状态，在这里this上的属性还没有更新，要想使用新的数据需要从参数中得到）</strong></li><li><strong>shouldComponentUpdate函数：主要做效率优化，控制组件是否随之更新，函数返回的true或false表示视图是否渲染，如：在函数中比较this.props.name（数据更新前）和props.name（数据更新后）对比，二者是否相同，从而避免重复渲染，加强优化 </strong></li><li><strong>componentWillUpdate函数：准备工作，多做一些调试工作，在props和state发生改变的时候执行，并且在render方法之前执行，但是你在这个钩子函数里不能更改状态，否则会造成死循环，类似Vue中的beforeUpdate render：重新渲染Dom </strong></li><li><strong><strong>componentDidUpdate：页面更新渲染完成，组件的更新结束后执行,在这里可以操作更新完成后的dom，类似Vue的updated </strong></strong></li></ul>
<p><strong>组件销毁： </strong></p> 
<ul><li><strong>componentWillUnmount：组件将要销毁，可以将定时器，事件等取消或结束 （ReactDOM.unmountComponentAtNode(node) 销毁节点中的组件）</strong></li></ul>
<p><strong><span style="color:#f33b45;">props与state的区别</span></strong></p> 
<p><strong>props是一个从外部传进组件的参数，由于React具有单向数据流，所以它的主要作用是从父组件向子组件传递数据，它是不可改变的。如果想要改变它，只能通过外部组件传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。 props除了可以传字符串、数字，还可以传数组，对象、甚至是回调函数。</strong></p> 
<p><strong>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，state是可以被改变的。state放改动的一些属性，比如点击选中，再点击取消。类似的这种属性就可以放到state里。 没有state的叫做无状态组件，多用props少用state，多写无状态组件。 修改state的值时，必须通过setState()方法。当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法</strong></p> 
<p><strong>主要区别：<br> state是组件自己管理数据，控制自己的状态，值是可以改变的；<br> props是外部传入的数据参数，不可变；<br> 相同点：</strong></p> 
<ul><li><strong>props和state都是导出HTML的原始数据</strong></li><li><strong>props和state都是确定性的，如果我们写的组件为同一props和state的组合生成了不同的输出，那么我们肯定在哪里做错了</strong></li><li><strong>props和state更改都会触发渲染更新，这里讨论同一个组件内的props和state，即props是从外层组件获取的，而state是当前组件自己维护的（这里可以看做是共同点也可看做是不同点，因为虽然都是会触发渲染更新，但是如何更改的机制不一样）</strong></li><li><strong>props和state都是纯JS对象（对象字面量，{}，我们会简称为对象；对于[]，我们会简称为数组），我们可以用typeof来判断他们，结果都是object</strong></li><li><strong>可以从父组件得到初始值props和state的初始值</strong></li></ul>
<p><strong>不同点：</strong></p> 
<ul><li><strong>可以从父组件修改自组件的props，而不能从父组件修改自组件的state</strong></li><li><strong>可以在组件内部分别对state和props设置初始值</strong></li><li><strong>props不可以在组件内部修改，但state可以在内部修改</strong></li></ul>
<p><span style="color:#f33b45;"><strong>react组件之间如何传值？</strong></span></p> 
<p><strong><a href="https://blog.csdn.net/time_____/article/details/85275221">自己的总结</a></strong></p> 
<p><strong>父组件向子组件传值，初步使用，这个是相当容易的，在使用 React 开发的过程中经常会使用到，主要是利用props来进行交流<br> 子组件向父组件传值，子组件控制自己的 state 然后告诉父组件的点击状态，然后在父组件中展示出来。<br> 没有任何嵌套关系的组件之间传值(事件总线，flux，redux)</strong></p> 
<p><span style="color:#f33b45;"><strong>React中，在setState后，发生了什么</strong></span></p> 
<p><strong>当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态。 这将启动一个称为和解（reconciliation）的过程。 和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。 为此，React将构建一个新的React元素树（可以将其视为 UI 的对象表示）。一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（diff）。 通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间。</strong></p> 
<p><span style="color:#f33b45;"><strong>vue react angular 怎么检测数据变化的</strong></span></p> 
<p><strong><span style="color:#000000;">Angular：</span></strong><span style="color:#333333;"><strong>在angular版本里面还是采用脏值检测来检测数据的变更的，但是和angularjs不一样的是,angular引入了zone.js来处理数据的变更。性能可以达到angularjs脏值检测的3到10倍<br> Vue：vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br> React：react状态变化只能通过setState,调用setState就会更新状态重新渲染dom&nbsp;</strong></span></p> 
<p><span style="color:#f33b45;"><strong>Virtual Dom实现的原理</strong></span></p> 
<p><strong>虚拟dom相当在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能<br> 用 javaScript对象结构表示dom树的结构；然后用这个树构建一个真正的dom树，插到文档中<br> 当状态变更的时候，重新构建一颗新的对象树。然后用新的树和旧的树进行比较，记录两颗树的差异<br> 把记录的差异之处重新进行dom 渲染 &nbsp;视图就更新了</strong></p> 
<p><span style="color:#f33b45;"><strong>如何实现Virtual Dom算法</strong></span></p> 
<p><strong>树的递归：<br> 新的节点的tagName或者key和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了，新的节点的tagName和 key（可能都没有）和旧的相同，开始遍历子树，没有新的节点，那么什么都不用做</strong></p> 
<p><strong>判断属性的更改（具体分为三个步骤）：</strong></p> 
<ul><li><strong>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</strong></li><li><strong>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</strong></li><li><strong>在第二步中同时查看是否有属性不存在与旧的属性列列表中</strong></li></ul>
<p><strong>判断列表差异算法实现（这个算法是整个 Virtual Dom 中最核心的算法）：</strong></p> 
<ul><li><strong>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</strong></li><li><strong>遍历新的节点列表，判断是否有新的节点</strong></li><li><strong>在第二步中同时判断节点是否有移动</strong></li></ul>
<p><strong>遍历子元素并创建标识：</strong></p> 
<ul><li><strong>判断两个列表差异</strong></li><li><strong>给节点打上标记</strong></li></ul>
<p><strong>渲染差异：</strong></p> 
<ul><li><strong>深度遍历树，将需要做变更操作的取出来</strong></li><li><strong>局部更新 DOM</strong></li></ul>
<p><span style="color:#f33b45;"><strong>使用setState遇到的问题（异步）</strong></span></p> 
<p><strong>this.setState()会调用render方法，但并不会立即改变state的值，state是在render方法中赋值的。所以执行this.setState()后立即获取state的值是不变的。同样的直接赋值state并不会触发更新，因为没有调用render函数。</strong></p> 
<p><strong>解决方法：</strong><strong>setState(data，callback)，DOM渲染完成后调用第二个参数callback，解决异步问题</strong></p> 
<p><span style="color:#f33b45;"><strong>在react中，什么是高阶组件</strong></span></p> 
<p><strong>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 高阶组件的作用，其实就是为了组件之间的代码复用。组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用。高阶组件内部的包装组件和被包装组件之间通过 props 传递数据。</strong></p> 
<p><span style="color:#f33b45;"><strong>如何在React中访问DOM</strong></span></p> 
<p><strong>在React的标签中可以通过ref={(ele) =&gt; this.ele= ele}接收放在实例上实际的 DOM 元素ele，通过this.ele访问原生ele标签，在React中，refs允许你直接访问DOM元素或组件实例。为了使用它们，可以向组件添加一个 ref 属性，该属性的值是一个回调函数，它将接收底层的 DOM 元素或组件的已挂接实例，作为其第一个参数。</strong></p> 
<p><span style="color:#f33b45;"><strong>React Native相对于原生的ios和Android有哪些优劣势</strong></span></p> 
<p><strong>优势:<br> 它对比原生开发更为灵活，对比H5体验更为高效。<br> 跨平台，开发者只需学习一种语言就能轻易为任何平台高效地编写代码。<br> 替代传统的WebView，打开效率更高，和原生之间的交互更方便。<br> 多个版本迭代后的今天，它已经拥有了丰富第三方插件支持。<br> React Native解决不了的，可以通过各位熟悉的原生来解决，互补益彰。<br> 更方便的热更新。</strong></p> 
<p><strong>劣势:<br> 尽管是跨平台，但是不同平台Api的特性与显示并不一定一致。<br> 相对增大了app的体积。<br> 调试相对麻烦。<br> Android上的兼容性问题。</strong></p> 
<p><strong>React Native适合作为项目中的补充，而不是作为核心去开发APP。因为尽管是跨平台和快捷开发，但是以React Native为核心，去开发稍微偏中型以上的项目，后期维护的人员绝对不比原生的少多少，而且项目大了，体验依旧是个大问题。<br> 相反，把React Native作为项目开发中的补充，可以在一定程度上实现平台业务的统一，还有灵活的开发效率，补充原生的不足。</strong></p> 
<p><span style="color:#f33b45;"><strong>react-router有几种传参方式</strong></span></p> 
<p><strong><a href="https://blog.csdn.net/time_____/article/details/85387384">自己的总结</a></strong></p> 
<p><strong>React Router 是一个基于React之上的强大路由库</strong></p> 
<p><strong>传参方式：</strong></p> 
<ul><li><strong>params：在编程式导航的push或replace中加 / : key，传递方式由路由匹配，只能传字符（JOSN处理），刷新界面依然保存</strong></li><li><strong>query：在路由path处写{path：‘/admin’，query：{name：aaa，age：20}},无需动态路由（即，在路径处有个 /：key），刷新后不保存，可传任何数据</strong></li><li><strong>state：类似query，在路由path处写{path：‘/admin’，state：{name：aaa，age：20}}，无需动态路由，刷新后保存，可传任何数据</strong></li></ul>
<p><span style="color:#f33b45;"><strong>react-router的实现原理是什么</strong></span></p> 
<p><strong>当用户点击页面跳转时，react-router阻止了浏览器的默认跳转行为，而改用history模块的pushState方法去触发url更新，当执行history.push时，执行了注册的listener函数，listener中的setState函数也被执行，将当前url地址栏对应的url传递下去，当Route组件匹配到该地址栏的时候，就会渲染该组件，如果匹配不到，Route组件就返回null</strong></p> 
<p><strong>react-router依赖基础是history库：<br> 老浏览器的history: 主要通过hash来实现，对应createHashHistory<br> 高版本浏览器: 通过html5里面的history，对应createBrowserHistory<br> node环境下: 主要存储在memeory里面，对应createMemoryHistory</strong></p> 
<p><strong><span style="color:#f33b45;">说说对Vuex，Flux和Redux的理解</span></strong></p> 
<p><strong>Vuex是一个专为Vue.js应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</strong></p> 
<p><strong>Flux和Redux都不是必须和React搭配使用的，因为Flux和Redux是完整的架构，在学习React的时候，只是将React的组件作为Redux中的视图层去使用了</strong></p> 
<p><strong>Flux和Redux区别：Redux是基于Flux实现的，Vuex是Redux的基础上进行改变，在Redux中我们只能定义一个store，在Flux中我们可以定义多个，在Redux中，store和dispatch都放到了store，在redux中本身就内置State对象</strong></p> 
<p><strong>Redux和Vuex的区别：Vuex是在Redux的基础上进行改变，Vuex使用mutation来替换Redux中的reducer，Vuex有自动渲染的功能</strong></p> 
<p><strong>一个Flux应用包含四个部分：</strong></p> 
<p><strong>Dispatcher，处理动作分发，维持 Store 之间的依赖关系<br> Store，负责存储数据和处理数据相关逻辑<br> Action，触发 Dispatcher<br> View，视图，负责显示用户界面</strong></p> 
<p><strong>Redux分为三部分</strong><strong>：</strong></p> 
<p><strong>Action，就是一个单纯的包含 { type, payload } 的对象，type 是一个常量用来标示动作类型，payload 是这个动作携带的数据。<br> Reducer 用来处理 Action 触发的对状态树的更改。</strong><br><strong>Store 的作用就是连接上两者</strong></p> 
<p><strong>vuex核心：</strong></p> 
<p><strong>state：存放多个组件共享的状态（数据）<br> mutations：存放更改state里状态的方法，用于变更状态，是唯一一个更改状态的属性<br> getters：将state中某个状态进行过滤，然后获取新的状态，类似于vue中的computed<br> actions：用于调用事件动作，并传递给mutation<br> modules：主要用来拆分state</strong></p> 
<p><span style="color:#f33b45;"><strong>说明Flux和Redux的处理流程</strong></span></p> 
<p><strong>Flux：</strong></p> 
<ul><li><strong>用户通过与 view 交互或者外部产生一个 Action，Dispatcher 接收到 Action 并执行那些已经注册的回调，向所有 Store 分发 Action。</strong></li><li><strong>通过注册的回调，Store 响应那些与他们所保存的状态有关的 Action。</strong></li><li><strong>然后 Store 会触发一个 change 事件，来提醒 controller-views 数据已经发生了改变。</strong></li><li><strong>Controller-views 监听这些事件并重新从 Store 中获取数据。</strong></li><li><strong>这些 controller-views 调用他们自己的 setState() 方法，重新渲染自身以及组件树上的所有后代组件。</strong></li></ul>
<p><strong>Redux：</strong></p> 
<ul><li><strong>store通过reducer创建了初始状态</strong></li><li><strong>view通过store.getState()获取到了store中保存的state挂载在了自己的状态上</strong></li><li><strong>用户产生了操作，调用了actions 的方法</strong></li><li><strong>actions的方法被调用，创建了带有标示性信息的action</strong></li><li><strong>actions将action通过调用store.dispatch方法发送到了reducer中</strong></li><li><strong>reducer接收到action并根据标识信息判断之后返回了新的state</strong></li><li><strong>store的state被reducer更改为新state的时候，store.subscribe方法里的回调函数会执行，此时就可以通知view去重新获取state</strong></li></ul>
                ]]></description></item><item><title>VueJs（前端面试题整合）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/12/10/14290013.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Thu, 10 Dec 2020 01:24:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/12/10/14290013.html</guid><description><![CDATA[
                    <p><span style="color:#f33b45;"><strong>vue和react的区别</strong></span></p> 
<ul><li><strong>React严格上只针对MVC的view层，Vue则是MVVM模式</strong></li><li><strong>virtual（虚拟） DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</strong></li><li><strong>组件写法不一样，React推荐的做法是 JSX + inline style，也就是把HTML和CSS全都写进JavaScript了，即'all in js'；Vue推荐的做法是webpack+vue-loader的单文件组件格式，即html，css，js写在同一个文件</strong></li><li><strong>数据绑定：vue实现了数据的双向绑定，react数据流动是单向的</strong></li><li><strong>state对象在react应用中不可变的，需要使用setState方法更新状态；在vue中，state对象不是必须的，数据由data属性在vue对象中管理</strong></li></ul>
<p><strong><span style="color:#f33b45;">redux和vuex的区别</span></strong></p> 
<ul><li><strong>vuex是redux的基础上进行改变，对仓库的管理更加明确</strong></li><li><strong>使用mutation来替换redux中的reducer</strong></li><li><strong>vuex有自动渲染的功能,所以不需要更新</strong></li><li><strong>vuex是专门为vue提供的状态管理工具,而redux是一个泛用的状态管理框架</strong></li></ul>
<p><span style="color:#f33b45;"><strong>vuex的实现原理</strong></span></p> 
<p><strong>Vuex的状态存储是响应式的，当Vue组件从store中读取状态时，若store中状态发生改变，响应的组件也会得到更新状态。但不能直接改变state,必须通过显示的提交(commit)mutations来追踪每一个状态的变化</strong></p> 
<p><span style="color:#f33b45;"><strong>双向数据绑定的原理</strong></span></p> 
<p><strong>vue实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。<br> 在MDN上对该方法的说明是：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 它接收三个参数，要操作的对象，要定义或修改的对象属性名，属性描述符。重点就是最后的属性描述符。<br> 属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合两种描述符的属性同时使用。上面说的get和set就是属于存取描述符对象的属性。 然后我们可以通过在存取描述符中的get和set方法内写入自定义的逻辑来实现对象获取属性和设置属性时的行为。</strong></p> 
<p><span style="color:#f33b45;"><strong>Vue中父组件如何向子组件传值</strong></span></p> 
<p><span style="color:#f33b45;"><strong>父子组件传参：</strong></span></p> 
<p><strong>1.父传子：通过props属性实现；子组件要做类型检测；</strong></p> 
<p><strong>2.子传父：</strong></p> 
<ul><li><strong>子组件this.$emit触发父组件监听的方法；$emit第二个参数为：向父组件传递的数据</strong></li><li><strong>父组件监听子组件触发的事件，然后调用绑定的方法；</strong></li></ul>
<p><span style="color:#f33b45;"><strong>非父子组件传参：</strong></span></p> 
<ul><li><strong>路由传值：&lt;router-link&gt;和编程式导航中，均可在query/params中传值，在子组件中：this.$route.query</strong></li><li><strong>通过$parent $children方法调用层级关系的组件内部的数据和方法：this.$parent.$data.id&nbsp; 获取父元素data中的id，但是容易造成代码耦合性太强，难以维护</strong></li><li><strong>eventBus：在全局定义一个eventBus</strong><br><strong>window.eventBus = new Vue( )或者Vue.eventBus = new Vue( )</strong><br><strong>在需要传递参数的组件中定义一个emit发送需要传递的值：eventBus.$emit(‘name’,id)</strong><br><strong>在需要接受参数的组件中，用on接受该值：eventBus.$on(‘name’,(val) =&gt; {…})</strong><br><strong>注意：使用完后要在beforeDestroy( )中关闭这个eventBus eventBus.$off(‘name’)</strong></li><li><strong>本地存储：localStorage或者sessionStorage，setItem存储value，getItem获取value</strong></li><li><strong>状态管理 Vuex</strong></li></ul>
<p><span style="color:#f33b45;"><strong>列举Vue中的事件修饰符</strong></span></p> 
<p><strong>Vue.js为v-on提供了事件修饰符。<br> 修饰符是由点开头的指令后缀来表示的。<br> .stop 阻止事件继续传播<br> .prevent 阻止默认事件<br> .capture 使用捕获模式<br> .self 只当事件在该元素本身（而不是子元素）触发时触发回调<br> .once 事件只会触发一次</strong></p> 
<p><span style="color:#f33b45;"><strong>vue常用指令有哪些</strong></span></p> 
<ul><li><strong>v-on &nbsp;监听DOM事件，比如v-on:click=”handleFunction”，可简写为 @click</strong></li><li><strong>v-bind &nbsp;绑定属性，比如 v-bind:href=”url”，可简写为 : href</strong></li><li><strong>v-for &nbsp;循环列表</strong></li><li><strong>v-if &nbsp;根据表达式seen的真假来插入/删除对应标签，比如 v-if=”seen”</strong></li><li><strong>v-else &nbsp;必须跟在v-if后</strong></li><li><strong>v-show &nbsp;根据表达式的真假值来切换元素的display CSS属性</strong></li><li><strong>v-model &nbsp;表单元素的数据双向绑定</strong></li><li><strong>v-text &nbsp;定义元素文本，比如 v-text=”message”</strong></li><li><strong>v-html &nbsp;更新元素的innerHTML</strong></li><li><strong>v-once &nbsp;只渲染元素和组件一次</strong></li></ul>
<p><span style="color:#f33b45;"><strong>用过哪些基于Vue</strong><strong>的组件库？</strong></span></p> 
<p><strong>Element-ui桌面端 mint-ui 移动端<br><a href="https://blog.csdn.net/time_____/article/details/109178004">自己总结的</a></strong></p> 
<p><span style="color:#f33b45;"><strong>Vue生命周期钩子有哪些，作用是什么</strong></span></p> 
<p><strong>Vue实例从创建到销毁的过程，就是生命周期<br> Vue的生命周期包括：开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程。<br> 在Vue的整个生命周期中，提供了一系列的事件，可以注册JS方法，达到控制整个过程的目的，在这些JS方法中的this直接指向的是vue的实例。 在Vue的整个生命周期中，实例可以调用一些生命周期钩子，这提供了执行自定义逻辑的机会。</strong></p> 
<p><strong>Vue提供的生命周期钩子如下：</strong></p> 
<ul><li><strong>beforeCreate 在实例初始化之后，数据观测(data observer，开始监控Data对象数据变化)和初始化事件(init event，Vue内部初始化事件)之前被调用。</strong></li><li><strong>created 在实例已经创建完成之后被调用。实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，event事件回调。挂载阶段尚未开始，$el 属性不可见。</strong></li><li><strong>beforeMount 在挂载开始之前被调用。相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</strong></li><li><strong>mounted 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。此时模板中的html渲染到了html页面中，此时一般可以做一些Ajax操作。注意mounted只会执行一次。</strong></li><li><strong>beforeUpdate 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</strong></li><li><strong>updated 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</strong></li><li><strong>beforeDestroy 在实例销毁之前调用。实例仍然完全可用。</strong></li><li><strong>destroyed 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</strong></li></ul>
<p><strong><a href="https://blog.csdn.net/time_____/article/details/85227914">自己的总结</a></strong></p> 
<p><span style="color:#f33b45;"><strong>v-if和v-show区别</strong></span></p> 
<ul><li>&nbsp;<strong>相同点：v-if 和 v-show 动态控制dom元素显示隐藏。</strong></li><li><strong>不同点：v-if显示隐藏是将dom元素整个添加或删除，（例如：&lt;div v-if=""&gt;&lt;/div&gt;&nbsp;，v-if 当值为 true时，显示div ，当值为false时，改元素消失，代码也会消失，相当于将代码删除了，当在为true时，页面会重新渲染div）；而v-show显示隐藏只是将css属性设为display: block 或none。dom元素还在。</strong></li><li><strong>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。</strong></li><li><strong>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载);&nbsp;v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留。</strong></li><li><strong>性能消耗：一般的，v-if有更高的切换消耗，而v-show有更多的初始化渲染消耗。</strong></li><li><strong>使用场景：如果需要频繁的切换而对安全性无要求，使用v-show。如果在运行时，条件不可能改变，则使用v-if较好。</strong>&nbsp;</li></ul>
<p><span style="color:#f33b45;"><strong>watch和</strong><strong>computed区别</strong></span></p> 
<p><strong>应用方面，watch比较适合对状态的监控，比如监控页面一个变量的值改变，需要进行什么操作。而computed适合简单计算并返回结果，结果随着内部变量改变而改变。<br> 调用方面，watch适合比较耗时的操作，比如网络异步请求，一个变量改变触发网络请求。watch可以看做一个onchange事件，computed可以看做几个变量的组合体。</strong></p> 
<p><strong><span style="color:#f33b45;">Vuex用过哪些方法，你如何在项目中使用它</span></strong></p> 
<p><strong>Store&nbsp; 表示对Vuex对象的全局引用。组件通过Store来访问Vuex对象中的State<br> State&nbsp; Vuex对象的状态，即其所拥有的数据<br> Getter &nbsp;相当于Store的计算属性。因为就像计算属性一样，Getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。下面会说到具体的使用场景 Mutation &nbsp;定义了对State中数据的修改操作。组件使用State中的数据的时候并不能直接对数据进行修改操作，需要调用Mutation定义的操作来实现对数据的修改。这也是Vuex定义中所说的用相应的规则来让数据发生变化的具体实现 Action &nbsp;Mutation中定义的操作只能执行同步操作，Vuex中的异步操作在Action中进行，Action最终通过调用Mutation的操作来更新数据 </strong></p> 
<p><strong>在vuex中用过dispatch()，commit()，mapstate，mapgetters，mapmutation，mapaction。</strong></p> 
<p><strong>在项目中的使用：<br> 首先通过npm install vuex --save&nbsp; &nbsp;安装vuex<br> 在项目的源代码文件夹下（如src文件夹）新建一个store文件夹(叫别的名字也行)<br> store文件夹下新建一个store.js文件，用来存放Vuex实例。可以把store注入到在vue实例中，那么所有的组件都可以通过this.$store.state去调用。 </strong></p> 
<p><strong>流程：vue Components使用dispatch()方法触发action里面的函数，通过在Action里面写公共的异步调用获取数据，供公共的组件渲染。Action使用commit()方法触发mutations里面的函数，Mutations去修改state，state重新render vue Components。 </strong></p> 
<p><strong>vuex的使用便于大型项目管理，Store包含多个Module，Module包含State、Mutation和Action。 </strong></p> 
<p><strong>mutation和action写在methods中</strong></p> 
<p><strong>getters和state写在computed中</strong></p> 
<p><strong><span style="color:#f33b45;">说说Vue.nextTick钩子的应用场景</span></strong></p> 
<p><strong>场景一：在created()钩子函数执行的时候，DOM并未进行任何渲染，这时操作DOM时会报错，这时，在created中使用Vue.nextTick（callback）进行操作即可解决。实际上直接将操作放在mounted钩子中是不会发生这种情况的，因为mounted函数执行时代表DOM已经渲染完毕</strong></p> 
<p><strong>场景二：当DOM渲染完成后，执行某些操作改变其结构时，需要把异步结果放在Vue.nextTick（callback）中</strong></p> 
<p><strong>其实可以理解为，Vue的数据驱动页面更新并不是数据改变后DOM立即做出响应，Vue 在更新 DOM 时是异步执行的，通过数据更新队列，监听数据变化，从而更新视图。而Vue.nextTick（callback）就是每次DOM渲染后触发的钩子</strong></p> 
<p><span style="color:#f33b45;"><strong>Vue3.0使用Proxy代替Vue2.0中Obeject.defineProperty的原因</strong></span></p> 
<p><strong>Obeject.defineProperty虽然已经能够实现双向绑定了，但是他还是有缺陷的。只能对属性进行数据劫持，所以需要深度遍历整个对象，对于数组不能监听到数据的变化，虽然Vue中确实能检测到数组数据的变化，但是其实是使用了hack的办法，并 且也是有缺陷的。</strong></p> 
<p><strong>反观Proxy就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以在Vue3.0中使用Proxy替换 Obeject.defineProperty</strong></p> 
<p><span style="color:#f33b45;"><strong>简述路由原理</strong></span></p> 
<p><strong>前端路由就是监听 URL 的变化，然后匹配路由规则， 显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式<br> hash 模式和history 模式</strong></p> 
<p><strong>像www.example.com/#/index就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务 器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。<br> 而www.example.com/index就是History 模式，它是HTML5新推出的功能，比之HashURL更加美观。</strong></p> 
<p><span style="color:#f33b45;"><strong>谈谈Virtual Dom（虚拟DOM）的意义及原理</strong></span></p> 
<p><strong>意义：直接通过JS操作DOM对象会对性能损耗很大，此时，我们可以通过JS对象模拟DOM对象，优化性能</strong></p> 
<p><strong>原理：</strong></p> 
<p><strong>Virtual Dom：如果需要对比两个完整的DOM多叉树，时间复杂度就是O（n^3）。React的核心就是通过diff算法调和，优化Virtual Dom，其团队优化了普通的DOM多叉树比较，将时间复杂度降低至O（n），其核心就是对比同层的节点，而不是跨层对比，Vue2.0中也引入了Virtual Dom算法，它是基于snabbdom算法修改的</strong></p> 
<p><strong>Virtual Dom中的Diff算法过程：</strong></p> 
<p><strong>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个 节点添加索引，便于最后渲染差异，</strong><strong>一旦节点有子元素，就去判断子元素是否有不同</strong></p> 
<p><strong>Virtual Dom算法的实现步骤</strong></p> 
<ul><li><strong>通过JS来模拟创建DOM对象</strong></li><li><strong>判断两个对象的差异</strong></li><li><strong><strong>渲染差异</strong></strong></li></ul>
                ]]></description></item><item><title>NodeJs（前端面试题整合）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/28/14290014.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sat, 28 Nov 2020 08:48:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/28/14290014.html</guid><description><![CDATA[
                    <p><strong><span style="color:#f33b45;">谈谈对Node的理解</span></strong></p> 
<p><strong>Node.js 在浏览器外运行V8 JavaScript引擎，单线程 非阻塞I/O 事件驱动,适应于数据高并发,适合多请求,但不适合高运算,有权限读取操作系统级别的API，</strong><strong>无法直接渲染静态页面，提供静态服务，没有根目录的概念，必须通过路由程序指定文件才能渲染文件，比其他服务端性能更好，速度更快，npm 仓库，常用框架：Express，koa，Socket.io，AdonisJs，NestJS</strong></p> 
<p><span style="color:#f33b45;"><strong>什么是gulp？作用？机制是什么？常用命令有哪些？</strong></span></p> 
<p><strong>gulp是基于node的自动化构建工具</strong></p> 
<p><strong>作用：</strong></p> 
<p><strong>1 自动压缩JS文件</strong></p> 
<p><strong>2 自动压缩CSS文件</strong></p> 
<p><strong>3 自动合并文件</strong></p> 
<p><strong>4 自动编译sass</strong></p> 
<p><strong>5 自动压缩图片</strong></p> 
<p><strong>6 自动刷新浏览器</strong></p> 
<p><strong>机制： </strong></p> 
<p><strong>Unix操作系统的管道（pipe）思想 前一级输出 后一级输入</strong></p> 
<p><strong>常用命令：</strong></p> 
<p><strong>.src &nbsp;输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。<br> .watch &nbsp;监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。<br> .dest &nbsp; 能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。<br> .pipe &nbsp;传入方法的是一个function，这个function作用无非是接受上一个流（stream）的结果，并返回一个处理后流的结果(返回值应该是一个stream对象)。<br> .task &nbsp;定义一个使用 Orchestrator 实现的任务（task）</strong></p> 
<p><strong><span style="color:#f33b45;">如何判断当前脚本运行在浏览器还是node环境中？</span></strong></p> 
<p style="margin-left:0cm;"><strong>this === window ? 'browser' : 'node'，通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</strong></p> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>node.js有哪些常用模块？</strong></span></p> 
<p style="margin-left:0cm;"><strong>util是node 里面一个工具模块，node里面几乎所有的模块都会用到这个模块<br> 功能：</strong><br><strong>1：实现继承这是主要功能</strong><br><strong>2：实现对象的完整输出</strong><br><strong>3：实现判断数据类型</strong></p> 
<p style="margin-left:0cm;"><strong>path模块<br> 功能：格式规范化路径</strong></p> 
<p style="margin-left:0cm;"><strong>fs模块<br> 功能：<br> 1：操作文件<br> 2：操作目录</strong></p> 
<p style="margin-left:0cm;"><strong>http模块：用于搭建HTTP服务端和客户端</strong></p> 
<p style="margin-left:0cm;"><strong>url模块：用户解析和处理URL字符串<br> url.parse(将url字符串解析并返回一个url的对象)<br> url.format(将url对象编程一个url字符串并返回)<br> url.resolve(将url中的参数用/进行拼接)</strong></p> 
<p style="margin-left:0cm;"><strong>zlib模块：提供了用Gzip和Deflate/Inflate实现的压缩功能</strong></p> 
<p style="margin-left:0cm;"><strong>socket.io: 实现客服端与服务端之间的实时通信方式</strong></p> 
<p style="margin-left:0cm;"><strong>uglify-js: 用来压缩合并js文件</strong></p> 
<p style="margin-left:0cm;"><strong>child_process：新建子进程。</strong></p> 
<p style="margin-left:0cm;"><strong>querystring：解析URL中的查询字符串。</strong></p> 
<p style="margin-left:0cm;"><strong>crypto：提供加密和解密功能。</strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#f33b45;">Express框架的核心特性是什么</span></strong></p> 
<p style="margin-left:0cm;"><strong>1.可以设置中间件来响应http请求<br> 2.定义了路由表用于执行不同的HTTP请求动作<br> 3.可以通过向模板传递参数来动态渲染html页面</strong></p> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>对Node的思想一切皆异步的理解</strong></span></p> 
<p style="margin-left:0cm;"><strong>node本身就是非阻塞I/O，与其他后端编程思想不同，虽然php, python, java中也有异步方法，但是编程人员的思想是同步的，node的思想目的是可以让开发者轻松编写高性能的web服务端，而不会通过同步思想api阻塞了服务器从而影响性能。而且node.js大部分api都是异步的，只有小量同步api，这与其他大部分语言刚好相反。</strong></p> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>node如何实现异步非阻塞（I/O）</strong></span></p> 
<p style="margin-left:0cm;"><strong>在node中，I/O（输入输出）是异步非堵塞的关键，I/O操作通常比较耗时但不会独占CPU，典型的I/O比如文件读写，远程数据库读写，网络请求等，如果用同步API来进行I/O操作，在返回结果之前就只能等待，此时阻塞代码会霸占cpu，导致本进程所有代码都等待，而node.js里面的I/O API都是不会霸占CPU的（原因：node中的核心库libuv会将建立的所有I/O操作内容绑定到单个线程上。只要每个事件循环在不同的线程中，就可以运行多个事件循环，libuv为Node.js提供了跨平台、线程池、事件池、异步I/O等能力），所以是非阻塞的。拿JS中的setTimeout来打比方，当用户使用setTimeout时，JS会开辟出一个异步线程池，与主线程分开执行，结果就是之前的代码继续执行，setTimeout的代码延时执行，等成功后再调用主线程的方法</strong></p> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>node中的exports如何实现的，它和module.exports有什么关系</strong></span></p> 
<p style="margin-left:0cm;"><strong>exports实现：exports = module.exports = {};就好像是var a = {&nbsp; } var b = a，看上去没有太大区别，但使用起来却又不同</strong></p> 
<p style="margin-left:0cm;"><strong>module是一个对象，当我们在控制台输入node并执行，在node中执行module或者执行js文件打印module时会发现以下log</strong></p> 
<pre><code class="language-javascript">Module {
  id: '&lt;repl&gt;',
  path: '.',
  exports: {},
  parent: undefined,
  filename: null,
  loaded: false,
  children: [],
  paths: [
    ...
  ]
}</code></pre> 
<p><strong>不难发现，module是Module的实例，exports是其中一个属性，也就是说当你在node中执行一个js文件或者使用require引入模块时，nodejs都会新建一个var&nbsp;module = new Module（），并执行exports = module.exports，这也就是为什么直接打印exports和exports时，控制台不会报错，如果在node中执行以下代码，就能清楚的看出这二者的引用关系了</strong></p> 
<pre><code class="language-javascript">console.log(module.exports) // {}
console.log(exports) // {}
module.exports.name = '张三'
exports.age = 22
console.log(module.exports) // { name: '张三', age: 22 }
console.log(exports) // { name: '张三', age: 22 }</code></pre> 
<p><span style="color:#f33b45;"><strong>谈谈Node.js加载模块机制</strong></span></p> 
<p><strong>node.js中模块有两种类型：核心模块和文件模块</strong></p> 
<p><strong>核心模块直接使用名称获取，文件模块只能按照路径加载（可以省略默认的.js拓展名，不是js文件的话需要显示声明书写）</strong></p> 
<p><strong>模块加载规则：</strong></p> 
<ul><li><strong>核心模块优先级最高，直接使用名字加载，在有命名冲突的时候首先加载核心模块</strong></li><li><strong>可通过绝对路径和相对路径查找</strong></li><li><strong>查找node_modules目录，我们知道在调用 npm install &lt;name&gt; 命令的时候会在当前目录下创建node_module目录(如果不存在) 安装模块，当 require 遇到一个既不是核心模块,又不是以路径形式表示的模块名称时,会试图 在当前目录下的 node_modules 目录中来查找是不是有这样一个模块。如果没有找到,则会 在当前目录的上一层中的 node_modules 目录中继续查找,反复执行这一过程,直到遇到根 目录为止</strong></li></ul>
<p><span style="color:#f33b45;"><strong>对Node的优点和缺点提出了自己的看法</strong></span></p> 
<p><strong>优点：因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</strong></p> 
<p><strong>缺点：Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。看起来，就像是Ruby/Rails当年的样子。</strong></p> 
<p><span style="color:#f33b45;"><strong>Node.js的适用场景</strong></span></p> 
<ul><li><strong>实时应用：如在线聊天，实时通知推送等等（如socket.io）</strong></li><li><strong>分布式应用：通过高效的并行I/O使用已有的数据</strong></li><li><strong>工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面图形界面应用程序</strong></li><li><strong>游戏类应用：游戏领域对实时和并发有很高的要求（如网易的pomelo框架）</strong></li><li><strong>利用稳定接口提升Web渲染能力</strong></li><li><strong>前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯Javascript全栈式MEAN架构）</strong></li></ul>
<p><strong><span style="color:#f33b45;">原生Node如何解决跨域</span></strong></p> 
<pre><code class="language-javascript">const http = require('http');

http.createServer((req, res) =&gt; {
 res.setHeader('Access-Control-Allow-Origin', '*');
 res.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
 res.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
}).listen(8080);</code></pre> 
<p><span style="color:#f33b45;"><strong>反向代理是什么，如何实现</strong></span></p> 
<p><strong>反向代理是指代理服务器来接受客户端的网络访问连接请求，然后服务器将请求有策略的转发给网络中实际工作的业务服务器，并将从业务服务器处理的结果，返回给网络上发起连接请求的客户端</strong></p> 
<p><strong>实现过程（这里的目标服务器是用getman产生的假数据）：</strong></p> 
<pre><code class="language-html">前端部分：
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        $.post('http://127.0.0.1:1024', {// 访问代理服务端，获取目标服务器的数据
            token: '1234'
        }, function (res) {
            console.log(JSON.parse(res))
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<pre><code class="language-javascript">//服务端
const http = require('http');
const https = require('https')
const reqOption = { // getman产生的虚拟数据的请求地址
    protocol: 'https:',
    host: 'getman.cn',
    path: '/mock/shopList',
    method: 'POST',
    headers: {
        "content-type": "application/json",
    }
}
let server = http.createServer((req, res) =&gt; {
    // 写请求头，解决跨域
    res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); // 若允许所有域名和ip，则设置成*
    res.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
    res.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
    let _data = ''
    req.on('data', data =&gt; _data += data)
    req.on('end', () =&gt; {
        proxyApi(_data).then((_res) =&gt; { // 服务端收到前端请求后，请求目标服务器，将结果返回至前端
            res.write(_res)
            res.end()
        })
    })
})

function proxyApi(_data) {
    return new Promise((resolve, reject) =&gt; {
        let req = https.request(reqOption, (res) =&gt; {
            let data = '';
            res.on('data', (chunk) =&gt; {
                data += chunk;
            });
            res.on('end', () =&gt; {
                resolve(data)
            });
        })
        req.write(_data)
        req.end();
    })
}
server.listen(1024, () =&gt; console.log("1024服务开启，开始侦听"));</code></pre> 
<p><strong><span style="color:#f33b45;">Node事件循环的流程是什么，在事件循环中，如何判断是否有事件需要处理呢</span></strong></p> 
<p><strong>事件循环的流程：在进程启动时，node会生成一个循环（类似于while（true）），每执行一次循环被称为一次Tick，每次的循环体Tick的过程会对事件进行判断，若发现存在事件，则执行相关操作，并进入下一个Tick，如果不再有事件，则退出进程</strong></p> 
<p><strong>判断Tick是否有事件：node中的Tick通过观察者判断是否有需要处理的事件，主要来源于网络请求的网络I/O观察者，和文件操作的文件I/O观察者，事件循环从观察者中取出事件并处理</strong></p> 
<p><span style="color:#f33b45;"><strong>webSocket相对http的优势</strong></span></p> 
<ul><li><strong>客户端与服务器只需要一个TCP连接，比http长轮询使用更少的连接</strong></li><li><strong>webSocket服务端可以推送数据到客户端</strong></li><li><strong>更轻量的协议头，减少数据传输量</strong></li></ul>
<p><span style="color:#f33b45;"><strong>简述明文、密文、密码、密钥、对称加密、非对称加密、摘要、数字签名、数字证书的概念</strong></span></p> 
<ul><li><strong>明文（plaintext）是加密之前的原始数据</strong></li><li><strong>密文是通过密码（cipher）运算后得到的结果成为密文（ciphertext）</strong></li><li><strong>密码学中的密码（cipher）和我们日常生活中所说的密码不太一样，计算机术语 ' 密码 cipher ' 是一种用于加密或者解密的算法，而我们日常所使用的 密码 (password)是一种口令，它是用于认证用途的一组文本字符串，这里我们要讨论的是前者：cipher。</strong></li><li><strong>密钥(key)是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</strong></li><li><strong>对称密钥（Symmetric-key algorithm）又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</strong></li><li><strong>非对称密钥（public-key cryptography）也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</strong></li><li><strong>摘要算法又称哈希/散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。算法不可逆。</strong></li><li><strong>数据在浏览器和服务器之间传输时，有可能在传输过程中被冒充的盗贼把内容替换了，那么如何保证数据是真实服务器发送的而不被调包呢，同时如何保证传输的数据没有被人篡改呢，要解决这两个问题就必须用到数字签名，数字签名就如同日常生活的中的签名一样，一旦在合同书上落下了你的大名，从法律意义上就确定是你本人签的字儿，这是任何人都没法仿造的，因为这是你专有的手迹，任何人是造不出来的。那么在计算机中的数字签名怎么回事呢？数字签名就是用于验证传输的内容是不是真实服务器发送的数据，发送的数据有没有被篡改过，它就干这两件事，是非对称加密的一种应用场景。不过他是反过来用私钥来加密，通过与之配对的公钥来解密。</strong></li><li><strong>数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。因此数字证书又称为数字标识。数字证书对网络用户在计算机网络交流中的信息和数据等以加密或解密的形式保证了信息和数据的完整性和安全性。</strong></li></ul>
<p><strong><span style="color:#f33b45;">什么是中间件，好处是什么</span></strong></p> 
<p><strong>中间件是一类连接软件组件和应用的计算机软件，它包括一组服务。以便于运行在一台或多台机器上的多个软件通过网络进行交互。使用node作为中间件更好提升了性能。</strong></p> 
<p><strong>好处：</strong></p> 
<ul><li><strong>代理，处理前端产生的访问接口跨域，通过node反向代理，访问目标服务器</strong></li><li><strong>缓存，用户触发数据更新时，使用node作为暂时缓存，节省后端资源</strong></li><li><strong>限流，针对接口和路由做出响应路由</strong></li><li><strong>监控，高并发请求特点</strong></li><li><strong>鉴权，对页面路由权限做出判断</strong></li><li><strong>渲染，使用node对前端页面进行预渲染</strong></li><li><strong>等等...</strong></li></ul>
<p><strong><span style="color:#f33b45;">node中的Connect模块是什么，Koa与Express的中间件有什么区别</span></strong></p> 
<p><strong>Connect是一个node中间件（middleware）框架，每个中间件在http处理过程中通过改写request或（和）response的数据、状态，实现了特定的功能</strong></p> 
<p><strong>Koa与Express中间件的</strong><strong>区别：</strong></p> 
<p><strong>Express主要基于Connect中间件框架，中间件一个接一个的顺序执行，通常会将 response 响应写在最后一个中间件中</strong></p> 
<p><strong>而koa主要基于co中间件框架，它的中间件是通过&nbsp;<code>async await</code>&nbsp;实现的，中间件执行顺序是“洋葱圈”模型。执行效果类似于Promise.all</strong></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>ES6+（前端面试题整合）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/23/14290015.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Mon, 23 Nov 2020 01:09:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/23/14290015.html</guid><description><![CDATA[
                    <p><strong><span style="color:#f33b45;">谈一谈let与var和const的区别</span></strong></p> 
<p><strong>let为ES6新添加申明变量的命令，它类似于var，但是有以下不同： &nbsp; </strong></p> 
<ul><li><strong>let命令不存在变量提升，如果在let前使用，会导致报错</strong></li><li><strong>let暂时性死区的本质，其实还是块级作用域必须“先声明后使用”的性质，let 暂时性死区的原因：var 会变量提升，let 不会。</strong></li><li><strong>let，const和class声明的全局变量不是全局对象的属性</strong></li><li><strong>const可以在多个模块间共享 </strong></li><li><strong>const声明的变量与let声明的变量类似，它们的不同之处在于，const声明的变量只可以在声明时赋值，不可随意修改，否则会导致SyntaxError（语法错误）</strong></li><li><strong>const只是保证变量名指向的地址不变，并不保证该地址的数据不变</strong></li></ul>
<p><span style="color:#f33b45;"><strong>说说箭头函数的特点</strong></span></p> 
<ul><li><strong>箭头函数不属于普通的 function，所以没有独立的上下文。</strong></li><li><strong>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</strong></li><li><strong>由于箭头函数没有自己的this，函数对象中的call、apply、bind三个方法，无法"覆盖"箭头函数中的this值。</strong></li><li><strong>箭头函数没有原本(传统)的函数有的隐藏arguments对象。</strong></li><li><strong>箭头函数不能当作generators使用，使用yield会产生错误。</strong></li></ul>
<p><strong>在以下场景中不要使用箭头函数去定义：</strong></p> 
<p><strong>1. 定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。</strong></p> 
<p><strong>2. 箭头函数里不但没有 this，也没有 arguments, super</strong></p> 
<p><strong><span style="color:#f33b45;">对Symbol，Map和Set的理解</span></strong></p> 
<p><strong>Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，即使使用同样的参数实例化symbol，得到的symbol实例也不会相等</strong></p> 
<pre><code class="language-javascript">let _symbol1 = Symbol('test');
let _symbol2 = Symbol('test');
console.log(_symbol1 == _symbol2);//false
</code></pre> 
<p><strong>Map对象保存键值对，有点类似于Object，但是Object的键只能是字符串或者Symbols，而Map可以是任何值</strong></p> 
<pre><code class="language-javascript">        let myMap = new Map()
        let str1 = 'dog'
        let str2 = 'cat'
        myMap.set(str1, '汪')
        myMap.set(str2, '喵')
        console.log(myMap) // {0: {"dog" =&gt; "汪"}1: {"cat" =&gt; "喵"}}
        console.log(myMap.get(str1)) // 汪</code></pre> 
<p><strong>Set 对象允许你存储任何类型的唯一值（数组去重），有点类似于Array，Set中的元素只会出现一次</strong></p> 
<pre><code class="language-javascript">        let mySet = new Set()
        mySet.add('hello')
        mySet.add('1')
        mySet.add('2')
        mySet.add('2')
        console.log(mySet) // {0: "hello",1: "1",2: "2"}</code></pre> 
<p><strong><span style="color:#f33b45;">使用ES6如何监测数组变化（proxy监测读写）</span></strong></p> 
<pre><code class="language-javascript">        let list = [1, 2, 3]
        // 代理
        let _proxy = new Proxy(list, {
            set: function (target, prop, val, rec) {
                console.log('写入')
                target[prop] = val
                return true
            },
            get: function (target, prop) {
                console.log('读取')
                return target[prop]
            }
        })
        _proxy[0] = 4 // 写入
        console.log(_proxy[1]) // 读取</code></pre> 
<p><span style="color:#f33b45;"><strong>JS有哪些处理异步的方法</strong></span></p> 
<p><strong>回调函数：回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行</strong></p> 
<p><strong>优点：简单，方便，实用，易懂<br> 缺点：当逻辑复杂时，会产生回调函数地狱，耦合度高，流程会很混乱</strong></p> 
<pre><code class="language-javascript">        // 回调
        let cb = (props) =&gt; {
            console.log(props) // 2
        }
        let init = (props) =&gt; {
            // 异步操作
            setTimeout(() =&gt; {
                cb(props) // 异步传参
            }, 1000)
        }
        init(2)
        console.log(1) // 1</code></pre> 
<p><strong>事件发布/订阅：采用事件驱动模式，任务的执行取决于某一个事件是否发生</strong></p> 
<p><strong>优点：事件监听方式相对回调实现了代码的解耦，对模块化开发很友好<br> 缺点：每次执行任务都需要发布/订阅事件</strong></p> 
<pre><code class="language-javascript">        // 事件发布/订阅
        let cb = (event) =&gt; {
            console.log(event.props) // 2
        }
        let init = (props) =&gt; {
            // 异步操作
            setTimeout(() =&gt; {
                let event = new Event('myEvent')
                event.props = props // 异步传参
                document.dispatchEvent(event)
            }, 1000)
        }
        init(2)
        console.log(1) // 1
        document.addEventListener('myEvent', cb)</code></pre> 
<p><strong>Promise：Promise是异步编程，它将异步操作以同步的方式表现出来，避免回调地狱的产生</strong></p> 
<p><strong>优点：避免回调地狱，链式调用，函数思路清晰，逻辑相对前两者更强<br> 缺点：理解性差，异步操作在promise构造函数内部</strong></p> 
<pre><code class="language-javascript">        // ES6  Promise
        let init = (props) =&gt; {
            return new Promise((resolve, reject) =&gt; {
                // 异步操作
                setTimeout(() =&gt; {
                    resolve(props)
                }, 1000)
            })
        }
        init(2).then((res) =&gt; {
            console.log(res) // 2
        })
        console.log(1) // 1</code></pre> 
<p><strong>Generator：generator（生成器）是ES6标准引入Python的新的数据类型</strong></p> 
<p><strong>优点：取消链式调用的then，和发布/订阅模式非常相似，对于理解同步操作很直观<br> 缺点：多个异步函数时不够直观，原函数需要通过next去维护外部函数的yield</strong></p> 
<pre><code class="language-javascript">        // ES6  Generator
        const fn = init(2)
        let cb = (props) =&gt; {
            console.log(props) // 2
        }
        function* init(props) {
            // 异步操作
            yield setTimeout(() =&gt; {
                fn.next()
            }, 500)
            yield setTimeout(() =&gt; {
                fn.next()
            }, 500)
            cb(props)
        }
        fn.next()
        console.log(1) // 1</code></pre> 
<p><strong>async/await：<code>async函数是generator函数的语法糖，函数（function关键字）前添加async关键字，函数中通过await等待异步执行</code></strong></p> 
<p><strong>优点：同步流程清晰，简洁，异步操作可以返回promise对象，后续操作更方便<br> 缺点：JS的执行器功能较其他co模块较弱</strong></p> 
<pre><code class="language-javascript">        // ES6+  async/await
        let cb = (props) =&gt; {
            console.log(props) // 2
        }
        let cb2 = (props) =&gt; {
            return new Promise((resolve, reject) =&gt; {
                setTimeout(() =&gt; {
                    resolve(props)
                }, 1000)
            })
        }
        async function init(props) {
            // 异步操作
            let num2 = await cb2(props)
            cb(num2)
        }
        init(2)
        console.log(1) // 1</code></pre> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>ES6中的class关键字跟function什么区别</strong></span></p> 
<ul><li style="margin-left:0cm;"><strong>在function定义的构造函数中，其prototype.constructor属性指向构造器自身，在class定义的类中，constructor其实也相当于定义在prototype属性上</strong></li><li style="margin-left:0cm;"><strong>function如果重复定义，会覆盖之前定义的方法，而class重复定义则会报错</strong></li><li style="margin-left:0cm;"><strong>class中定义的方法不可用Object.keys(Point.prototype)枚举到，function构造器原型方法可被Object.keys(Point.prototype)枚举到</strong></li><li style="margin-left:0cm;"><strong>class没有变量提升，也就是说，必须先定义class，再使用，而function定义后，会被提升至当前作用域顶端</strong></li><li style="margin-left:0cm;"><strong>class定义的类没有私有方法和私有属性，function可以通过闭包实现私有方法和属性</strong></li></ul>
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>ES6新增哪些数组方法</strong></span></p> 
<p style="margin-left:0cm;"><strong>find()：返回数组中第一个满足条件的元素（如果有的话）， 如果没有，则返回 undefined<br> findIndex()：返回数组中第一个满足条件的元素的索引（如果有的话）， 如果没有，则返回 -1<br> keys()：返回一个数组索引的迭代器<br> values()：返回一个数组迭代器对象，该对象包含数组中每个索引的值<br> entries()：返回一个数组迭代器对象，该对象包含数组中每个索引的键值对</strong></p> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>for in </strong><strong>和 for of 的</strong><strong>区别</strong></span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">for in&nbsp;</span>适合用于遍历对象，for of可以用来遍历数组，类数组对象，argument，字符串，Map和Set</strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">for in 遍历数组时会有以下问题：</span></strong></p> 
<ul><li style="margin-left:0cm;"><strong><span style="color:#333333;">index索引为字符串型数字，不能直接进行几何运算</span></strong></li><li style="margin-left:0cm;"><strong><span style="color:#333333;">遍历顺序有可能不是按照实际数组的内部顺序</span></strong></li><li style="margin-left:0cm;"><strong><span style="color:#333333;">使用for in会遍历数组所有的可枚举属性，包括原型，原型上的方法和属性</span></strong></li></ul>
<p style="margin-left:0cm;"><strong>所以for in 不适合遍历数组，而适合用于遍历对象</strong></p> 
<p style="margin-left:0cm;"><strong>而for of</strong><strong><span style="color:#333333;">遍历数组时</span></strong><strong>：</strong></p> 
<p style="margin-left:0cm;"><strong>只会遍历<span style="color:#000000;"><span style="color:#333333;">数组内的元素，而不包括数组的原型属性</span><span style="color:#333333;">method</span><span style="color:#333333;">和索引</span><span style="color:#333333;">name</span></span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#f33b45;">CommonJS 中的 require/exports 和 ES6 中的 import/export 区别</span></strong></p> 
<ul><li style="margin-left:0cm;"><strong><span style="color:#212121;">CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</span></strong></li><li style="margin-left:0cm;"><strong><span style="color:#212121;">CommonJS模块是运行时加载，ES6模块是编译时输出接口，ES6</span><span style="color:#212121;">可以在编译时就完成模块加载，效率要比</span><span style="color:#212121;">CommonJS模块的加载方式高</span></strong></li><li style="margin-left:0cm;"><strong><span style="color:#212121;">CommonJS模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。而</span><span style="color:#212121;">Es6</span><span style="color:#212121;">模块的运行机制与</span><span style="color:#212121;">CommonJS</span><span style="color:#212121;">不一样。</span><span style="color:#212121;">JS</span><span style="color:#212121;">引擎对脚本静态分析的时候，遇到模块加载命令</span><span style="color:#212121;">import</span><span style="color:#212121;">，就会生成一个只读引用。等到脚本真正执行时，在根据引用到被加载的那个模块里面去取值。</span><span style="color:#212121;">ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span></strong></li><li style="margin-left:0cm;"><strong><span style="color:#212121;">require/exports</span><span style="color:#212121;">是</span><span style="color:#212121;">CommonJS</span><span style="color:#212121;">在</span><span style="color:#212121;">Node</span><span style="color:#212121;">中实现的，</span><span style="color:#212121;">import/export</span><span style="color:#212121;">是</span><span style="color:#212121;">ES6</span><span style="color:#212121;">的模块</span></strong></li><li style="margin-left:0cm;"><strong><span style="color:#212121;">require/exports</span>是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而<span style="color:#212121;">ES6模块</span>是异步导入，因为用于浏览器，需要下载文件，如果也采用导入会对渲染有很大影响</strong></li><li style="margin-left:0cm;"><strong><span style="color:#000000;"><span style="color:#212121;">ES6模块的设计思想，是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，ES6模块</span></span>会编译成 require/exports 来执行的</strong></li><li style="margin-left:0cm;"><strong><span style="color:#212121;">export</span><span style="color:#212121;">命令用于规定模块的对外接口，</span><span style="color:#212121;">import</span><span style="color:#212121;">命令用于输入其他模块提供的功能</span></strong></li></ul>
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>尝试实现Promise</strong></span></p> 
<p><strong><a href="https://blog.csdn.net/time_____/article/details/109721703">https://blog.csdn.net/time_____/article/details/109721703</a></strong></p> 
<p><span style="color:#f33b45;"><strong>Object.is()与“==”，“===”的区别</strong></span></p> 
<p><strong>“==”会在比较时进行类型转换</strong></p> 
<p><strong>“===”比较时不进行隐式类型转换</strong></p> 
<p><strong>Object.is()在三等号判等的基础上特别处理了NaN、-0和+0，保证-0和+0不再相同，但Object.is(NaN,NaN)会返回true</strong></p> 
<p><span style="color:#f33b45;"><strong>ES6中为何出现Class</strong></span></p> 
<p><span style="color:#f33b45;"><strong>Class的功能实际上在ES5都能实现，可以算是ES6的语法糖，其作用是使JS语法清晰，更像面向对象语法</strong></span></p> 
<p><strong>基础写法</strong></p> 
<pre><code class="language-javascript">        class MyEvent extends EventTarget { // 继承EventTarget
            constructor(e) {
                super(e) // 父类的构造函数
                this.consoleThis() // 执行函数
            }
            consoleThis() {
                console.log(this)
            }
        }
        let myEvent = new MyEvent(document) // EventTarget&nbsp;</code></pre> 
<p><span style="color:#f33b45;"><strong>ES6语法糖的对象的属性简写和属性名表达式是什么</strong></span></p> 
<p><strong>属性简写：对象的字面量可以直接写入与之名称相同的变量和函数</strong></p> 
<pre><code class="language-javascript">        let name = '小明'
        function showName() {
            console.log(this.name)
        }
        let person = {
            name,
            showName
        }
        console.log(person.name)// 小明
        person.showName()// 小明</code></pre> 
<p><strong>属性名表达式简写：ES6允许把表达式放在方括号内，作为对象的属性名</strong></p> 
<pre><code class="language-javascript">        let num = 0
        let obj = {
            "1": 'a',
            "2": 'b',
            "3": 'c'
        }
        console.log(obj[++num]) // a
        console.log(obj[++num]) // b
        console.log(obj[++num]) // c</code></pre> 
<p><strong><span style="color:#f33b45;">谈谈解构赋值的理解</span></strong></p> 
<p><strong>解构赋值是对赋值运算符的扩展，是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值</strong></p> 
<pre><code class="language-javascript">        // 数组
        let [a, b, c] = [1, 2, 3];
        console.log(a, b, c) // 1,2,3
        // 对象
        let {
            d,
            e,
            f
        } = {
            d: 4,
            e: 5
        };
        console.log(d, e, f) // 4,5,undefined</code></pre> 
<p><span style="color:#f33b45;"><strong>使用ES6如何合并多个对象，复制对象</strong></span></p> 
<p><strong>ES6中的对象新增（...）拓展运算符，用于取出参数对象所有可遍历属性然后拷贝到当前对象</strong></p> 
<p><strong>ES6新增对象拷贝方法：Object.assign(target, source1，source2，source3， ···)，将源对象的所有可枚举属性复制到目标对象中，即，将source1，source2，source3......复制到target中</strong></p> 
<p><strong>合并：</strong></p> 
<pre><code class="language-javascript">        let name = {
            name: '小明'
        }
        let age = {
            age: 20
        }
        let hobby = {
            hobby: 'music'
        }
        let person = {// 拓展运算符
            ...name,
            ...age,
            ...hobby
        }
        console.log(person)// age: 20,hobby: "music",name: "小明"

        Object.assign(person, name, age, hobby)// 对象拷贝
        console.log(person) // age: 20,hobby: "music",name: "小明"</code></pre> 
<p><strong>复制：</strong></p> 
<pre><code class="language-javascript">        let list = [1, 2, 3, 4, 5]
        let list2 = [...list]// 拓展运算符
        Object.assign(list2, list)// 对象拷贝
        let index = 0
        do {
            list[index] += 10
        } while (index++ &lt; list.length - 1)
        console.log(list, list2) // [11, 12, 13, 14, 15]  [1, 2, 3, 4, 5]</code></pre> 
<p><span style="color:#f33b45;"><strong>如何控制类中属性的读写性</strong></span></p> 
<p><strong>setter...getter...</strong></p> 
<div> 
 <pre><code class="language-javascript">        class Animal {
            constructor() {
                this._dog = '小黑'
                this._cat = '小黄'
            }
            set cat(val) { // 只写
                this._cat = val
            }
            get dog() { // 只读
                return this._dog
            }
        }
        let animal = new Animal()
        animal.dog = '小白'
        animal.cat = '小灰'
        console.log(animal.dog, animal.cat) // 小黑 undefined
        console.log(animal._dog, animal._cat) // 小黑 小灰</code></pre> 
 <p><strong>Object.defineProperty（）修改对象只读</strong></p> 
 <pre><code class="language-javascript">        class Animal {
            constructor() {
                this.dog = '小白'
            }
        }
        let animal = new Animal()
        Object.defineProperty(animal, 'dog', {
            writable: false, // 可写，false为只读
        });
        animal.dog = '小黑'
        console.log(animal.dog) // 小白</code></pre> 
 <p>&nbsp;</p> 
</div>
                ]]></description></item><item><title>JS案例：实现Promise</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/17/14290016.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Tue, 17 Nov 2020 09:02:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/17/14290016.html</guid><description><![CDATA[
                    <p><strong>说到ES6的Promise，大家并不陌生，它是JS中解决异步的方法之一<br> 其优点：避免回调地狱，链式调用，函数思路清晰，逻辑相对回调函数和事件发布/订阅更强<br> 缺点：理解性差，异步操作在promise构造函数内部</strong></p> 
<p><strong>这段时间在整理面试题时发现，Promise的实现可以单独拿出来分享，于是自己简单实现了一下<br> 码云地址：<a href="https://gitee.com/DieHunter/myCode/tree/master/Promise%E5%B0%81%E8%A3%85">https://gitee.com/DieHunter/myCode/tree/master/Promise%E5%B0%81%E8%A3%85</a></strong></p> 
<p><strong>实现完整功能之前，我们先了解一下Promise的用法，并实现一个简单的Promise和Promise.then函数</strong></p> 
<pre><code class="language-javascript">Promise(executor: (resolve: (value?: any) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; void): Promise&lt;any&gt;</code></pre> 
<p><strong>上述配置提示中显示，Promise需要传入一个回调函数，函数有两个参数（resolve, reject），第一个是异步执行成功后回调，另一个是失败时的回调。Promise.then方法是执行异步函数成功，即resolve执行时，才会执行then方法中的回调，以下是Promise最简单的一个用法</strong></p> 
<pre><code class="language-javascript">        new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve('success')// 传参
            }, 500)
        }).then(function (res) {
            console.log(res) // success
        })</code></pre> 
<p><strong>下面，我们实现一个最简单的Promise，用于解析Promise.then的原理，主要原理就是用两个回调函数嵌套，将函数作为参数放入至异步操作中，当异步操作执行后再执行作为参数的回调</strong></p> 
<pre><code class="language-javascript">        function MyPromise(fn) { // 主要原理就是用两个回调函数嵌套，将函数作为参数放入至异步操作中，当异步操作执行后再执行作为参数的回调
            var _this = this;
            _this.params = null; // 传递的参数
            _this.tempResolve = null // _this.tempResolve的作用是将参数传递至then方法中
            function resolve(params) { // 异步操作之后才会执行该方法，执行前一直等待
                _this.params = params
                _this.tempResolve(_this.params)
            }
            fn(resolve) // 将resolve通过回调返回到异步操作函数中,当resolve执行时，才是异步操作执行后
        }

        MyPromise.prototype.then = function (_resolve) { // 异步操作传递参数，简言之就是连接then和resolve
            var _this = this
            _this.tempResolve = function () {
                _resolve(_this.params)
            }
        }
        MyPromise.prototype.constructor = MyPromise

        new MyPromise(function (res, rej) {
                setTimeout(function () {
                    res('success')
                }, 1000)
            })
            .then(function (res) {
                console.log(res) // success
            })</code></pre> 
<p><strong>如果理解了上面的代码，就已经成功了一半，接下来，我们对Promise进行深入的实现，与上述代码差别是，添加then的链式调用，其实可以理解为多层Promise嵌套，但是我们需要对每层Promise做出操作，所以，我们在每层promise中添加status用于记录当前promise是否已执行，tempResolve也要改成tempResolveList，因为需要执行的函数不止一个，变成了一个队列，在上面代码的基础上，我们对resolve进行优化</strong></p> 
<pre><code class="language-javascript">            function resolve(params) { // 异步操作之后才会执行该方法，执行前一直等待
                if (_this.status === 'pending') {
                    _this.status = 'resolve'; // 进入函数后，立即修改函数状态，防止下面的循环重复执行函数
                    _this.params = params;
                    for (var i = 0; i &lt; array.length; i++) {
                        _this.tempResolveList[i](_this.params) // 执行所有then的链式调用的函数
                    }
                }
            }</code></pre> 
<p><strong>除此之外，在then函数中，还需要添加一段代码，其目的是将Promise返回到下一层链式调用，将回调函数通过resolve传递至下一层，达到依次同步执行的目的</strong></p> 
<pre><code class="language-javascript">        MyPromise.prototype.then = function (tempResolve) { // 异步操作传递参数，简言之就是连接then和resolve
            var _this = this
            var _promise = new MyPromise(function (resolve, reject) {
                if (_this.status == 'pending') {
                    _this.tempResolveList.push(function () {
                        resolve(tempResolve(_this
                            .params)) // 将上一层tempResolve通过resolve的参数异步传递给下一层的Promise中，每层都会异步叠加
                    })
                }
            })
            return _promise // 返回Promise用于链式调用
        }</code></pre> 
<p><strong>完成之后，我们会发现一个问题，当我们通过resolve传递tempResolve执行结果时，只有一层链式调用的话，返回的是原回调函数，当到了第二层时，返回的是上一层的resolve，此时我们需要在resolve函数之前做个过滤，并且把参数中的then放在本层，直接执行</strong></p> 
<pre><code class="language-javascript">                if (params &amp;&amp; typeof params === 'function' || typeof params ===
                    'object') { // 这里要判断参数是普通参数params，还是MyPromise方法，链式调用一定会产生MyPromise构造函数
                    var _then = params.then // 如果参数是MyPromise构造函数，则将上层的then放到本层继续执行后续操作
                    if (typeof _then === 'function') {
                        _then.call(params, resolve); // 链式调用then
                        return;
                    }
                }</code></pre> 
<p><strong>Promise.then的链式调用完整代码</strong></p> 
<pre><code class="language-javascript">        function MyPromise(fn) { // 主要原理就是用两个回调函数嵌套，将函数作为参数放入至异步操作中，当异步操作执行后再执行作为参数的回调
            var _this = this;
            _this.status = 'pending'; // 每层Promise的待定状态，只有当前Promise处于pending的时候，才会执行异步函数
            _this.params = null; // 传递的参数
            _this.tempResolveList = new Array() // 储存链式调用then中的函数队列
            function resolve(params) { // 异步操作之后才会执行该方法，执行前一直等待
                if (params &amp;&amp; typeof params === 'function' || typeof params ===
                    'object') { // 这里要判断参数是普通参数params，还是MyPromise方法，链式调用一定会产生MyPromise构造函数
                    var _then = params.then // 如果参数是MyPromise构造函数，则将上层的then放到本层继续执行后续操作
                    if (typeof _then === 'function') {
                        _then.call(params, resolve); // 链式调用then
                        return;
                    }
                }
                if (_this.status === 'pending') {
                    _this.status = 'resolve'; // 进入函数后，立即修改函数状态，防止下面的循环重复执行函数
                    _this.params = params;
                    for (var i = 0; i &lt; _this.tempResolveList.length; i++) {
                        _this.tempResolveList[i](_this.params) // 执行所有then的链式调用的函数
                    }
                }
            }
            fn(resolve) // 将resolve通过回调返回到异步操作函数中,当resolve执行时，才是异步操作执行后
        }

        MyPromise.prototype.then = function (tempResolve) { // 异步操作传递参数，简言之就是连接then和resolve
            var _this = this
            var _promise = new MyPromise(function (resolve, reject) {
                if (_this.status == 'pending') {
                    _this.tempResolveList.push(function () {
                        resolve(tempResolve(_this
                            .params)) // 将上一层tempResolve通过参数异步传递给下一层的Promise中，每层都会异步叠加
                    })
                }
            })
            return _promise // 返回Promise用于链式调用
        }
        MyPromise.prototype.constructor = MyPromise
        var count = 1
        new MyPromise(function (res, rej) {
                setTimeout(function () {
                    res('success' + count++)
                }, 1000)
            })
            .then(function (res) {
                console.log(res) // success1
                return new MyPromise(function (res, rej) {
                    setTimeout(function () {
                        res('success' + count++)
                    }, 1000)
                })
            }).then(function (res) {
                console.log(res) // success2
                return new MyPromise(function (res, rej) {
                    setTimeout(function () {
                        res('success' + count++)
                    }, 1000)
                })
            }).then(function (res) {
                console.log(res) // success3
            })</code></pre> 
<p><strong>实现了链式调用后，我们对reject以及catch进行一个简单的实现，其实现过程与then相似，我们对一些方法封装一下，得到以下代码（catch没有完善链式调用，导致then方法执行数量大于1时失效）</strong></p> 
<pre><code class="language-javascript">        function MyPromise(fn) { // 主要原理就是用两个回调函数嵌套，将函数作为参数放入至异步操作中，当异步操作执行后再执行作为参数的回调
            var _this = this;
            _this.status = 'pending'; // 每层Promise的待定状态，只有当前Promise处于pending的时候，才会执行异步函数
            _this.params = null; // 传递的参数
            _this.tempResolveList = new Array() // 储存链式调用then中的函数队列
            _this.tempRejectList = new Array() // 储存链式调用catch中的函数队列

            _this.runCommandList = function (_status, _params,
                _commandList) { // 若函数状态是pending待定状态，函数执行后会有两个状态，resolve和reject
                if (_params &amp;&amp; typeof _params === 'function' || typeof _params ===
                    'object') { // 这里要判断参数是普通参数params，还是MyPromise方法，链式调用一定会产生MyPromise构造函数
                    var _then = _params.then // 如果参数是MyPromise构造函数，则将上层的then放到本层继续执行后续操作
                    if (typeof _then === 'function') {
                        _then.call(_params, resolve); // 链式调用then
                        return;
                    }
                }
                if (_this.status === 'pending') {
                    _this.status = _status; // 进入函数后，立即修改函数状态，防止下面的循环重复执行函数
                    _this.params = _params;
                    for (var i = 0; i &lt; _commandList.length; i++) {
                        _commandList[i](_this.params) // 执行所有then的链式调用的函数
                    }
                }
            }
            _this.runCallBack = function (resolve, reject, finishFn) {
                return function () {
                    try {
                        var temp = finishFn(_this.params);
                        resolve(temp);
                    } catch (error) {
                        reject(error);
                    }
                }
            }
            _this.createPromise = function (temp, tempList) {
                var _this = this
                return new MyPromise(function (resolve, reject) {
                    if (_this.status == 'pending') {
                        tempList.push(_this.runCallBack(resolve, reject,
                            temp)) // 将上一层tempResolve通过参数异步传递给下一层的Promise中，每层都会异步叠加
                    }
                })
            }

            function resolve(params) { // 异步操作之后才会执行该方法，执行前一直等待,通过回调返回到new Promise(fn)参数中
                _this.runCommandList('resolve', params, _this.tempResolveList)
            }

            function reject(params) { // 异步操作之后才会执行该方法，执行前一直等待,通过回调返回到new Promise(fn)参数中
                _this.runCommandList('reject', params, _this.tempRejectList)
            }
            try { //捕获异常
                fn(resolve, reject)
            } catch (error) {
                reject(error)
            } // 将resolve通过回调返回到异步操作函数中,当resolve执行时，才是异步操作执行后
        }

        MyPromise.prototype.then = function (tempResolve) { // 异步操作传递参数，简言之就是连接then和resolve
            var _this = this
            var _promise = _this.createPromise(tempResolve, _this.tempResolveList)
            _promise.catch = function (tempReject) { // 异步操作传递参数，简言之就是连接then和resolve
                _this.createPromise(tempReject, _this.tempRejectList)
            }
            return _promise // 返回Promise用于链式调用
        }



        MyPromise.prototype.constructor = MyPromise
        var count = 1
        new MyPromise(function (res, rej) {
                setTimeout(function () {
                    rej('success' + count++)
                }, 1000)
                // setTimeout(function () {
                //     res('success' + count++)
                // }, 1000)
            })
            .then(function (res) {
                console.log(res) // success1
                return new MyPromise(function (res, rej) {
                    setTimeout(function () {
                        res('success' + count++)
                    }, 1000)
                })
            }).catch(function (err) {
                console.log(err) // success1
            })</code></pre> 
<p><strong>总结：代码可能有地方不完善，欢迎大佬指出</strong></p> 
<div id="gtx-trans"> 
 <div class="gtx-trans-icon">
  &nbsp;
 </div> 
</div>
                ]]></description></item><item><title>JS从看懂到看开（前端面试题整合）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/11/14290017.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Wed, 11 Nov 2020 03:11:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/11/14290017.html</guid><description><![CDATA[
                    <p><span style="color:#f33b45;"><strong>解释一下为何[ ] == ![ ]&nbsp; &nbsp;// ---&gt; true</strong></span></p> 
<p><strong>首先看一张图</strong></p> 
<p><img alt="" height="228" src="https://img-blog.csdnimg.cn/2020110610052125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="316"><br><strong>！[ ] 是 false<br> 原式：[ ] == false<br> 根据第八条，false通过tonumber（）转换为0<br> 原式：[ ] == 0<br> 根据第十条，[ ]通过ToPrimitive()转换为'&nbsp; '<br> 原式：' ' == 0<br> 根据第六条<br> 原式：0 == 0</strong></p> 
<p><span style="color:#f33b45;"><strong>尝试实现new</strong></span></p> 
<pre><code class="language-javascript">        function ObjectClass() {//对象
            console.log(arguments[0])
        }
        ObjectClass.prototype.constructor = ObjectClass

        function create() {
            // 创建一个空的对象
            var obj = {}
            // 获得构造函数
            var _constructor = this
            // 链接到原型
            obj.__proto__ = _constructor.prototype
            // 绑定 this，执行构造函数
            var result = _constructor.apply(obj, arguments)
            // 确保 new 出来的是个对象
            return typeof result === 'object' ? result : obj
        }
        create.call(ObjectClass, 'hello world')//实例化</code></pre> 
<p><strong><span style="color:#f33b45;">拓展typeof功能使其支持更多类型（array，object，null区分），并解释一下typeof null为何是object</span></strong></p> 
<pre><code class="language-javascript">        function myTypeOf(target) {
            var _type = typeof (target)
            var temp = {
                "[object Object]": 'object',
                "[object Array]": 'array',
                "[object Number]": 'number',
                "[object String]": 'string',
                "[object Boolean]": 'boolean'
            }
            if (target === null) {
                return 'null'
            } else if (_type == 'object') {
                var str = Object.prototype.toString.call(target)//根据toString区分
                return temp[str]
            } else {
                return _type
            }
        }
        console.log(myTypeOf('hello')) //string
        console.log(myTypeOf(111)) // number
        console.log(myTypeOf(true)) // boolean
        console.log(myTypeOf({})) // object
        console.log(myTypeOf([])) // array
        console.log(myTypeOf(null)) // null
        console.log(myTypeOf(undefined)) // undefined
        console.log(myTypeOf(Symbol())) // symbol</code></pre> 
<p><strong>typeof null为何是object</strong></p> 
<p><strong>因为在早期js初版本中，操作系统使用的是32位，出于性能考虑，使用低位存储变量类型，object的类型前三位是000，而null是全0，从而系统将null误判为object</strong></p> 
<p><strong><span style="color:#f33b45;">instanceof是什么？尝试实现一下</span></strong></p> 
<p><strong>用官话来讲：instanceof用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上</strong></p> 
<p><strong>通俗来讲，a instanceof b也就是判断a是否是由b实例化得来的</strong></p> 
<p><strong>实现：</strong></p> 
<pre><code class="language-javascript">        function ObjectClass() {}
        ObjectClass.prototype.constructor = ObjectClass
        var _objectClass = new ObjectClass()

        function myInstanceof(orgProto, tag) { //org前者，实例化对象, tag后者，类
            var tagProto = tag.prototype
            orgProto = orgProto.__proto__
            for (;;) { //死循环查询原型链上是否有类的原型
                if (orgProto === null) {
                    return false
                }
                if (orgProto === tagProto) {
                    return true
                }
                orgProto = orgProto.__proto__
            }
        }
        console.log(myInstanceof(Object, Function)) // true
        console.log(myInstanceof(Object, Object)) // true
        console.log(myInstanceof(String, Object)) // true
        console.log(myInstanceof(_objectClass, Object)) // true
        console.log(myInstanceof(String, String)) // false
        console.log(myInstanceof(Boolean, Boolean)) // false</code></pre> 
<p><strong><span style="color:#f33b45;">解释以下代码分别在控制台显示什么，并简单说明</span></strong></p> 
<p><strong>有一个对象Car，分别对以下四种情况进行作答</strong></p> 
<pre><code class="language-javascript">Car.prototype.name = 'BMW'

function Car() {}</code></pre> 
<p><strong>1.实例化对象时打印BMW，因为Car.prototype.name = 'BMW'，实例化的car本身没有name属性，于是会在Car的原型上找。此时将Car.prototype.name = 'Benz'，实例化后的car.name也会等于Benz，因为name是基本数据类型（原始值），当值发送变化，实例化后的对象也会改变</strong></p> 
<pre><code class="language-javascript">        var car = new Car()
        console.log(car.name) //BMW
        Car.prototype.name = 'Benz'
        console.log(car.name) //Benz</code></pre> 
<p><strong>2.实例化对象时打印Benz，因为在实例化之前就已经改变构造函数原型上的name值</strong></p> 
<pre><code class="language-javascript">        Car.prototype.name = 'Benz'
        var car = new Car()
        console.log(car.name) //Benz</code></pre> 
<p><strong>3.第一个log的BMW与上述一样，第二个log依然打印BMW的原因是，这里将Car.prototype直接改变成另一个对象，由于对象是引用数据类型（引用值），指向的是内存地址而不是值，new之前和new之后的实例对象引用的name地址不同</strong></p> 
<pre><code class="language-javascript">        var car = new Car()
        console.log(car.name) //BMW
        Car.prototype = {
            name: 'Benz'
        }
        console.log(car.name) //BMW</code></pre> 
<p><strong>4.和上述相同，原因是修改了prototype，改变的是引用地址，new之前和new之后的实例对象引用的name地址不同</strong></p> 
<pre><code class="language-javascript">        Car.prototype = {
            name: 'Benz'
        }
        var car = new Car()
        console.log(car.name) //Benz</code></pre> 
<p><strong><span style="color:#f33b45;">写一个函数，计算字符串Unicode总长度（例如：abcd，打印4，qwerdf，打印6）</span></strong></p> 
<p><strong>需要注意的是，英文字符占1个字节，中文字符占两个字节</strong></p> 
<pre><code class="language-javascript">        function unicodeLength(str) {
            for (var i = 0, count = 0; i &lt; str.length; i++) {
                console.log(str.charCodeAt(i))
                if (str.charCodeAt(i) &gt; 255) { //中文字符
                    count += 2
                } else { //英文字符
                    count++
                }
            }
            return count
        }
        console.log(unicodeLength('hello，1024，你好')) //17</code></pre> 
<p><span style="color:#f33b45;"><strong>实现一下js中window自带的isNaN()函数</strong></span></p> 
<p><strong>注意点：如果直接使用NaN==NaN来判断，会返回false，需要将NaN转换成字符串，再来判断</strong></p> 
<pre><code class="language-javascript">        isNaN('asda') //window下的原函数
        console.log(isNaN(13)) //false
        console.log(isNaN('aaa')) //true

        function myIsNaN(number) {
            return "" + Number(number) == "NaN" ? true : false
        }
        console.log(myIsNaN(32323)) //false
        console.log(myIsNaN('aaa')) //true</code></pre> 
<p><strong><span style="color:#f33b45;">实现数组push()方法</span></strong></p> 
<pre><code class="language-javascript">        function myPush() {
            for (var i = 0; i &lt; arguments.length; i++) {
                this[this.length] = arguments[i]
            }
            return this.length
        }
        Array.prototype.myPush = myPush
        var list = [1, 2, 3, 4, 5]
        var item = 6
        console.log(list.myPush(item)) //6
        console.log(list) //[1, 2, 3, 4, 5, 6]</code></pre> 
<p><strong><span style="color:#f33b45;">实现数组乱序（提示：使用Array.sort）</span></strong></p> 
<p><strong>Array.sort((a,b)=&gt;{})中a-b升序，b-a降序</strong></p> 
<pre><code class="language-javascript">        Array.prototype.random = random

        function random() {
            this.sort(function () {
                return Math.random() - 0.5
            })
            return this
        }
        var list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        console.log(list.random())//[3, 2, 6, 4, 9, 8, 1, 5, 7] 结果每次都不同</code></pre> 
<p><strong><span style="color:#f33b45;">以下代码在控制台显示什么？说明原因</span></strong></p> 
<pre><code class="language-javascript">        var obj = {
            "0": 'a',
            "1": 'b',
            "2": 'c',
            "length": 3,
            "push": Array.prototype.push
        }
        obj.push(1, 2, 3)
        console.log(obj)</code></pre> 
<p><strong>打印结果是</strong></p> 
<pre><code class="language-javascript">        {
            0: "a"
            1: "b"
            2: "c"
            3: 1
            4: 2
            5: 3
            length: 6
        }</code></pre> 
<p><strong>原因：说明原因之前先看一段Array.prototype.push的源码：</strong></p> 
<pre><code class="language-javascript">function ArrayPush () {  
var n = TO_UNIT32(this.length);  
var m = %_ArgumentsLength();  
for (var i = 0; i &lt; m; i++) {
    this[i + n ] = %_Arguments(i);
  }  this.length = n + m;
  return this.length;
}
</code></pre> 
<p><strong>push的原理是在原对象后面将push的内容遍历进去，获取this.length并且在此基础上加上push的个数，这就不难解释为何push了三个数后length为6</strong></p> 
<p><span style="color:#f33b45;"><strong>解释以下代码打印为undefined的原因</strong></span></p> 
<pre><code class="language-javascript">        var num = 123;
        num.item = 'abc'
        console.log(num.item) //undefined</code></pre> 
<p><strong>第一步：var num = 123</strong></p> 
<p><strong>第二步：num.item = 'abc'//隐式转换，相当于new Number(num).item = 'abc'（包装类生成引用类型数据），此时底层会判定此时的num是原始值，不存在属性值，所以执行delete（num.item）</strong></p> 
<p><strong>第三步：打印undefined</strong></p> 
<p><span style="color:#f33b45;"><strong>使用JS原生实现function中的call，apply，bind函数</strong></span></p> 
<p><strong>call:</strong></p> 
<pre><code class="language-javascript">        Function.prototype.myCall = function () {
            var _this = arguments[0] || window; //第一项是需要this指向的对象
            _this._function = this //this是要执行的函数，改变指向为_this
            var args = [] //把除this之外的所有参数放在args中
            for (var i = 1; i &lt; arguments.length; i++) { //i = 1，第二项到最后一项是参数
                args[i - 1] = arguments[i]
            }
            return eval("_this._function(" + args + ")") //eval能将数组隐式拆分，效果与join相似，但二者区别很大，return将函数执行结果返回
            delete _this._function //执行完成后删除当前_function,这个_function用来放this
        }
        var a = 'window'
        var obj1 = {
            a: 'obj1',
            fn: function () {
                console.log(this.a)
                console.log(arguments)
            }
        }
        var obj2 = {
            a: 'obj2'
        }
        obj1.fn.myCall(obj2, 1, 2, 3, 4) //obj2  arguments[1, 2, 3, 4]
        obj1.fn.myCall(this, 3, 2, 1) //window  arguments[3, 2, 1]</code></pre> 
<p><strong>apply（调用上面的myCall实现即可）:</strong></p> 
<pre><code class="language-javascript">        Function.prototype.myApply = function () {
            var _this = arguments[0] || window; //第一项是需要this指向的对象
            _this._function = this //this是要执行的函数，改变指向为_this
            return eval("_this._function.myCall(_this, " + arguments[1] + ")") //eval能将数组隐式拆分，效果与join相似，但二者区别很大，return将函数执行结果返回
            delete _this._function //执行完成后删除当前_function,这个_function用来放this
        }
        var a = 'window'
        var obj1 = {
            a: 'obj1',
            fn: function () {
                console.log(this.a)
                console.log(arguments)
            }
        }
        var obj2 = {
            a: 'obj2'
        }
        obj1.fn.myApply(obj2, [1, 2, 3, 4]) //obj2  arguments[1, 2, 3, 4]
        obj1.fn.myApply(this, [3, 2, 1]) //window  arguments[3, 2, 1]</code></pre> 
<p><strong>bind（继续调用上面myApply）:</strong></p> 
<pre><code class="language-javascript">        Function.prototype.myBind = function () {
            var t = this;
            var _this = arguments[0] || window; //第一项是需要this指向的对象
            var args = Array.prototype.slice.myApply(arguments, [
                1], ) //这项的目的是为了去除第一项arguments[0]，就与上面的myCall中的遍历作用相同，Array.prototype.slice传一个参数，slice(start,end)表示删除第start到end项并返回删除后的数组，这里我们只用截取，不用删除，这里是删除第一项（由于用的是myApply，第二个参数是数组所以用[1]）并返回删除后的数组
            return function () {
                return t.myApply(_this, args)
            }
        }
        var a = 'window'
        var obj1 = {
            a: 'obj1',
            fn: function () {
                console.log(this.a)
                console.log(arguments)
            }
        }
        var obj2 = {
            a: 'obj2'
        }
        obj1.fn.myBind(obj2, 1, 2, 3, 4)() //obj2  arguments[1, 2, 3, 4]
        obj1.fn.myBind(this, 3, 2, 1)() //window  arguments[3, 2, 1]</code></pre> 
<p><span style="color:#f33b45;"><strong>对mvvm，mvp和mvc的理解</strong></span></p> 
<p><strong>Model–View–ViewModel(MVVM)，Model-View-Presenter（MVP）和Model–View-Controller（MVC）&nbsp;都是软件架构设计模式</strong></p> 
<p><strong><span style="color:#f33b45;">相同的地方</span></strong></p> 
<ul><li><strong>Model 是指任何一个领域模型(domain model)，一般做数据处理，可以理解为数据库，用来存放应用的所有数据对象。模型不必知晓视图和控制器的细节，模型只需包含数据及直接和这些数据相关的逻辑。任何事件处理代码、视图模版，以及那些和模型无关的逻辑都应当隔离在模型之外，它代表了真实情况的内容（一个面向对象的方法），或表示内容（以数据为中心的方法）的数据访问层</strong></li><li><strong>View就是用户界面（UI），视图层是呈现给用户的，用户与之产生交互。在javaScript应用中，视图大都是由html、css和JavaScript模版组成的。除了模版中简单的条件语句之外，视图不应当包含任何其他逻辑。事实上和模型类似，视图也应该从应用的其他部分中解耦出来</strong></li></ul>
<p><strong><span style="color:#f33b45;">不同的地方</span></strong></p> 
<ul><li><strong>MVC的Controller控制器是模型和视图的纽带。控制器从视图获得事件和输入，对它们进行处理，并相应地更新视图。当页面加载时，控制器会给视图添加事件监听，比如监听表单提交和按钮单击。然后当用户和应用产生交互时，控制器中的事件触发器就开始工作。</strong></li><li><strong>MVVM的ViewModel是一个公开公共属性和命令的抽象的view。取代了 MVC 模式的 controller，或 MVP 模式的任命者(presenter)，MVVM 有一个驱动。 在 viewmodel 中，这种驱动传达视图和数据绑定的通信。此 viewmodel 已被描述为该 model 中的数据的状态。</strong></li><li><strong>MVP的Presenter负责逻辑的处理，在MVP中View并不直接使用Model，它们之间的通信是通过Presenter来进行的，所有的交互都发生在Presenter内部，而 在MVC中View会直接从Model中读取数据而不是通过Controller。</strong></li></ul>
<p><span style="color:#f33b45;"><strong>谈谈对前端页面渲染的理解（过程，原理，性能，重绘和回流）</strong></span></p> 
<p><strong>页面渲染分为以下步骤<br> 1. 处理HTML语句标签并构建 DOM 树<br> 2. 处理CSS语句并构建CSSOM树<br> 3. 将处理好的DOM与CSSOM合并成一个渲染树<br> 4. 根据渲染树来布局，计算每个节点的位置样式等等<br> 5. 调&nbsp;GPU（显卡）绘制页面，合成图层，最后显示在浏览器</strong></p> 
<p><strong>在处理CSSOM时，会暂时堵塞DOM渲染，并且扁平层级关系有利于渲染速度，越详细的样式选择器，会导致页面渲染越慢<br> CSS加载会影响JS文件或语句加载，JS需要等待CSS解析完毕后运行</strong></p> 
<p><strong>document中的DOMContentLoaded和Load的区别​​：前者只需HTML加载完成后，就会触发，后者需要等HTML，CSS，JS都加载完成才会触发​​​​​</strong></p> 
<p><strong>图层概念：普通文档流就是一个图层，特定的属性可以生成一个新的图层。 不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用<br> 以下CSS属性可以生成新图层：</strong></p> 
<ul><li><strong>3D 变换：translate3d、translateZ</strong></li><li><strong>will-change</strong></li><li><strong>video、iframe 标签</strong></li><li><strong>通过动画实现的 opacity 动画转换</strong></li><li><strong>position: fixed</strong></li></ul>
<p><strong>重绘（Repaint）和回流（Reflow）<br> 重绘是当节点需要更改外观而不会影响布局的，比如改变color就叫称为重绘回流是布局或者几何属性需要改变就称为回流。<br> 回流必定会发生重绘，重绘不一定会引发回流。<br> 回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</strong></p> 
<p><strong>所以以下几个动作可能会导致性能问题： </strong></p> 
<ul><li><strong>改变 window 大小</strong></li><li><strong>改变字体</strong></li><li><strong>添加或删除样式</strong></li><li><strong>文字改变</strong></li><li><strong>定位或者浮动</strong></li><li><strong>盒模型</strong></li></ul>
<p><strong>如何减少重绘和回流</strong></p> 
<ul><li><strong>使用 translate 替代 top</strong></li><li><strong>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发 回流（改变了布局）</strong></li><li><strong>把DOM离线后修改，比如：先把DOM给display:none（回流），然后你修改100次，然后再把它显示出来</strong></li><li><strong>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</strong></li><li><strong>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</strong></li><li><strong>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame</strong></li><li><strong>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</strong></li><li><strong>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对 于 video 标签，浏览器会自动将该节点变为图层。</strong></li></ul>
<p><span style="color:#f33b45;"><strong>谈谈对前端继承的理解</strong></span></p> 
<p><strong>原型链继承，子类实例继承的属性有，子类构造函数的属性，父类构造函数的属性，父类原型上的属性<br> 缺点：无法向父类传参，当父类原型上的属性改变时，所以子类实例相对应的属性都会对应改变</strong></p> 
<pre><code class="language-javascript">        function Father() {
            this.name = "father";
            this.sex = "man"
        }
        Father.prototype.hobby = 'fish'

        function Son() {
            this.name = "son";
        }
        // 原型链继承
        Son.prototype = new Father()
        var son1 = new Son()
        var son2 = new Son()
        Father.prototype.hobby = 'dog' //缺点，修改父类prototype上的属性时，所有子类都会随之修改
        console.log(son1.hobby) // dog
        console.log(son2.hobby) // dog
        console.log(son1 instanceof Father) // true</code></pre> 
<p><strong>构造函数继承（通过call，apply），子类可继承多个父类，可传参给父类<br> 缺点：每个实例都有父类的构造函数，父类prototype上的属性无法继承</strong></p> 
<pre><code class="language-javascript">        // 构造函数继承（通过call，apply）
        function Father() {
            this.name = "father";
            this.sex = "man"
        }
        Father.prototype.hobby = 'fish'
        function Son(sex) {
            Father.call(this, sex) //可继承多个父类,但是每个实例都有父类的构造函数
            this.name = "son";
        }
        var son = new Son('woman')
        console.log(son.sex) //woman,可传参给父类
        console.log(son.hobby) //undefined，缺点，父类prototype上的属性无法继承
        console.log(son instanceof Father) // false</code></pre> 
<p><strong>组合继承，上述两者的结合，解决了上面的缺点和问题（常用）<br> 缺点：Father.call()和new Father()执行了两次父类构造函数，增加了性能损耗，父类的原型上的constructor指向了子类，此时需要在实例化父类（new Father）后在实例化子类（new Son）之前添加一句话：Father.prototype.constructor&nbsp;=&nbsp;Father</strong></p> 
<pre><code class="language-javascript">        // 组合继承
        function Father(sex) {
            this.name = "father";
            this.sex = sex
        }
        Father.prototype.hobby = 'fish'

        function Son(sex) {
            Father.call(this, sex) //可继承多个父类
            this.name = "son";
        }
        Son.prototype = new Father()
        Father.prototype.constructor = Father //解决父类的原型上的constructor指向了子类
        var son = new Son('woman')
        console.log(son.sex) //woman,可传参给父类
        console.log(son.hobby) //fish
        console.log(son instanceof Father) // true</code></pre> 
<p><strong>原型式继承，和Object.create相似，通过函数进行继承，会继承父类所有属性<br> 缺点：父类原型上的属性发生变化时，所有子类对应属性都会改变，子类无法直接修改属性，复用性较差</strong></p> 
<pre><code class="language-javascript">        // 原型式继承
        function Father() {
            this.name = "father";
            this.sex = 'man'
        }
        Father.prototype.hobby = 'fish'

        function Son() {
            this.name = "son";
        }

        function inherit(father) {
            function Fn() {}
            Fn.prototype = father;
            return new Fn() //类似于复制了father这个对象
        }
        var father = new Father()
        var son1 = inherit(father)
        Father.prototype.hobby = 'dog' //缺点，修改父类prototype上的属性时，所有子类都会随之修改
        var son2 = inherit(father)
        console.log(son1.sex) //man
        console.log(son1.hobby) //dog
        console.log(son2.hobby) //dog
        console.log(son1 instanceof Father) // true</code></pre> 
<p><strong>寄生式继承，继承父类所有属性，并且可以添加子类自己的属性方法<br> 缺点：代码复用率低</strong></p> 
<pre><code class="language-javascript">        function Father(sex) {
            this.name = "father";
            this.sex = sex //实例传参
        }
        Father.prototype.hobby = 'fish'

        function Son() {
            this.name = "son";
        }
        Object.prototype.myCreate = function (obj) {//实现Object.create
            function Fn() {}
            Fn.prototype = obj;
            return new Fn()
        }

        function inherit(father) {
            var _father = Object.myCreate(father)//克隆对象
            _father.getInfo = function () {//增强子类，修改属性，产生子类独有的方法和属性，但是耦合高，复用性差，不同子类的写法各不同
                console.log(_father.name)
                console.log(_father.hobby)
                console.log(_father.sex)
            }
            return _father;
        }
        var father = new Father('woman')
        var son = inherit(father)
        son.getInfo() //father，fish，woman</code></pre> 
<p><strong>寄生式组合继承，继承父类所有属性，解决调用两次父类构造函数问题：一次是在创建子类型原型，一次在子类内部（理论上是最理想的继承）</strong></p> 
<pre><code class="language-javascript">        // 寄生式组合继承
        function Father(sex) {
            this.name = "father";
            this.sex = sex //实例传参
        }
        Father.prototype.hobby = 'fish'
        Father.prototype.getName = function () {
            console.log(this.name)
        }

        function Son(sex) {
            console.log(this.superClass) //Father
            Father.call(this, sex); //构造函数继承传递参数
            this.name = "son";
            this.hobby = "dog";
        }
        Son.prototype.getName = function () {
            console.log(this.name)
        }

        function Grandson(sex) {
            console.log(this.superClass) //Son
            Son.call(this, sex); //构造函数继承传递参数
            this.name = "grandson";
            this.hobby = "cat";
        }

        var inherit = (function () {
            function F() {} //使用闭包产生私有函数，使每个子类继承的父类属性无引用关系
            return function (father, son) {
                F.prototype = father.prototype; //私有函数取出父类的原型
                son.prototype = new F();
                son.prototype.superClass = father; //子类的超类指向父类，子类通过this.superClass调用Father
                son.prototype.constructor = son;
            }
        }())
        inherit(Father, Son)
        inherit(Son, Grandson)
        var father = new Father('fatherMan')
        var son = new Son('sonMan')
        var grandson = new Grandson('grandsonMan')
        console.log(son instanceof Father) //true
        console.log(grandson instanceof Son) //true
        console.log(grandson instanceof Father) //true
        console.log(father.sex) //fatherMan
        console.log(son.sex) //sonMan
        console.log(grandson.sex) //grandsonMan
        console.log(father.hobby) //fish
        console.log(son.hobby) //dog
        console.log(grandson.hobby) //cat
        father.getName() //father
        son.getName() //son
        grandson.getName() //grandson</code></pre> 
<p>&nbsp;</p>
                ]]></description></item><item><title>前端面试题整合（JS进阶篇）（二）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/07/13945215.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Sat, 07 Nov 2020 10:41:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/07/13945215.html</guid><description><![CDATA[
                    <p><span style="color:#f33b45;"><strong>Ajax 是什么? 如何创建一个Ajax？</strong></span></p> 
<p><strong>AJAX全称是Asychronous JavaScript And Xml（异步的 JavaScript 和 XML）<br> 它的作用是用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持<br> 其主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果<br> 实现方式（<a href="https://gitee.com/DieHunter/myCode/blob/master/Tools/methods.js">gitee上的案例</a>）：</strong></p> 
<pre><code class="language-javascript">var xhr =null;//创建对象 
if(window.XMLHttpRequest){
	xhr = new XMLHttpRequest();
}else{
	xhr = new ActiveXObject("Microsoft.XMLHTTP");
}
xhr.open(“方式”,”地址”,”标志位”);//初始化请求 
xhr.setRequestHeader(“”,””);//设置http头信息 
xhr.onreadystatechange =function(){}//指定回调函数 
xhr.send();//发送请求 
</code></pre> 
<p><strong><span style="color:#f33b45;">Ajax的优缺点</span></strong></p> 
<p><strong>优点：</strong></p> 
<ul><li><strong>通过异步模式，提升了用户体验 </strong></li><li><strong>优化了浏览器和服务器之间的传输，按需获取数据，减少不必要的数据往返，减少了带宽占用</strong></li><li><strong><strong>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</strong></strong></li></ul>
<p><strong>缺点：</strong></p> 
<ul><li><strong>ajax不支持浏览器back按钮</strong></li><li><strong>安全问题 AJAX暴露了与服务器交互的细节</strong></li><li><strong>对搜索引擎的支持比较弱</strong></li><li><strong>破坏了程序的异常机制。</strong></li></ul>
<p><strong><span style="color:#f33b45;">一个页面从输入 URL 到页面加载显示完成，发生了什么？</span></strong></p> 
<ul><li><strong>当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。</strong></li><li><strong>浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</strong></li><li><strong>一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</strong></li><li><strong>此时，Web 服务器提供资源服务，客户端开始下载资源。</strong></li><li><strong>后续HTML页面解析参照<a href="https://blog.csdn.net/time_____/article/details/109472503">前端面试题整合（JS进阶篇）（一）</a>的&nbsp;</strong>“<strong>html页面怎么解析的？它加载顺序是什么？</strong>”</li></ul>
<p><strong><span style="color:#f33b45;">JQuery一个对象为何可以同时绑定多个事件</span></strong></p> 
<p><strong>低层实现方式是使用addEventListner或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件</strong></p> 
<p><strong><span style="color:#f33b45;">对页面某个节点的拖曳</span></strong></p> 
<p><strong>1.&nbsp;&nbsp; &nbsp;给需要拖拽的节点绑定mousedown, mousemove, mouseup事件<br> 2.&nbsp;&nbsp; &nbsp;mousedown事件触发后，开始拖拽<br> 3.&nbsp;&nbsp; &nbsp;mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置<br> 4.&nbsp;&nbsp; &nbsp;mouseup时，拖拽结束<br> 5.&nbsp;&nbsp; &nbsp;需要注意浏览器边界的情况</strong></p> 
<p><strong><a href="https://gitee.com/DieHunter/myCode/blob/master/Tools/methods.js">gitee上的案例</a></strong></p> 
<pre><code class="language-javascript">        function mouseMove(ele, parent) {
            ele.addEventListener('mousedown', moveHandler);
            ele.style.position = 'absolute'
            function moveHandler(e) {
                if (e.type === 'mousedown') {
                    parent.ele = this;
                    parent.point = {
                        x: e.offsetX,
                        y: e.offsetY
                    }
                    parent.addEventListener('mousemove', moveHandler);
                    parent.addEventListener('mouseup', moveHandler);
                } else if (e.type === 'mousemove') {
                    this.ele.style.left = e.x - this.point.x + "px";
                    this.ele.style.top = e.y - this.point.y + "px";
                } else if (e.type === 'mouseup') {
                    parent.removeEventListener("mousemove", moveHandler);
                    parent.ele = null;
                    parent.point = null;
                }
            }
        }</code></pre> 
<p><span style="color:#f33b45;"><strong>new操作符具体干了什么</strong></span></p> 
<ol><li><strong>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</strong></li><li><strong>属性和方法被加入到 this 引用的对象中。</strong></li><li><strong>新创建的对象由 this 所引用，并且最后隐式的返回 this</strong></li></ol>
<p><strong>以下是模拟操作：</strong></p> 
<pre><code class="language-javascript">new TestObj('str')=function(){
    let obj={};  //创建一个空对象
    obj.__proto__=TestObj.prototype;
    //把该对象的原型指向构造函数的原型对象，就建立起原型了：obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null
    return TestObj.call(obj,arguments);// 绑定this到实例化的对象上
}</code></pre> 
<p><span style="color:#f33b45;"><strong>前端开发的优化问题</strong></span></p> 
<p><strong>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br> （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br> （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br> （4） 当需要设置的样式很多时设置className而不是直接操作style。<br> （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br> （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br> （7） 图片预加载，将样式表放在顶部，将脚本放在底部 &nbsp;加上时间戳。<br> （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</strong></p> 
<p><span style="color:#f33b45;"><strong>fetch和Ajax有什么不同</strong></span></p> 
<ul><li><strong>XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好</strong></li><li><strong>fetch 是浏览器提供的一个新的 web API，它用来代替 Ajax（XMLHttpRequest），其提供了更优雅的接口，更灵活强大的功能。</strong></li><li><strong>Fetch 优点主要有：</strong><strong>语法简洁，更加语义化</strong>，<strong>基于标准 Promise 实现，支持 async/await</strong></li></ul>
<p><strong><span style="color:#f33b45;">如何编写高性能的Javascript</span></strong></p> 
<ul><li><strong>使用 DocumentFragment 优化多次 append</strong></li><li><strong>通过模板元素 clone，替代 createElement</strong></li><li><strong>使用一次 innerHTML 赋值代替构建 dom 元素</strong></li><li><strong>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</strong></li><li><strong>使用 Array 做为 StringBuffer ，代替字符串拼接的操作</strong></li><li><strong>将循环控制量保存到局部变量</strong></li><li><strong>顺序无关的遍历时，用 while 替代 for</strong></li><li><strong>将条件分支，按可能性顺序从高到低排列</strong></li><li><strong>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</strong></li><li><strong>使用三目运算符替代条件分支</strong></li><li><strong>需要不断执行的时候，优先考虑使用 setInterval</strong></li></ul>
<p><span style="color:#f33b45;"><strong>定时器setInterval有一个有名函数fn，setInterval（fn,500）与setInterval（fn(),500）有什么区别？</strong></span></p> 
<p><strong>第一个是重复执行每500毫秒执行一次，后面一个只执行一次。</strong></p> 
<p><strong><span style="color:#f33b45;">简述一下浏览器内核</span></strong></p> 
<p><strong>浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。</strong></p> 
<p><strong><span style="color:#f33b45;">JavaScript的数据对象有哪些属性值？</span></strong></p> 
<p><strong>writable：这个属性的值是否可以改<br> configurable：这个属性的配置是否可以删除，修改<br> enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来<br> value：属性值。</strong></p> 
<p><span style="color:#f33b45;"><strong>懒加载（瀑布流）的实现原理</strong></span></p> 
<p><strong>意义：懒加载的主要目的是作为服务器前端优化，减少请求数或延迟请求数实现原理：先加载一部分数据，当触发某个条件时利用异步加载剩余的数据，新得到的数据，不会影响有数据的显示，同时最大程度上减少服务器的资源消耗<br> 实现方式：<br> （1）延迟加载，使用setTimeOut或setInterval进行加载延迟<br> （2）符合某些条件，或触发了某些事件才开始异步下载<br> （3）可视区加载</strong></p> 
<p><strong>我的<a href="https://blog.csdn.net/time_____/article/details/84639454">懒加载文章</a>，以及<a href="https://gitee.com/DieHunter/myCode/tree/master/%E7%80%91%E5%B8%83%E6%B5%81">源码地址</a></strong></p> 
<p><strong><span style="color:#f33b45;">js实现数组去重</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#222222;">双层循环，外层循环元素，内层循环时比较值，</span></strong><strong><span style="color:#222222;">如果有相同的值则跳过，不相同则push进数组</span></strong></p> 
<pre><code class="language-javascript">        class MyArray extends Array {
            constructor() {
                super(...arguments)
            }
            distinct() {
                var myArr = this,
                    list = []
                for (var i = 0; i &lt; myArr.length; i++) {
                    for (var j = i + 1; j &lt; myArr.length; j++) {
                        if (myArr[i] === myArr[j]) {
                            j = ++i;
                        }
                    }
                    list.push(myArr[i]);
                }
                return list;
            }
        }
        var _arr = new MyArray(4, 5, 6, 7, 7, 7, 1, 1, 1, 2, 2, 2, 5, 8, 5, 2, 4, 4, 4, 6, 9);
        console.log(_arr.distinct()); //[7, 1, 8, 5, 2, 4, 6, 9]</code></pre> 
<p><strong>利用对象的属性不能相同的特点进行去重</strong></p> 
<pre><code class="language-javascript">        class MyArray extends Array {
            constructor() {
                super(...arguments)
            }
            distinct() {
                var myArr = this,
                    list = [],
                    obj = {}
                for (var i = 0; i &lt; myArr.length; i++) {
                    obj[myArr[i]] || (obj[myArr[i]] = 1,
                        list.push(myArr[i])) //如果能查找到，证明数组元素重复了
                }
                return list;
            }
        }
        var _arr = new MyArray(4, 5, 6, 7, 7, 7, 1, 1, 1, 2, 2, 2, 5, 8, 5, 2, 4, 4, 4, 6, 9);
        console.log(_arr.distinct()); //[4, 5, 6, 7, 1, 2, 8, 9]</code></pre> 
<p><strong><span style="color:#222222;">Set</span><span style="color:#222222;">数据结构，它类似于数组，其成员的值都是唯一的</span></strong></p> 
<pre><code class="language-javascript">        function dedupe(array) {
            return Array.from(new Set(array));
        }
        console.log(dedupe([1, 1, 2, 3])) //[1,2,3]</code></pre> 
<p><span style="color:#f33b45;"><strong>实现快速排序和冒泡排序</strong></span></p> 
<p><span style="color:#f33b45;"><strong>快速排序</strong></span><strong>：选取位置在数组中间的一个数，然后比它小的放在left[]的一个新数组里面，比他大的放在right[]的一个新数组里面，以此类推，重复执行这个过程，利用递归的思想，直至执行到left[]和right[]里面都只有一个数</strong><br><strong><span style="color:#f33b45;">冒泡排序</span>：两两比较，前面的比后面的大，则换位。第一轮list.length-1次，挑出最大的；第二轮list.length-1-1次，挑出第二大的。以此往复</strong></p> 
<pre><code class="language-javascript">        class MyArray extends Array {
            constructor() {
                super(...arguments)
            }
            quickSort(list) { //快速排序
                var myArr = this,
                    listConfig = {
                        midItem: myArr[parseInt(myArr.length / 2)],
                        leftList: new MyArray(),
                        rightList: new MyArray()
                    }
                if (myArr.length &lt;= 1) {
                    return myArr
                };
                for (var i = 0; i &lt; myArr.length; i++) {
                    myArr[i] &lt; listConfig.midItem ? listConfig.leftList.push(myArr[i]) : myArr[i] &gt; listConfig
                        .midItem ? listConfig.rightList.push(myArr[i]) : '';
                }
                return listConfig.leftList.quickSort().concat([listConfig.midItem], listConfig.rightList
                    .quickSort()); //递归
            }
            bubbleSort() { //冒泡排序
                for (var i = 0; i &lt; this.length - 1; i++) {
                    for (var j = 0; j &lt; this.length - 1 - i; j++) {
                        if (this[j] &gt; this[j + 1]) {
                            var item = this[j];
                            this[j] = this[j + 1];
                            this[j + 1] = item;
                        }
                    }
                }
                return this
            }
        }
        var quickSortArray = new MyArray(19, 15, 18, 17, 11, 21, 14, 61, 13, 10, 25);
        var bubbleSortArray = new MyArray(9, 5, 8, 7, 1, 2, 4, 6, 3, 10, 25);
        console.log(quickSortArray.quickSort()); //[10, 11, 13, 14, 15, 17, 18, 19, 21, 25, 61]
        console.log(bubbleSortArray.bubbleSort()); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 25]</code></pre> 
<p><strong><span style="color:#f33b45;">谈谈节流和防抖，如何实现</span></strong></p> 
<p><strong>节流：使频繁执行的函数，定时执行，高频率函数执行时，使执行率减少，每n秒才能执行一次，打个比方：每隔1秒钟，会执行5次滚动条滚动事件，我只让它每一秒执行一次（案例：网站中的返回顶部）</strong></p> 
<p><strong>防抖：使频繁执行的函数，延时执行，高频率函数执行时，n秒内只执行一次，在事件内多次执行会延时，打个比方：用户在输入框中输入字符，当用户一直在输入时，我们做个延时，当用户输入完毕后会有一段时间停顿，若这个停顿时间大于我们的我们延时时间，我们就进行下一步操作，反之则不进行并且一直延时（案例：搜索引擎搜索输入框）</strong></p> 
<p><strong>区别：对于高频率执行函数，节流是每隔规定时间都会执行一次，防抖是只在规定时间外的最后一次执行</strong></p> 
<p><strong>实现过程：</strong></p> 
<pre><code class="language-javascript">        var count = 0
        class OptimizeEvent {
            constructor() {}
            throttle(fn, time) { //节流
                var canDo = true
                return function (e) {
                    if (!canDo) {
                        return false
                    }
                    canDo = false
                    setTimeout(() =&gt; {
                        fn.call(this)
                        canDo = true
                    }, time)
                }
            }
            debounce(fn, time) { //防抖
                var _timer = null
                return function () {
                    if (_timer) {
                        clearTimeout(_timer)
                        _timer = null
                    }
                    _timer = setTimeout(fn, time)
                }
            }
        }
        var _event = new OptimizeEvent()
        inputBox.addEventListener('input', _event.debounce(function () {
            showBox.textContent = inputBox.value
        }, 1000))
        document.addEventListener('scroll', _event.throttle(function () {
            console.log(count++)
        }, 1000))</code></pre> 
<p><span style="color:#f33b45;"><strong>谈谈深拷贝的实现</strong></span></p> 
<p><strong>深拷贝相对浅拷贝不同的是，深拷贝内所有引用类型属性值都是在新开辟的内存地址，被拷贝的原数据发生改变时不会影响复制后的对象。</strong></p> 
<p><strong><span style="color:#555555;">常见方法</span></strong></p> 
<ul><li><span style="color:#000000;"><strong><span style="color:#555555;">JSON.parse(),JSON.stringify()</span></strong></span></li><li><span style="color:#000000;"><strong><span style="color:#555555;">jQury</span><span style="color:#555555;">的$.extend(true,{},obj)</span></strong></span></li><li><span style="color:#000000;"><strong><span style="color:#555555;">lodash</span><span style="color:#555555;">的</span></strong><span style="color:#555555;"><strong>_.cloneDeep</strong></span></span></li><li><span style="color:#000000;"><span style="color:#555555;"><strong><a href="https://blog.csdn.net/time_____/article/details/85392699">我的深复制文章</a></strong></span></span> <pre><code class="language-javascript">
			function deepClone(org, tag) {
				var tag = tag || {}; //初始化要复制的对象
				var name = Object.getOwnPropertyNames(org); //获取该对象的属性名，以字符串数组返回
				for (var i = 0; i &lt; name.length; i++) { //遍历对象
					var desc = Object.getOwnPropertyDescriptor(org, name[i]); //获取对象的属性描述对象，无引用关系，返回另一个对象，改变时原对象不发生变化(复制的关键)
					if (typeof desc.value === 'object' &amp;&amp; desc.value !== null) { //若遍历的每一项非空且为对象，则为引用值，则进行下一步
						var obj = desc.value.toString() === '[object Object]' ? {} : []; //判断是数组还是对象
						Object.defineProperty(tag, name[i], { //设置对象属性值，前三个的值是返回true或false
							configurable: desc.configurable, //是否可删除可替换
							enumerable: desc.enumerable, //是否可枚举可遍历
							writable: desc.writable, //是否可写入
							value: obj //对象的值
						});
						copyObj(desc.value, obj); //再次执行函数
					} else {
						Object.defineProperty(tag, name[i], desc); //否则直接将该对象的属性值进行复制(原始值)
					}
				}
				return tag;
			}
</code></pre> <p>&nbsp;</p> </li></ul>
                ]]></description></item><item><title>前端面试题整合（JS进阶篇）（一）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/06/13945216.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Fri, 06 Nov 2020 01:21:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/06/13945216.html</guid><description><![CDATA[
                    <p><strong><span style="color:#f33b45;">js的垃圾回收机制是什么原理</span></strong></p> 
<p><strong>垃圾回收机制有两种方法</strong></p> 
<ul><li><strong>第一种是标记清除法：当变量进入执行环境时,就标记这个变量为”进入环境”,当变量离开环境的时候,则将其标记为”离开环境”,垃圾收集器在运行的时候会给储存在内存中的所有变量都加上标记,然后它会去掉环境中的标量以及被环境中的变量引用的标记,而在此之后再被加上标记的变量将被视为准备删除的变量,原因是环境中的变量已经无法访问到这些变量了,最后,垃圾收集器完成内存清除工作,销毁那些带标记的值,并回收他们所占用的内存空间</strong></li><li><strong>第二种是引用计数法：当声明了一个变量并将一个引用类型赋值给改变量是,则这个值得引用次数就是1,相反,如果包含对这个值引用的变量又取得了另外一个值,则这个值得引用次数就减1,当这个引用次数变成0时,则说明没有办法在访问这个值了,因而就可以将其所占的内存空间给收起来,这样垃圾收集器再下次运行时,它就会释放那些引用次数为0的值所占的内存</strong></li></ul>
<p><strong><span style="color:#f33b45;">哪些操作会造成内存泄露，怎样避免内存泄露</span></strong></p> 
<p><strong>会造成内存泄漏的操作：</strong></p> 
<ul><li><strong>意外的全局变量引起的内存泄露</strong></li><li><strong>闭包引起的内存泄露</strong></li><li><strong>控制台日志</strong></li><li><strong>没有清理的DOM元素引用</strong></li><li><strong>被遗忘的定时器或者回调&nbsp;</strong></li></ul>
<p><strong>避免内存泄露的操作：</strong></p> 
<ul><li><strong>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收</strong></li><li><strong>注意程序逻辑，避免“死循环”之类的 </strong></li><li><strong>避免创建过多的对象 &nbsp;原则：不用了的东西要及时归还（置为null）</strong></li></ul>
<p><span style="color:#f33b45;"><strong>AMD\CMD区别</strong></span></p> 
<ul><li><strong>AMD即Asynchronous Module Definition,翻译过来就是异步模块化定义（RequireJS）</strong></li><li><strong>CMD即 common moudle definition,翻译过来即通用模块定义（SeaJS）</strong></li><li><strong>RequireJS在主文件里是将所有的文件同时加载，然而SeaJS强调一个文件一个模块。</strong></li><li><strong>AMD推崇依赖前置，CMD推崇依赖就近。</strong></li><li><strong>AMD加载完模块后，就立马执行该模块；CMD加载完某个模块后没有立即执行而是等到遇到require语句的时再执行</strong></li><li><strong>所以，他们两者的不同导致各自的优点是AMD用户体验好，因为模块提前执行了；CMD性能好，因为只有用户需要的时候才执行。</strong></li></ul>
<p><strong><span style="color:#f33b45;">面向对象的三个特性</span></strong></p> 
<p><strong>封装 ： 屏蔽内部细节 &nbsp; 用户直接调用被封装的功能<br> 继承 ： 子类拥有父类的所有属性或方法<br> 多态 （js中不存在多态概念）</strong></p> 
<p><strong><span style="color:#f33b45;">原型，原型链的理解</span></strong></p> 
<p><strong>所有的构造函数都有一个prototype属性，这个属性也叫 原型对象 &nbsp; 构造函数.prototype &nbsp; &nbsp;所有的构造函数new出来的对象也都有一个原型对象 &nbsp; 实现 ：对象.__proto__<br> 原型链就是实例对象和原型之间的链接<br> 原型对象的执行流程：</strong></p> 
<ul><li><strong>首先去实例上查找，如果找到了就返回</strong></li><li><strong><strong>如果没做查找到，就去改构造函数的原型上查找，如果找到了就返回，如果没找到，就去Object.prototype的原型上查找，找到了就返回，否则返回undefined</strong></strong></li></ul>
<p><span style="color:#f33b45;"><strong>继承的方式</strong></span></p> 
<p><strong>1.通过改变父类的执行环境来实现<br> 2.通过call<br> 3.通过apply<br> 4.原型继承<br> 5.混合继承<br> 6.es6构造函数</strong></p> 
<p><span style="color:#f33b45;"><strong>作用域链的理解</strong></span></p> 
<p><strong>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的</strong><br><strong>安全隐患：污染全局环境，或者造成内存泄露的问题，变量的提升</strong></p> 
<p><span style="color:#f33b45;"><strong>闭包的理解</strong></span></p> 
<p><strong>什么是闭包<br> 一个函数内部返回一个匿名函数，这个函数就称为闭包<br> 闭包中this指向 window<br> 特点<br> （1）函数嵌套函数<br> （2）函数可以引用外层的参数和变量<br> （3）参数和变量不会被垃圾回收机制回收<br> 闭包的缺点：常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。<br> 为何要使用闭包：为了设计私有方法和变量，避免全局变量污染 希望一个变量长期驻扎在内存中</strong></p> 
<p><span style="color:#f33b45;"><strong>下面这个ul，如何点击每一列的时候alert其index（闭包解决方式）</strong></span></p> 
<pre><code class="language-html">&lt;ul id="test"&gt;
    &lt;li&gt;这是第一条&lt;/li&gt;
    &lt;li&gt;这是第二条&lt;/li&gt;
    &lt;li&gt;这是第三条&lt;/li&gt;
&lt;/ul&gt;
</code></pre> 
<p><strong>方法一：</strong></p> 
<pre><code class="language-javascript">//将i属性绑定到标签对象中的index
var liItems=document.getElementById('test').getElementsByTagName('li');
for(var i=0;i&lt;liItems.length;i++)
{
    liItems[i].index=i;
    liItems[i].onclick=function(){
        alert(this.index);
    };
}
</code></pre> 
<p><strong>方法二：</strong></p> 
<pre><code class="language-javascript">//将i属性通过参数传递至function作用域中，立即执行函数在下一次循环之前先将i绑定至作用域
var liItems=document.getElementById('test').getElementsByTagName('li');
for(var i=0;i&lt;liItems.length;i++)
{
     liItems[i].onclick=(function(a){
        return function() {
            alert(a);
        }
    })(i);

}
</code></pre> 
<p><strong>方法三（es6的let产生暂时性死区，与声明的变量所在的块级作用域（for循环内）都不会造成闭包，var只受function的作用域影响，let受所有带‘{}‘大括号的作用域影响）：</strong></p> 
<pre><code class="language-javascript">//通过let
var liItems=document.getElementById('test').getElementsByTagName('li');
        for (let i = 0; i &lt; liItems.length; i++) {
            liItems[i].onclick = function () {
                alert(i);
            }
        }</code></pre> 
<p><strong><span style="color:#f33b45;">高内聚低耦合的理解</span></strong></p> 
<p><strong>高内聚 ：模块内部高内聚 。 一个系统有多个模块组成，在划分模块式，要把功能关系紧密的放到一个模块中，这就叫做高内聚低耦合：功能关系远的放到其它模块中。模块之间的联系越少越好，接口越简单越好，这叫做低耦合，也称为细线通信</strong></p> 
<p><strong><span style="color:#f33b45;">TCP和UDP的最完整的区别</span></strong></p> 
<p><strong>1.基于连接与无连接<br> 2.TCP要求系统资源较多，UDP较少；<br> 3.UDP程序结构较简单<br> 4.流模式（TCP）与数据报模式(UDP);<br> 5.TCP保证数据正确性，UDP可能丢包<br> 6.TCP保证数据顺序，UDP不保证&nbsp;</strong></p> 
<p><span style="color:#f33b45;"><strong>JS处理异步的方式</strong></span></p> 
<ul><li><strong>利用回调函数（es5常用方法）</strong></li><li><strong>用async和await来处理异步（es7-8中新增）</strong></li><li><strong>promise（es6新增）</strong></li><li><strong>发布/订阅 我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）（和事件原理一样）</strong></li><li><strong>事件 触发一个事件也可以作为异步的处理 &nbsp;当触发某个事件再来执行某件事（js底层解决异步常用方法）</strong></li></ul>
<p><span style="color:#f33b45;"><strong>深拷贝浅拷贝的理解</strong></span></p> 
<p><strong>浅拷贝：只是复制当前的对象，该对象内部的引用（Object,Array等堆内存数据）不能复制<br> 深拷贝：对对象内部的引用均复制，是创建一个新的实例<br> 简言之：是否复制了子对象，修改了克隆后的对象属性值，影响到原对象-浅拷贝 &nbsp;不影响-深拷贝</strong></p> 
<p><strong><span style="color:#f33b45;">常见的HTTP请求返回状态码</span></strong></p> 
<ul><li><strong>200成功</strong></li><li><strong>304请求浏览器缓存的内容</strong></li><li><strong>400语义有误，当前请求无法被服务器理解</strong></li><li><strong>401当前请求需要用户验证</strong></li><li><strong>404未找到</strong></li><li><strong>403服务器已经理解请求，但是拒绝执行它</strong></li><li><strong>500服务器错误</strong></li><li><strong>503服务器端暂时无法处理请求</strong></li></ul>
<p><strong>1开头的（信息类）：表示接收到请求并且继续处理，用于指定客户端应相应的某些动作<br> 2开头的（响应成功）：表示动作被成功接收，理解和接受。<br> 3开头的（重定向）：为了完成指定的动作，必须接受进一步处理，用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息<br> 4开头的（客户端错误类）：请求包含错误语法或不能正确执行<br> 5开头的（服务器端错误）：服务器遇到错误，无法完成请求</strong></p> 
<p><strong><span style="color:#f33b45;">html页面怎么解析的？它加载顺序是什么？</span></strong></p> 
<ol><li><strong>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件</strong></li><li><strong>浏览器开始载入html代码，如果发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件</strong></li><li><strong>浏览器又发出CSS文件的请求，服务器返回这个CSS文件</strong></li><li><strong>浏览器继续载入html中&lt;body&gt;部分的代码，并且CSS文件已经加载完成了，开始渲染页面</strong></li><li><strong>如果浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是异步渲染后面的代码</strong></li><li><strong>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码</strong></li><li><strong>如果浏览器发现了一个包含一行Javascript代码的&lt;script&gt;标签，会立即运行它</strong></li><li><strong>如果Javascript脚本执行了浏览器隐藏掉代码中的某个&lt;style&gt;（style.display=”none”），浏览器就得重新渲染这部分代码</strong></li><li><strong>如果这时用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径，那么浏览器就会向服务器请求了新的CSS文件，重新渲染页面</strong></li></ol>
<p><strong>总结：最好将无论内部或是外部JS文件放到所有html内容之后，这样会令用户感觉页面加载速度变快了，否则如果将所有外部文件（包括css和JS）引用都放到&lt;head&gt;中，意味着必须等到全部的JS代码都被下载解析和执行完毕后，才能开始呈现页面的内容（当浏览器遇到&lt;body&gt;）,这样会导致呈现页面时出现明显的延迟，二延迟期间的浏览器窗口将是一片空白。</strong></p> 
<p><strong><span style="color:#f33b45;">谈谈web攻击技术</span></strong></p> 
<ul><li><strong>XSS攻击</strong></li><li><strong>CSRF攻击</strong></li><li><strong>网络劫持攻击</strong></li><li><strong>控制台注入代码</strong></li><li><strong>钓鱼</strong></li></ul>
<p><strong><span style="color:#f33b45;">同步和异步的区别</span></strong></p> 
<p><strong>同步：阻塞的，A需要等待B完成任务后再开始任务<br> 异步：非阻塞的，A，B同时开始任务</strong></p> 
<p><strong>打个简单的比方：Ajax请求数据渲染页面操作，需要使用同步方式渲染，因为js执行的时间很短，几乎可以忽略不计，而Ajax请求需要等待时间，所以，需要等待Ajax请求完毕，收到响应信息后再渲染页面</strong></p> 
<p><span style="color:#f33b45;"><strong>解释a = b||c，fn&amp;&amp;fn()，a=(b,c)，a?b:c的作用或含义</strong></span></p> 
<p><strong><span style="color:#f33b45;">a = b||c：</span>和if(!b) {a=c}效果一致，如果b存在，把b的值赋给a，否则把c的值赋给a（短路求值，提升效率）</strong><br><span style="color:#f33b45;"><strong>fn&amp;&amp;fn()：</strong></span><strong>和上面的效果一样，但条件相反，如果fn不存在，则不执行，否则将执行</strong><strong>（短路求值，提升效率）</strong><br><span style="color:#f33b45;"><strong>a=(b,c)：</strong></span><strong>这里是逗号运算符的用法之一，先执行运算符左侧的操作数，然后再执行右侧的操作数，最后返回右侧操作数的值，即a=c</strong><br><span style="color:#f33b45;"><strong>a?b:c：</strong></span><strong>条件表达式（三元表达式），若a为真，返回b，若a为假，则返回c</strong></p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>前端面试题整合（JS基础篇）（二）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/04/13945217.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Wed, 04 Nov 2020 08:01:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/04/13945217.html</guid><description><![CDATA[
                    <p><strong><span style="color:#f33b45;">如何创建函数</span></strong></p> 
<ul><li><strong>第一种（函数声明）： &nbsp;function sum1(num1,num2){ &nbsp; &nbsp;return num1+num2; } </strong></li><li><strong>第二种（函数表达式）： var sum2 = function(num1,num2){ &nbsp; &nbsp;return num1+num2; } </strong></li><li><strong>第三种（函数对象方式）： var sum3 = new Function("num1","num2","return num1+num2");</strong></li></ul>
<p><strong><span style="color:#f33b45;">三种弹窗的单词以及三种弹窗的功能</span></strong></p> 
<pre><code class="language-javascript">1.alert  
//弹出对话框并输出一段提示信息  
    function ale() {  
        //弹出一个对话框  
        alert("提示信息！");  
  
    }  
  
2.confirm
    //弹出一个询问框，有确定和取消按钮  
    function firm() {  
        //利用对话框返回的值 （true 或者 false）  
        if (confirm("你确定提交吗？")) {  
            alert("点击了确定");  
        }  
        else {  
            alert("点击了取消");  
        }  
  
    }  
  
3.prompt
    //弹出一个输入框，输入一段文字，可以提交  
    function prom() {  
        var name = prompt("请输入您的名字", ""); //将输入的内容赋给变量 name ，  
  
        //这里需要注意的是，prompt有两个参数，前面是提示的话，后面是当对话框出来后，在对话框里的默认值  
        if (name)//如果返回的有内容  
        {  
            alert("欢迎您：" + name)  
        }  
    }
</code></pre> 
<p><strong><span style="color:#f33b45;">JavaScript的循环语句</span></strong></p> 
<p><strong>for,for..in,while,do...while</strong></p> 
<p><strong><span style="color:#f33b45;">减低页面加载时间的方法</span></strong></p> 
<p><strong>1、压缩css、js文件<br> 2、合并js、css文件，减少http请求<br> 3、外部js、css文件放在最底下<br> 4、减少dom操作，尽可能用变量替代不必要的dom操作</strong></p> 
<p><span style="color:#f33b45;"><strong>对象有哪些原生方法</strong></span></p> 
<ul><li><strong>Object.hasOwnProperty( ) 检查属性是否被继承</strong></li><li><strong>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型</strong></li><li><strong>Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性</strong></li><li><strong>Object.toLocaleString( ) 返回对象的本地字符串表示 </strong></li><li><strong>Object.toString( ) 定义一个对象的字符串表示</strong></li><li><strong>Object.valueOf( ) 指定对象的原始值</strong></li></ul>
<p><strong><span style="color:#f33b45;">JS 怎么实现一个类。怎么实例化这个类</span></strong></p> 
<p><strong>严格来讲js中并没有类的概念，不过js中的函数可以作为构造函数来使用，通过new来实例化，其实函数本身也是一个对象。</strong></p> 
<p><strong><span style="color:#f33b45;">外部JS文件出现中文字符，会出现什么问题，怎么解决</span></strong></p> 
<p><strong>会出现乱码，加charset=”utf-8”;</strong></p> 
<p><strong><span style="color:#f33b45;">target与currentTarget区别</span></strong></p> 
<p><strong>target在事件流的目标阶段；<br> currentTarget在事件流的捕获，目标及冒泡阶段。<br> 只有当事件流处在目标阶段的时候，两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。</strong></p> 
<p><span style="color:#f33b45;"><strong>DOM的增删改查操作</strong></span></p> 
<p><strong>创建新节点</strong></p> 
<ul><li><strong>createDocumentFragment() &nbsp; &nbsp;//创建一个DOM片段</strong></li><li><strong>createElement() &nbsp; //创建一个具体的元素</strong></li><li><strong>createTextNode() &nbsp; //创建一个文本节点</strong></li></ul>
<p><strong>添加、移除、替换、插入</strong></p> 
<ul><li><strong>appendChild()</strong></li><li><strong>removeChild()</strong></li><li><strong>replaceChild()</strong></li><li><strong>insertBefore() //在已有的子节点前插入一个新的子节点</strong></li></ul>
<p><strong>查找</strong></p> 
<ul><li><strong>getElementsByTagName() &nbsp; &nbsp;//通过标签名称</strong></li><li><strong>getElementsByName() &nbsp; &nbsp;//通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</strong></li><li><strong>getElementById() &nbsp; &nbsp;//通过元素Id，唯一性</strong></li><li><strong>queryselector()//es6新增的，可选择id（#ele），class（.ele），tagName（ele）等</strong></li></ul>
<p><strong><span style="color:#f33b45;">documen.write和 innerHTML区别</span></strong></p> 
<p><strong>document.write只能重绘整个页面<br> innerHTML可以重绘页面的一部分</strong></p> 
<p><strong><span style="color:#f33b45;">Ajax 解决浏览器缓存问题？</span></strong></p> 
<p><strong>1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")<br> 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")<br> 3、在URL后面加上一个随机数： "fresh=" + Math.random();<br> 4、在URL后面加上时间戳："nowtime=" + new Date().getTime();<br> 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</strong></p> 
<p><strong><span style="color:#f33b45;">bind，call和apply的区别</span></strong></p> 
<p><strong>bind方法: </strong></p> 
<ul><li><strong>语法：bind(thisObj，Object1,Object2...) </strong></li><li><strong>定义：调用一个对象的一个方法，以另一个对象替换当前对象。 </strong></li><li><strong><strong>说明： </strong>bind<strong>方法会返回执行上下文被改变的函数而不会立即执行</strong></strong></li></ul>
<p><strong>call方法: </strong></p> 
<ul><li><strong>语法：call(thisObj，Object1,Object2...) </strong></li><li><strong>定义：调用一个对象的一个方法，以另一个对象替换当前对象。 </strong></li><li><strong><strong>说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 &nbsp;如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</strong></strong></li></ul>
<p><strong>apply方法： &nbsp;</strong></p> 
<ul><li><strong>语法：apply(thisObj，[argArray]) </strong></li><li><strong>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</strong></li><li><strong>说明： &nbsp;如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 &nbsp;如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</strong></li></ul>
<p><strong><span style="color:#f33b45;">javascript的本地对象，内置对象和宿主对象</span></strong></p> 
<ul><li><strong>本地对象为array obj regexp等可以new实例化</strong></li><li><strong>内置对象为gload Math 等不可以实例化的</strong></li><li><strong>宿主为浏览器自带的document,window 等</strong></li></ul>
<p><strong><span style="color:#f33b45;">列举浏览器对象模型BOM里常用的对象，并列举window对象的常用方法</span></strong></p> 
<p><strong>对象：window, document, location, screen, history, navigator<br> 方法：alert(), confirm(), prompt(), open(), close()&nbsp;</strong></p> 
<p><strong><span style="color:#f33b45;">iframe的优缺点</span></strong></p> 
<p><strong>优点：<br> 1. 解决加载缓慢的第三方内容如图标和广告等的加载问题<br> 2. Security sandbox<br> 3. 并行加载脚本<br> 缺点：<br> 1. iframe会阻塞主页面的Onload事件<br> 2. 即时内容为空，加载也需要时间<br> 3. 没有语意</strong></p> 
<p><strong><span style="color:#f33b45;">Cookie的弊端</span></strong></p> 
<ul><li><strong>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</strong></li><li><strong>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</strong></li><li><strong>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</strong></li></ul>
<p><strong><span style="color:#f33b45;">谈谈js精度问题</span></strong></p> 
<p><strong>由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript是一种弱类型的脚本语言，没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失，c#的decimal和Java的BigDecimal之所以没有出现精度差异，只是因为在其内部作了相应处理，把这种精度差异给屏蔽掉了，而javascript是一种弱类型的脚本语言，本身并没有对计算精度做相应的处理，这就需要我们另外想办法处理了。&nbsp;所以0.1+0.2！==0.3。<br> 为了避免产生精度差异，把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。</strong></p> 
<p><strong><span style="color:#f33b45;">js哪些值会强制转换为false</span></strong></p> 
<p><strong>在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所 有值都转为 true，包括所有对象。</strong></p> 
<p><strong><span style="color:#f33b45;">link添加预加载预渲染</span></strong></p> 
<p><strong>预加载：强制浏览器请求资源，并且不会阻塞 onload 事件， 可以使用以下代码开启预加载<br> &lt;link rel="preload" href="http://test.com"&gt;<br> 预渲染:可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染<br> &lt;link rel="prerender" href="http://test.com"&gt;&nbsp;</strong></p>
                ]]></description></item><item><title>前端面试题整合（JS基础篇）（一）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/03/13945218.html</link><dc:creator>DieHunter1024</dc:creator><author>DieHunter1024</author><pubDate>Tue, 03 Nov 2020 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/11/03/13945218.html</guid><description><![CDATA[
                    <p><span style="color:#f33b45;"><strong>typeof返回的数据类型</strong></span></p> 
<ul><li><strong>undefined</strong></li><li><strong>string</strong></li><li><strong>boolean</strong></li><li><strong>number</strong></li><li><strong>object</strong></li><li><strong>function</strong></li><li><strong>symbol</strong></li></ul>
<p><span style="color:#f33b45;"><strong>js数据类型</strong></span></p> 
<p><strong>基本六种</strong></p> 
<ul><li><strong>string &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;字符串</strong></li><li><strong>number &nbsp; &nbsp; &nbsp; &nbsp; 数字</strong></li><li><strong>boolean &nbsp; &nbsp; &nbsp; &nbsp; 布尔</strong></li><li><strong>Null &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 空</strong></li><li><strong>undefined &nbsp; &nbsp; &nbsp;未定义</strong></li><li><strong>Object &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 引用类型</strong></li><li><strong>es6新增 symbol类型</strong></li></ul>
<p><strong><span style="color:#f33b45;">”==”和“===”的区别</span></strong></p> 
<p><strong>前者会强制转换类型 后者不会</strong></p> 
<p><strong><span style="color:#f33b45;">有哪些强制类型转换和隐式类型转换</span></strong></p> 
<p><strong>强制：parseInt(),parseFloat(),Number()<br> 隐式：== ,!=</strong></p> 
<p><span style="color:#f33b45;"><strong>解决js兼容性问题</strong></span></p> 
<ul><li><strong>使用 event对象</strong></li></ul>
<pre><code class="language-javascript">function eventHandler(event) {
    event = event || window.event
}</code></pre> 
<ul><li><strong>获取滚动条属性</strong></li></ul>
<pre><code class="language-javascript">var scrollTop = document.documentElment.scrollTop || document.body.scrollTop</code></pre> 
<ul><li><strong>阻止浏览器默认行为</strong></li></ul>
<pre><code class="language-javascript">        function eventHandler(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        }</code></pre> 
<ul><li><strong>事件冒泡</strong></li></ul>
<pre><code class="language-javascript">
        function eventHandler(event) {
            if (event.stopPropagation) {
                event.stopPropagation()
            } else {
                event.cancelBubble()
            }
        }</code></pre> 
<p><strong><span style="color:#f33b45;">事件流</span></strong></p> 
<p><strong>冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。就子元素向父元素触发<br> 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。 即从DOM树的根到叶子。就是父元素向子元素触发 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 优点：<br> （1）可以大量节省内存占用<br> （2）可以实现当新新增对象时，无需在对其进行绑定</strong></p> 
<p><span style="color:#f33b45;"><strong>事件委托</strong></span></p> 
<p><strong>可以为同样元素绑定多次同一事件<br> 可以确定是冒泡还是捕获<br> 动态创建元素，可以创建元素的函数体外部为其添加<br> 把某个事件加到父元素上&nbsp;提高程序执行效率</strong></p> 
<p><strong><span style="color:#f33b45;">浏览器的事件机制</span></strong></p> 
<p><strong>事件捕获阶段---处于目标阶段&nbsp;---&nbsp;事件的冒泡阶段----&nbsp;事件的默认阶段</strong></p> 
<p><strong><span style="color:#f33b45;">事件绑定和普通事件的区别</span></strong></p> 
<ul><li><strong>普通添加事件的方法： </strong></li></ul>
<pre><code class="language-javascript">var btn = document.getElementById("ele");
 btn.onclick = function(){
 &nbsp; &nbsp; alert(1); 
}
 btn.onclick = function(){
 &nbsp; &nbsp; alert(2); 
} </code></pre> 
<p><strong>执行上面的代码只会alert&nbsp; &nbsp;2&nbsp;</strong></p> 
<ul><li><strong>事件绑定方式添加事件：</strong></li></ul>
<pre><code class="language-javascript">var btn = document.getElementById("ele");
btn.addEventListener("click",function(){
    alert(1);
},false);
btn.addEventListener("click",function(){
    alert(2);
},false);

</code></pre> 
<p><strong>执行上面的代码会先alert 1 再 alert 2&nbsp;</strong></p> 
<ul><li><strong>普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定 &nbsp; （addEventListener）方式添加事件可以添加多个。</strong></li><li><strong>addEventListener不兼容低版本IE</strong></li><li><strong>普通事件无法取消</strong></li><li><strong>addEventLisntener还支持事件冒泡+事件捕获</strong></li></ul>
<p><strong><span style="color:#f33b45;">eval的理解</span></strong></p> 
<ul><li><strong>可以将字符串生成语句执行，一般执行动态js语句</strong></li><li><strong>eval的使用场合：有时候我们预先不知道要执行什么语句，只有当条件和参数给时才知到执行什么语句，这时候eval就派上用场了 &nbsp; &nbsp; &nbsp; &nbsp; eval和json.parse的谁更高效？</strong></li><li><strong>是json.parse</strong></li><li><strong>因为evel他是转化在解析而json.parse是直接解析</strong></li><li><strong>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</strong></li></ul>
<p><span style="color:#f33b45;"><strong>数组的方法</strong></span></p> 
<ul><li><strong>push() 从队尾添加,改变原数组 </strong></li><li><strong>pop() &nbsp; 移除数组末尾最后一项,返回移除的项 &nbsp;</strong></li><li><strong>shift() &nbsp; &nbsp;删除数组第一项,返回删除元素的值,如果数组为空返回undefined &nbsp;</strong></li><li><strong>unshift() 添加头部,改变原数组 </strong></li><li><strong>sort() &nbsp;数组排序,参数为一个匿名函数,如果匿名函数返回正值,则升序排列,反之相反 </strong></li><li><strong>reverse() 翻转数组项的顺序 原数组改变 </strong></li><li><strong>concat() 将参数添加到原数组,将参数添加到数组的末尾,并返回一个新数组,不改变原数组 </strong></li><li><strong>slice() &nbsp; 返回原数组中指定开始下标到结束下标之间的项组成的新数组,slice接受两个参数,如果致谢一个参数,slice方法返回从该参数到数组末尾的所有项,如果有两个参数,该方法返回起始位置和结束位置之间的项,但不包括结束位置的项 </strong></li><li><strong>splice() &nbsp; &nbsp;可以实现删除,插入,替换 &nbsp; 删除(可以删除任意属相的项,只需要指定2个参数,要删除的第一项的位置和要删除的项) &nbsp;插入,替换(可以向指定位置插入任意数量的项,只需提供3个参数:起始位置,0(要删除的项),插入的项),splice()方法始终都会返回一个数组,数组中包括从原数组中删除的项,如果没有删除任何项则返回一个空数组 &nbsp;</strong></li><li><strong>map() &nbsp;对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组 &nbsp;</strong></li><li><strong>some() 判断数组中是否存在满足条件的项,只要有一项满足条件,就返回true &nbsp;</strong></li><li><strong>every() &nbsp; &nbsp;判断数组中每一项都是否满足条件,只有所有选项都满足条件,才会返回true &nbsp;</strong></li><li><strong>filter() 过滤功能,数组中的每一项运行给定函数,返回满足过滤条件组成的数组 &nbsp;</strong></li><li><strong>forEach() 对数组进行循环遍历,对数组中的每一项运行给定函数,这个方法没有返回值,参数都是function类型,默认有传参功能,参数分别是,便利的数组内容,对应的索引,数组本身 </strong></li><li><strong>indexOf() 接受两个参数,要查找的项和表示查找起点位置的索引,返回查找的项在数组的位置,没找到的情况下返回-1</strong></li></ul>
<p><span style="color:#f33b45;"><strong>伪数组转成真数组的方法</strong></span></p> 
<ul><li><strong>Array.from() </strong></li><li><strong>Array.prototype.slice.call();</strong></li><li><strong>循环并push到新数组</strong></li><li><strong>解构赋值：list=[..._list]（es6）</strong></li></ul>
<p><strong><span style="color:#f33b45;">window.onload与$(document).ready()的区别</span></strong></p> 
<ul><li><strong>执行时间 &nbsp;window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 &nbsp;$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕.</strong></li><li><strong>编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 $(document).ready()可以同时编写多个，并且都可以得到执行 </strong></li><li><strong>简化写法 window.onload没有简化写法 $(document).ready(function(){})可以简写成$(function(){});</strong></li></ul>
<p><strong><span style="color:#f33b45;">this的理解</span></strong></p> 
<p><strong>this代表函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，this的值会发生变化。但有一个总的原则就是，谁调用它，它就指向谁。一般在这几种情况下会用到它.</strong></p> 
<ul><li><strong>单纯的函数调用；</strong></li><li><strong>作为对象方法的调用；</strong></li><li><strong>作为构造函数调用；</strong></li><li><strong>apply调用，apply（）是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，当它的参数为空时，默认调用全局对象</strong></li></ul>
<p><strong><span style="color:#f33b45;">跨域机制是什么，解决方式</span></strong></p> 
<p><strong>因为同源策略的诞生,只能访问相同端口,协议,域名的网站,所以我们要进行跨域，以下是常见解决方式</strong></p> 
<ul><li><strong>通过JsonP(动态创建一个script标签,通过src属性,设置一个端口号,通过接口上的某个参数向服务器传送一个函数,通过之歌回调函数接受服务器返回的数据)</strong></li><li><strong>通过修改document.domain来跨子域</strong></li><li><strong>使用window.name来进行跨域</strong></li><li><strong>cors </strong></li><li><strong>反向代理</strong></li><li><strong>webSocket</strong></li></ul>
<p><strong><span style="color:#f33b45;">get和post的区别</span></strong></p> 
<p><strong>共同点：</strong></p> 
<ul><li><strong>无论是get还是post，都是可以发送数据，也可以接受数据</strong></li></ul>
<p><strong>区别：</strong></p> 
<ul><li><strong>get是以url方式传递数据，而post是以http请求中的body部分传递数据 ，所以说post更安全</strong></li><li><strong>get传递数据时，直接再浏览器地址栏可以看到；而post可以使用开发者工具中看到</strong></li><li><strong>get传递数据，中文不会被编码或有可能出现乱码，而post不会</strong></li><li><strong>get在IE下会走缓存，而post不会</strong></li></ul>
<p><strong><span style="color:#f33b45;">js如何创建一个对象</span></strong></p> 
<p><strong>对象的字面量创建 var obj= {}<br> 创建实例对象 var obj = new Object（）<br> 构造函数的模式 function fn(){}, new fn()<br> 工厂模式 用一个函数，通过传参数返回对象</strong></p> 
<pre><code class="language-javascript">function createObj(name,age,family) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.family = family;
    return o;
}</code></pre> 
<p><br><strong>原型模式</strong></p> 
<pre><code class="language-javascript">function Obj() {
}

Obj.prototype.name = "Obj";
Obj.prototype.age = 10;
var obj= new Obj()</code></pre> 
<p><br><strong>混合模式</strong></p> 
<pre><code class="language-javascript">function createObj(name,age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return o;
}

createObj.prototype.name = "Obj";
createObj.prototype.age = 10;
var _obj= new createObj()</code></pre> 
<p><span style="color:#f33b45;"><strong>null，undefined 的区别</strong></span></p> 
<ul><li><strong>null表示一个对象是“没有值”的值，也就是值为“空”；</strong></li><li><strong>undefined表示一个变量声明了没有初始化(赋值)；</strong></li><li><strong>undefined不是一个有效的JSON，而null是；</strong></li><li><strong>undefined的类型(typeof)是undefined； &nbsp;null的类型(typeof)是object；</strong></li><li><strong>Javascript将未赋值的变量默认值设为undefined； &nbsp;Javascript不会将变量设为null。null是用来让程序员表明某个用var声明的变量时没有值的。</strong></li><li><strong>null == undefined // true&nbsp; &nbsp; null === undefined // false</strong></li></ul>
<p><span style="color:#f33b45;"><strong>对</strong></span><span style="color:#f33b45;"><strong>JSON 的了解</strong></span></p> 
<p><strong>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br> 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br> JSON字符串转换为JSON对象: &nbsp;</strong></p> 
<ul><li><strong>var obj =eval('('+ str +')');</strong></li><li><strong>var obj = str.parseJSON();</strong></li><li><strong>var obj = JSON.parse(str);</strong></li></ul>
<p><strong>JSON对象转换为JSON字符串：</strong></p> 
<ul><li><strong>var last=obj.toJSONString();</strong></li><li><strong>var last=JSON.stringify(obj);</strong></li></ul>
<p><strong><span style="color:#f33b45;">js延迟加载的方式有哪些？</span></strong></p> 
<p><strong>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</strong></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<div id="gtx-trans"> 
 <div class="gtx-trans-icon">
  &nbsp;
 </div> 
</div>
                ]]></description></item><item><title>前端面试题整合（基础篇）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/30/13908175.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Fri, 30 Oct 2020 09:42:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/30/13908175.html</guid><description><![CDATA[
                    <ul><li><span style="color:#f33b45;"><strong>浏览器的内核</strong></span> <p style="margin-left:0cm;"><strong>IE: trident内核，Firefox：gecko内核，Safari:webkit内核，Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核，Chrome:Blink(基于webkit，Google与Opera Software共同开发)</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">HTML中的Doctype有什么作用</span><br> 此标签可告知浏览器文档使用哪种&nbsp;HTML&nbsp;或&nbsp;XHTML&nbsp;规范。（重点：告诉浏览器按照何种规范解析页面）</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">div+css的布局较table布局有什么优点</span><br> 改版的时候更方便 只要改css文件。 页面加载速度更快、结构化清晰、页面显示简洁。 表现与结构相分离。 易于优化（seo）搜索引擎更友好，排名更容易靠前</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">img的alt与title有何异同？ strong与em的异同？</span><br> alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下会在没有title时把alt当成 tool tip显示)<br> title(tool tip):该属性为设置该属性的元素提供建议性的信息。<br> strong:粗体强调标签，强调，表示内容的重要性。<br> em:斜体强调标签，更强烈强调，表示内容的强调点。</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">渐进增强和优雅降级之间的不同</span><br> 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">为什么利用多个域名来存储网站资源会更有效？</span><br> CDN缓存更方便<br> 突破浏览器并发限制<br> 节约cookie带宽<br> 节约主域名的连接数，优化页面响应速度<br> 防止不必要的安全问题</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">cookies，sessionStorage和localStorage的区别</span><br> sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">src与href的区别</span><br> 简单来讲，src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</strong><br><strong><span style="color:#f33b45;">src</span>：src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。<br> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。<br><span style="color:#f33b45;">harf</span>：href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 &lt;link href=”common.css” rel=”stylesheet”/&gt; 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">什么是微格式，谈谈理解</span><br> 微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</span><br> dns缓存，cdn缓存，浏览器缓存，服务器缓存</strong></p> </li><li> <p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>优化大型网站加载图片方案</strong></span><br><strong>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</strong></p> </li><li> <p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>HTML结构的语义化</strong></span><br><strong>html本身是没有表现的，我们看到例如&lt;h1&gt;是粗体，字体大小2em，加粗；&lt;strong&gt;是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">有哪项方式可以对一个DOM设置它的CSS样式</span><br> 外部样式表，引入一个外部css文件<br> 内部样式表，将css代码放在 &lt;head&gt; 标签内部<br> 内联样式，将css样式直接定义在 HTML 元素内部</strong></p> </li><li> <p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>CSS都有哪些选择器</strong></span><br><strong>派生选择器（用HTML标签申明）<br> id选择器（用DOM的ID申明）<br> 类选择器（用一个样式类名申明） </strong><br><strong>属性选择器（a[rel = "external"]）<br> 除了前3种基本选择器，还有一些扩展选择器，<br> 包括 后代选择器（利用空格间隔，比如div .a{ &nbsp;}）<br> 相邻选择器（利用加号间隔，h1 + p）<br> 群组选择器（利用逗号间隔，比如p,div,#a{ &nbsp;}）<br> 通配符选择器（ * ）<br> 伪类选择器（a: hover, li: nth - child）</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内</span><br> 设置display属性为none，或者设置visibility属性为hidden<br> 设置宽高为0，设置透明度为0，设置z-index位置在-1000em</strong></p> </li><li> <p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>超链接访问过后hover样式就不出现的问题是什么？如何解决？</strong></span><br><strong>被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）</strong></p> </li><li> <p style="margin-left:0cm;"><strong><span style="color:#f33b45;">什么是Css Hack？ie6,7,8的hack分别是什么？</span><br> 针对不同的浏览器写不同的CSS code的过程，就是CSS hack。<br> 示例如下： &nbsp; </strong></p> <pre><code class="language-css">   #test{   
        width:300px;   
        height:300px;   
        background-color:blue;      /*firefox*/
        background-color:red\9;      /*all ie*/
        background-color:yellow;    /*ie8*/
        +background-color:pink;        /*ie7*/
        _background-color:orange;       /*ie6*/    }  
        :root #test { background-color:purple\9; }  /*ie9*/
@media all and (min-width:0px)
     { #test {background-color:black;} }  /*opera*/
@media screen and (-webkit-min-device-pixel-ratio:0)
{ #test {background-color:gray;} }       /*chrome and safari*/
</code></pre> <p>&nbsp;</p> </li><li> <p><strong><span style="color:#f33b45;">行内元素和块级元素的具体区别是什么？</span></strong><br><strong>块级元素(block)特性： 总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示; 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;<br> 内联元素(inline)特性： 和相邻的内联元素在同一行;</strong></p> </li><li> <p><strong><span style="color:#f33b45;">什么是外边距重叠？有什么效果</span><br> 外边距重叠就是margin-collapse。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br><span style="color:#f33b45;">折叠结果遵循下列计算规则</span>： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。</strong></p> </li><li> <p><strong><span style="color:#f33b45;">rgba()和opacity的透明效果有什么不同？</span><br> rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度， 而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>水平垂直居中一个浮动元素</strong></span></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label0http:/www.tuicool.com/articles/_blank">方法一：</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label0http:/www.tuicool.com/articles/_blank">position</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label0http:/www.tuicool.com/articles/_blank">加</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label0http:/www.tuicool.com/articles/_blank">margin</a></strong></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label1http:/www.tuicool.com/articles/_blank">方法二：</a>&nbsp;<a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label1http:/www.tuicool.com/articles/_blank">diaplay:table-cell</a></strong></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label2http:/www.tuicool.com/articles/_blank">方法三：</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label2http:/www.tuicool.com/articles/_blank">position</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label2http:/www.tuicool.com/articles/_blank">加</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label2http:/www.tuicool.com/articles/_blank"> transform</a></strong></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label3http:/www.tuicool.com/articles/_blank">方法四：</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label3http:/www.tuicool.com/articles/_blank">flex;align-items: center;justify-content: center</a></strong></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label4http:/www.tuicool.com/articles/_blank">方法五：</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label4http:/www.tuicool.com/articles/_blank">display:flex;margin:auto</a></strong></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label5http:/www.tuicool.com/articles/_blank">方法六：纯</a><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label5http:/www.tuicool.com/articles/_blank">position</a></strong></p> <p><strong><a href="http://www.cnblogs.com/xianyulaodi/p/5863305.html_label6http:/www.tuicool.com/articles/_blank">方法七：兼容低版本浏览器，不固定宽高</a></strong></p> </li><li> <p><span style="color:#f33b45;"><strong>讲一下你对盒模型的了解</strong></span><br><strong>有padding、margin、border、content属性<br> box-sizing: content-box 是W3C盒子模型，元素的width和height属性只包含内容content部分，不包含内边距padding和边框border部分。<br> box-sizing: border-box 是IE盒子模型，元素的width和height属性同时包含内容content，内边距padding和边框border部分</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>position定位</strong></span><br><strong>Relitive: 相对于自身,会指引子元素相对于他自身进行定位<br> Absolute: 根据父元素的relitive进行定位<br> Fixed:现对于window窗口定位</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>rem原理与em/ vw/vh 区别</strong></span><br><strong>Rem是基于根元素的字体大小发生改变,而em是基于body的字体大小发生改变<br> 1.因为html5和css3引入视口的概念来代替显示器的物理尺寸。通过在meta标签上的设置，视口的长宽可以跟设备的物理分辨率相等，也可以不相等（以便手机上可以实现用两个手指来放大会缩小页面），可根据需要灵活掌握。在PC中，视口的长宽则是跟浏览器窗口的物理分辨率恒等的。<br> 2. 1vw等于视口宽度（viewport width）的百分之一，也就是说100vw就是视口的宽度。同理，1vh等于视30px改成5vw，意思就是窗口宽度的5%，同理10vw。<br> 3.不过由于vw和vh是css3才支持的长度单位，所以在不支持css3的浏览器中是无效的口高度（viewport height）的百分之一。</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>Css3的动画</strong></span><br><strong>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>Sass、LESS是什么，优点</strong></span><br><strong>他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。<br> 例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。<br><span style="color:#f33b45;">优点：</span><br> 结构清晰，便于扩展。<br> 可以方便地屏蔽浏览器私有语法差异。<br> 封装对浏览器语法差异的重复处理，减少无意义的机械劳动。<br> 可以轻松实现多重继承。<br> 完全兼容 CSS 代码，可以方便地应用到老项目中。<br> LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>display:none与visibility:hidden的区别是什么？</strong></span><br><strong>display : 隐藏对应的元素但不挤占该元素原来的空间。<br> visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br> 即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</strong></p> </li><li> <p><strong><span style="color:#f33b45;">CSS中link和@import的区别</span><br> Link属于html标签，而@import是CSS中提供的<br> 在页面加载的时候，link会同时被加载，而@import引用的CSS会在页面加载完成后才会加载引用的CSS<br> @import只有在ie5以上才可以被识别，而link是html标签，不存在浏览器兼容性问题 Link引入样式的权重大于@import的引用（@import是将引用的样式导入到当前的页面中）</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>BFC是什么</strong></span><br><strong>BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题 BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>html常见兼容性问题</strong></span><br><strong>1.双边距BUG float引起的 &nbsp;使用display<br> 2.3像素问题 使用float引起的 使用dislpay:inline -3px &nbsp;<br> 3.超链接hover 点击后失效 &nbsp;使用正确的书写顺序 link visited hover active<br> 4.Ie z-index问题 给父级添加position:relative<br> 5.Png 透明 使用js代码 改<br> 6.Min-height 最小高度 ！Important 解决’<br> 7.select 在ie6下遮盖 使用iframe嵌套<br> 8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）<br> 9.IE5-8不支持opacity，解决办法： .opacity { &nbsp; &nbsp; opacity: 0.4 &nbsp; &nbsp; filter: alpha(opacity=60); /* for IE5-7 */ &nbsp; &nbsp; -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /* for IE 8*/ }<br> 10. IE6不支持PNG透明背景，解决办法: IE6下使用gif图片</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>行内元素有哪些?块级元素有哪些?空(void)元素有哪些？</strong></span><br><strong><span style="color:#f33b45;">块级元素</span>：address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是css layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容） noscript – ）可选脚本内容（对于不支持script的浏览器显示此内容） ol – 排序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 非排序列表<br><span style="color:#f33b45;">行内元素</span>:a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) big – 大字体 br – 换行 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 label – 表格标签 s – 中划线(不推荐) select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 var – 定义变量<br><span style="color:#f33b45;">知名的空元素</span>：&lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt;鲜为人知的是： &lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;command&gt; &lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt;</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>前端页面有哪三层构成</strong></span><br><strong>结构层 Html 表示层 CSS 行为层 js</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>CSS哪些属性可以继承？</strong></span><br><strong>可继承： font-size font-family color, UL LI DL DD DT;<br> 不可继承 ：border padding margin width height ;</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>CSS优先级算法（权重）</strong></span><br><strong>优先级就近原则，样式定义最近者为准<br> 载入样式以最后载入的定位为准<br> !important&gt; 内联&nbsp; &gt;&nbsp; id &gt; class &gt; tag</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>高度自适应，宽度是高度的一半，如何布局</strong></span><br><strong>利用padding-top/bottom/left/right属性在设置为百分比时按照父元素的宽度来进行设置，可以通过设置padding-top/bottom：100%；padding-left/right:50%;将元素撑开，使用需注意设置父元素的宽度，特别是在父元素的宽度是继承的情况下，也可更具情况只设置父元素的宽度而不设置高度来隐藏父元素；</strong></p> </li><li> <p><span style="color:#f33b45;"><strong>类似圣杯布局的多种代码方式</strong></span><br><strong>圣杯布局是一种很常见的css布局。<br> 要求：<br> 1、上部和下部各自占领屏幕所有宽度。<br> 2、上下部之间的部分是一个三栏布局。<br> 3、三栏布局两侧宽度不变，中间部分自动填充整个区域。<br> 4、中间部分的高度是三栏中最高的区域的高度。</strong></p> <pre><code class="language-html">浮动实现
外层框架
&lt;div class="header"&gt;这里是头部&lt;/div&gt;
&lt;div class="container"&gt;&lt;/div&gt;
&lt;div class="footer"&gt;这里是底部&lt;/div&gt;
.header,.footer{
    height:200px;
    width:100%;
    background:red;
}
.container{
    padding-left:200px;
    padding-right:300px;
}
填充三栏
这一步骤，首先给底部区域清除浮动，防止跟随上边的区域一起浮动。
另外：把中，左，右三个区域设置成度浮动。给左右两块区域固定的宽度，中间部分的宽度设置成100%。
这样实现下来，因为浮动的关系，[middle]会占据[container]的所有部分，而左右两块区域都会被挤到下面，但是，由于第一步设置了内边距的关系，[container]的左右各剩余了一块区域，且宽度与左右区域相同。
&lt;div class="header"&gt;这里是头部&lt;/div&gt;
&lt;div class="container"&gt;
    &lt;div class="middle"&gt;中间部分&lt;/div&gt;
    &lt;div class="left"&gt;左边&lt;/div&gt;
    &lt;div class="right"&gt;右边&lt;/div&gt;
&lt;/div&gt;
&lt;div class="footer"&gt;这里是底部&lt;/div&gt;

.header,.footer{
    height:40px;
    width:100%;
    background:red;
}
.footer{
    clear:both;
}
.container{
    padding-left:200px;
    padding-right:300px;
}.container div{
    float:left;
}
.middle{
    width:100%;
    background:yellow;
}
.left{
    width:200px;
    background:pink;
}
.right{
    width:300px;
    background:aqua;
}
移动左侧区域
接下来要做的就是把左右两块区域挪到空出来的内边距空间里去。
先移动左边，新加一个样式 margin-left:-100%。这样一来，因为浮动关系，就把左边块上移到了[middle]左侧，与其交织在一起，而右侧栏就自动往左移动。然后再给左侧栏一个偏移量，偏移量恰好是其宽度，这一步要给[container]的position设成relative
&lt;div class="header"&gt;这里是头部&lt;/div&gt;
&lt;div class="container"&gt;
    &lt;div class="middle"&gt;中间部分&lt;/div&gt;
    &lt;div class="left"&gt;左边&lt;/div&gt;
    &lt;div class="right"&gt;右边&lt;/div&gt;
&lt;/div&gt;
&lt;div class="footer"&gt;这里是底部&lt;/div&gt;
.header,.footer{
    height:40px;
    width:100%;
    background:red;
}
.footer{
    clear:both;
}
.container{
    padding-left:200px;
    padding-right:300px;
}
.container div{
    postion:relative;
    float:left;
}
.middle{
    width:100%;
    background:yellow;
}
.left{
    width:200px;
    background:pink;
    margin-left:-100%;
    right:200px;
}
.right{
    width:300px;
    background:aqua;
}
移动右边
同上一步的原理一样，把右侧区域也给弄上去，设置负外边距和本身宽度相同就行了。
&lt;div class="header"&gt;这里是头部&lt;/div&gt;
&lt;div class="container"&gt;
    &lt;div class="middle"&gt;中间部分&lt;/div&gt;
    &lt;div class="left"&gt;左边&lt;/div&gt;
    &lt;div class="right"&gt;右边&lt;/div&gt;
&lt;/div&gt;
&lt;div class="footer"&gt;这里是底部&lt;/div&gt;

.header,.footer{
    height:40px;
    width:100%;
    background:red;
}
.footer{
    clear:both;
}
.container{
    padding-left:200px;
    padding-right:300px;
}
.container div{
    postion:relative;
    float:left;
}
.middle{
    width:100%;
    background:yellow;
}
.left{
    width:200px;
    background:pink;
    margin-left:-100%;
    right:200px;
}
.right{
    width:300px;
    background:aqua;
    margin-right:-300px;
}

 


flexbox弹性盒子实现
弹性盒子用来实现圣杯布局特别简单。只需要把中间的部分用flex布局即可。
&lt;div class="header"&gt;这里是头部&lt;/div&gt;
&lt;div class="container"&gt;
    &lt;div class="left"&gt;左边&lt;/div&gt;
    &lt;div class="middle"&gt;中间部分&lt;/div&gt;
    &lt;div class="right"&gt;右边&lt;/div&gt;
&lt;/div&gt;
&lt;div class="footer"&gt;这里是底部&lt;/div&gt;

.header,.footer{
    height:40px;
    width:100%;
    background:red;
}
.container{
    display: flex;
}
.middle{
    flex: 1;
    background:yellow;
}
.left{
width:200px;
    background:pink;
}
.right{
    background: aqua;
    width:300px;
}
很简单，在写html的时候，因为不再涉及到浮动，只需要按照左中右的顺序来写就可以了。左右两块区域的宽度写死，把中间的区域的flex属性设置成1就可以了。
css grid网格
grid是一种新的布局方式，截止2018年初，绝大多数浏览器都已经支持css grid。
其原理就是把页面的区域划分成一个一个的网格，就和围棋的棋盘一样。
用网格来解决圣杯问题，可以摆脱弹性盒子时需要格外加一个[container]的问题，也就是左中右三款区域不需要在他们外边包装一个额外的div。
&lt;div id="header"&gt;header&lt;/div&gt;
&lt;div id="left"&gt;left&lt;/div&gt;
&lt;div id="middle"&gt;middle&lt;/div&gt;
&lt;div id="right"&gt;right&lt;/div&gt;     
&lt;div id="footer"&gt;footer&lt;/footer&gt;&lt;/div&gt;
  
body{
    display: grid;
}
#header{
    background: red;
    grid-row:1;
    grid-column:1/5;
}
#left{
    grid-row:2;
    grid-column:1/2;
    background: orange;
}
#right{
    grid-row:2;
    grid-column:4/5;
    background: cadetblue;
}
#middle{
    grid-row:2;
    grid-column:2/4;
    background: rebeccapurple
}
#footer{
    background: gold;
    grid-row:3;
    grid-column:1/5;
}
简单说一下代码的实现。回头会专门看一下css grid的细节。
首先给最外层的body设成display:grid。当然，是外层父级元素即可，不一定是body。
grid-row就是说由上到下，#header占据第1格，#left,#middle,#right占据第2格，#footer占据第3格。
而grid-column表示，在横向从左向右，分成了五格。其中#header和#footer占据全部。#left占据第1格，#middle占据第2到第4格，#right占据第5格。
不管是实现起来还是理解起来都很方便。
</code></pre> <p>&nbsp;</p> </li></ul>
                ]]></description></item><item><title>联想Tab M10 FHD PLUS (TB-X606F)解锁BL，获取root权限（无需第三方recovery），刷xp框架（太极-阳）适用大部分联发科CPU（国际版rom底包）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/27/13908176.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 27 Oct 2020 13:27:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/27/13908176.html</guid><description><![CDATA[
                    <p><strong><span style="color:#f33b45;">注意：此文章仅作为学习和参考，造成的所有后果与本人无关，在进行所有操作之前请进行备份，备份，备份！！！其次请确保你有一定的刷机基础，如救砖刷机，线刷，卡刷。如果是解锁BootLoader一定会双清，如果你是国行版的，并且使用该教程，数据一定会双清，请做好抉择！！！并备份文件！！！！！</span></strong></p> 
<p><strong>前言：5月份的时候在网上买了个联想M10 FHD PLUS平板（国行版），当时想找root方法拓展平板更多功能，发现几乎查不到教程，在国外网站也只有一些比较模糊的教程，并且由于当时工作较忙，也就没有深入研究教程。<br> 其中包括<a href="https://forum.xda-developers.com/general/help/lenovo-tb-x605f-magisk-root-t3992477">https://forum.xda-developers.com/general/help/lenovo-tb-x605f-magisk-root-t3992477</a><br> 和<a href="https://forum.frandroid.com/topic/275557-root-lenovo-tab-m10-fhd-plus-tb-x606f/">https://forum.frandroid.com/topic/275557-root-lenovo-tab-m10-fhd-plus-tb-x606f/</a><br> 之前照着这两个教程发现无法达到目的，但是还是感谢这两个作者提供的思路</strong></p> 
<p><strong>时隔五个月，我再次搜索M10 FHD PLUS root教程时找到了相关教程<br><a href="https://forum.frandroid.com/topic/275622-tuto-bootloader-et-root-du-lenovo-tab-m10-fhd-plus-tb-x606f-sans-twrp/">https://forum.frandroid.com/topic/275622-tuto-bootloader-et-root-du-lenovo-tab-m10-fhd-plus-tb-x606f-sans-twrp/</a><br> 国际版rom刷机包（自带谷歌全套，国行版无法安装谷歌套件）：<a href="https://mirrors.lolinet.com/firmware/lenovo/Tab_M10_FHD_Plus_2nd_Gen/TB-X606F/">https://mirrors.lolinet.com/firmware/lenovo/Tab_M10_FHD_Plus_2nd_Gen/TB-X606F/</a><br> 联想官方软件和驱动：<br><a href="https://pcsupport.lenovo.com/us/zh/products/tablets/m-series-tablets/tab-m10-fhd-plus/downloads/driver-list/component?name=%E8%BB%9F%E9%AB%94%E5%8F%8A%E5%85%AC%E7%94%A8%E7%A8%8B%E5%BC%8F">https://pcsupport.lenovo.com/us/zh/products/tablets/m-series-tablets/tab-m10-fhd-plus/downloads/driver-list/component?name=%E8%BB%9F%E9%AB%94%E5%8F%8A%E5%85%AC%E7%94%A8%E7%A8%8B%E5%BC%8F</a><br> 联想官方论坛：<br><a href="https://club.lenovo.com.cn/search.php?mod=forum&amp;searchid=482&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=M10">https://club.lenovo.com.cn/search.php?mod=forum&amp;searchid=482&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=M10</a></strong></p> 
<p><strong>获取root及xp后的效果</strong><br><img alt="" height="147" src="https://img-blog.csdnimg.cn/20201027092214825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="237"><img alt="" height="148" src="https://img-blog.csdnimg.cn/20201027092235266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="239"><img alt="" height="145" src="https://img-blog.csdnimg.cn/20201027092304729.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="91"></p> 
<p><strong>以下是我获取root及xp的完整过程（如果要获取root权限，请确保你有一定的刷机基础，并可以救砖刷机，因为之后的操作可能会使你的机器变砖，我就踩了个坑，后面会说到）：</strong></p> 
<p><strong>准备工作</strong></p> 
<ul><li><strong>电量充足的联想Tab M10 FHD PLUS平板</strong></li><li><strong>type-c数据线</strong></li><li><strong>电脑</strong></li><li><strong><a href="https://mirrors.lolinet.com/firmware/lenovo/Tab_M10_FHD_Plus_2nd_Gen/TB-X606F/">国际版官方ROM</a></strong></li><li><strong>adb工具</strong></li><li><strong>magisk.apk及科学上网软件</strong></li></ul>
<p><strong><a href="https://pan.baidu.com/s/1UDnpIC6rtS6euyQ0j8dEfA%C2%A0">相关的软件地址</a>，提取码：topq （失效评论补链接）</strong></p> 
<p><strong>百度网盘文件介绍：</strong></p> 
<p><img alt="" height="114" src="https://img-blog.csdnimg.cn/20201027173519298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="282"></p> 
<p><strong>adb工具：</strong><strong><a href="https://gitee.com/DieHunter/myCode/tree/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo">https://gitee.com/DieHunter/myCode/tree/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/lenovo</a>（已集成magisk_patched.img）</strong></p> 
<p><strong>首先将平板的adb和OEM打开，这两者都需要先打开开发者模式，点击七次版本号，在下图第二张图中会出现开发者选项，点进去就是图四。</strong><br><img alt="" height="169" src="https://img-blog.csdnimg.cn/20201027085658393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="186"><img alt="" height="166" src="https://img-blog.csdnimg.cn/20201027085729843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="187"><img alt="" height="168" src="https://img-blog.csdnimg.cn/20201027085751969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="178"><img alt="" height="165" src="https://img-blog.csdnimg.cn/20201027085827504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="151"></p> 
<p><strong>其次，使用type-c数据线将平板连接电脑，等待安装驱动，充电选项选择文件传输，当计算机出现图四时，勾选一律允许，并点确定</strong></p> 
<p><img alt="" height="70" src="https://img-blog.csdnimg.cn/20201027090259160.png" width="191"><img alt="" height="104" src="https://img-blog.csdnimg.cn/20201027090804662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="139"><img alt="" height="103" src="https://img-blog.csdnimg.cn/20201027090843326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="140"><img alt="" height="101" src="https://img-blog.csdnimg.cn/2020102709103063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="161"></p> 
<p><strong>然后，解锁BootLoader：打开adb工具文件夹，其中步骤如下图<br> 输入&nbsp;adb devices，查找已连接设备</strong><br><img alt="" height="156" src="https://img-blog.csdnimg.cn/20201027104156733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="290"><img alt="" height="155" src="https://img-blog.csdnimg.cn/20201027104448291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="238"></p> 
<p><strong>运行 adb reboot bootloader，重启至bootloader模式，出现以下效果表示进入成功，或者也可以在关机状态下按住开机键+音量减，直至震动开机，松开后会显示以下图示</strong></p> 
<p><img alt="" height="106" src="https://img-blog.csdnimg.cn/20201027105412735.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="229"></p> 
<p><strong>输入 fastboot flashing unlock达到以下效果，按下音量下键即可解锁BootLoader，这里我第二次手贱，按了一下，导致系统恢复出厂设置，<span style="color:#f33b45;">注意：在这步之前备份还来得及，如果有重要文件，请一定要备份！！！（这里我已经吃了两次亏了），</span>这里会格式化设备分区</strong></p> 
<p><img alt="" height="174" src="https://img-blog.csdnimg.cn/2020102711090716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="267"><img alt="" height="177" src="https://img-blog.csdnimg.cn/20201027111014770.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="133"></p> 
<p><strong>运行&nbsp;fastboot reboot重启设备至初始化界面，第一次开机会等待一段时间<br> 以上就是完整的BootLoader解锁过程，下一步将对magisk_patched刷入，获取root权限，需要保证boot镜像与当前系统对应，也就是说如果你是国行平板，必须使用国行ROM进行解压并提取boot镜像，我这里没有找到国行包，并且需要谷歌套件，所以我索性直接重新刷了国际版ROM包</strong></p> 
<p><strong>重启成功后把之前的usb调试和文件传输打开，最好拷贝一个科学上网工具，因为需要更新最新版magisk，把网盘中的magisk.apk放到平板根目录下，并在平板中安装，这里建议下载一个快传软件通过手机发送软件，挂科学上网工具，打开Magisk，更新软件。<br> 点击安装，选择当前系统镜像中解压的boot.img文件，等待magisk生成magisk_patched.img文件至download文件夹下，复制该文件到电脑adb根目录下，就可以正式开始刷root权限了</strong></p> 
<p><strong><span style="color:#f33b45;">这里踩了个坑：由于我是国行的平板，安装的ROM是国内版包，但是由于我之前不知道我下载的系统包是国际版的，包内的boot.img是不同的，导致机器刷成后，系统崩溃（打开任何软件都会重启），但是我又找不到国行的ROM，于是干脆刷成了国际版，教程在后面会贴出，所以一定要保证使用的boot.img是正在使用的系统中解压的，或者直接刷成国际版ROM，地址在上面都已经给出。</span></strong><br><img alt="" height="127" src="https://img-blog.csdnimg.cn/20201027112320475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="249"><img alt="" height="130" src="https://img-blog.csdnimg.cn/20201027122524984.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="81"><img alt="" height="125" src="https://img-blog.csdnimg.cn/20201027135944177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="112"><img alt="" height="124" src="https://img-blog.csdnimg.cn/2020102714004024.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="135"><img alt="" height="121" src="https://img-blog.csdnimg.cn/20201027140115938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="129"><img alt="" height="123" src="https://img-blog.csdnimg.cn/20201027143930662.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="77"><img alt="" height="122" src="https://img-blog.csdnimg.cn/20201027144115917.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="76"></p> 
<p><img alt="" height="121" src="https://img-blog.csdnimg.cn/20201027140351807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="229"></p> 
<p><strong>获取root权限的准备工作完成，下面开始操作<br> 运行&nbsp;&nbsp;adb reboot bootloader&nbsp; &nbsp;启动到BootLoader模式下</strong></p> 
<p><strong>执行&nbsp; fastboot flash boot magisk_patched.img&nbsp; 刷入magisk生成的img文件</strong></p> 
<p><strong>最后执行&nbsp; fastboot reboot&nbsp; &nbsp;重启</strong></p> 
<p><img alt="" height="255" src="https://img-blog.csdnimg.cn/20201027145003846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="390"></p> 
<p><strong>如果重启后打开Magisk显示以下图示，那么恭喜你，root成功，获取root权限之后能做些啥就不用多说了</strong><br><img alt="" height="312" src="https://img-blog.csdnimg.cn/20201027145313293.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="195"><img alt="" height="309" src="https://img-blog.csdnimg.cn/20201027145335917.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="193"></p> 
<p><strong>下一步说说xposed框架支持，安卓较高版本用的是<a href="https://www.taichi-app.com/#/index">太极</a>，在官网下载太极安装并打开，这里需要安装一个太极阳Magisk模块，官网上有详细的教程<br> 我的<a href="https://gitee.com/DieHunter/myCode/blob/master/%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7/magisk-taichi-v6.2.3.zip">仓库上</a>也有上传，把zip包放在平板根目录，使用magisk加载模块并刷入系统</strong></p> 
<p><img alt="" height="269" src="https://img-blog.csdnimg.cn/20201027151809289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="273"><img alt="" height="273" src="https://img-blog.csdnimg.cn/20201027151746732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="269"><img alt="" height="269" src="https://img-blog.csdnimg.cn/20201027151830426.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="168"><br><strong>magisk刷入zip模块过程，首先在magisk首页选择模块，选择本地安装，找到太极阳模块zip，自动安装，点击重启即可</strong></p> 
<p><img alt="" height="238" src="https://img-blog.csdnimg.cn/20201027153549665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="149"><img alt="" height="234" src="https://img-blog.csdnimg.cn/20201027153642142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="146"><img alt="" height="230" src="https://img-blog.csdnimg.cn/20201027153748945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="144"><img alt="" height="234" src="https://img-blog.csdnimg.cn/20201027153907470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="146"></p> 
<p><strong>最后附上简易的线刷救砖教程（百度网盘都有详细的教程，理论支持大部分联发科CPU）<br> 准备工作（文件都在百度网盘中）：</strong></p> 
<ul><li><strong>官方ROM包（我这里用的是上面链接中ROM包）</strong></li><li><strong>线刷工具flash_tool</strong></li><li><strong>驱动包</strong></li></ul>
<p><strong>首先将官方ROM解压</strong></p> 
<p><img alt="" height="232" src="https://img-blog.csdnimg.cn/2020102717292355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="274"></p> 
<p><strong>其次安装驱动</strong></p> 
<p><img alt="" height="133" src="https://img-blog.csdnimg.cn/20201027211904613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="287"><img alt="" height="139" src="https://img-blog.csdnimg.cn/20201027211806989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="244"><img alt="" height="140" src="https://img-blog.csdnimg.cn/20201027211833562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="294"></p> 
<p><strong>打开flash_tool程序,并进行以下操作（相关操作在百度云链接都有），这里简单介绍一下，图二是正在刷机，图三是刷机完成<br><span style="color:#f33b45;">如果点了下载没反应，请将平板或手机关机</span></strong></p> 
<p><img alt="" height="190" src="https://img-blog.csdnimg.cn/20201027173858340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="289"><img alt="" height="189" src="https://img-blog.csdnimg.cn/202010271744497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="287"><img alt="" height="188" src="https://img-blog.csdnimg.cn/20201027174635985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="286"></p> 
<p><strong>总结：无论是解锁bl，刷机，root，xp框架一定要备份好数据，刷机无情，数据无价！！！为了完成这篇文章，我自己就尝到了教训，解锁时不小心双清了！如果文章内容对你有帮助，请帮忙点个赞~非常感谢！！！</strong></p> 
<p>&nbsp;</p> 
<div id="gtx-trans"> 
 <div class="gtx-trans-icon">
  &nbsp;
 </div> 
</div>
                ]]></description></item><item><title>谷歌插件Infinity pro标签书签分享，附上本地pro版的书签的迁移方法</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/24/13908177.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 24 Oct 2020 02:24:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/24/13908177.html</guid><description><![CDATA[
                    <p><strong>这个书签涵盖很多程序员必备网站，不止有前端</strong></p> 
<p><strong>方法一：直接在浏览器打开即可：m.infinitynewtab.com?6iyA0H</strong></p> 
<p><strong><img alt="" height="151" src="https://img-blog.csdnimg.cn/20201021163112662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="358"><img alt="" height="151" src="https://img-blog.csdnimg.cn/20201021163137551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="358"><br> 方法二：谷歌infinity插件下载：<a href="https://www.extfans.com/search/extensions/infinity/">https://www.extfans.com/search/extensions/infinity/</a>（推荐）</strong></p> 
<p><strong>官网：<a href="http://cn.infinitynewtab.com/">http://cn.infinitynewtab.com/</a></strong></p> 
<p><img alt="" height="173" src="https://img-blog.csdnimg.cn/20201021173046620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="396"></p> 
<p><strong><img alt="" height="164" src="https://img-blog.csdnimg.cn/20201021163040823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="388"></strong></p> 
<p><img alt="" height="177" src="https://img-blog.csdnimg.cn/20201021174039112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="387"><br><strong>安装方法：<br> 由于国内使用谷歌产品需要科学上网，这里分享一个谷歌插件代理网站<br> 把下载的压缩包解压，提取出crx后缀文件，打开设置中的扩展程序如下图，打开开发者模式，将crx文件拖拽进窗口，如果失败，多试几次</strong></p> 
<p><img alt="" height="173" src="https://img-blog.csdnimg.cn/20201021174204147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="367"></p> 
<p><img alt="" height="297" src="https://img-blog.csdnimg.cn/20201021173915696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="380"></p> 
<p><img alt="" height="171" src="https://img-blog.csdnimg.cn/20201021174828771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="374"></p> 
<p><strong>安装成功后可以用第三方账号登录，或者旧版infinity插件数据迁移</strong><br><img alt="" height="140" src="https://img-blog.csdnimg.cn/2020102117503358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="317"><img alt="" height="142" src="https://img-blog.csdnimg.cn/20201021175123878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="103"><br><strong>然而新版的infinity pro标签不支持备份成本地infinity文件，只能通过云端进行云更新和备份，作为web前端开发者当然是要打开F12一探究竟，于是我发现，断网的状态下，刷新页面不会请求数据渲染，也就是所有的书签都存在本地缓存中，于是我试了试查看localstorage，果然查到了一个infinity-icons的键值对，这里就是infinity_pro的所有图标，如果需要复制别人的或者复制给别人，直接用此方法生成json文件或者直接用txt即可。</strong></p> 
<p><strong>注意：粘贴了别人的书签后需要重启浏览器才有效</strong></p> 
<p><img alt="" height="178" src="https://img-blog.csdnimg.cn/20201023174209868.gif" width="400"><img alt="" height="177" src="https://img-blog.csdnimg.cn/20201023175424457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="387"></p> 
<p><strong>最后，分享一下我的infinity pro的书签json文件以及插件，希望对大家有帮助。<br> 地址：<a href="https://gitee.com/DieHunter/myCode/tree/master/infinity_pro">https://gitee.com/DieHunter/myCode/tree/master/infinity_pro</a></strong></p> 
<div id="gtx-trans"> 
 <div class="gtx-trans-icon">
  &nbsp;
 </div> 
</div>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十九）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/17/13908178.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 17 Oct 2020 06:50:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/17/13908178.html</guid><description><![CDATA[
                    <p id="articleContentId"><strong>从零开始，搭建一个简单的购物平台（十八）前端商城部分：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108918489">https://blog.csdn.net/time_____/article/details/108918489</a><br><strong>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>上篇文章后，前端商城部分基本功能已实现，包括商品列表，商品分类，首页商品展示，商品详情，购物车，用户登录注册，剩余内容：用户信息修改，提交订单，订单展示等，这篇文章将对剩余功能部分完结。</strong></p> 
<p><strong>用户信息修改的后端接口已经在管理平台实现，这里直接进行验证调用即可</strong></p> 
<p><strong>之前的修改用户信息功能在测试中体现出来了一个bug，因为生成Token的字段是用户名，当修改用户信息时，如果修改了用户名，就会导致token验证失败，于是我们需要修复token生成方式，将之前的用户名生成改成_id生成,新版代码已经提交至码云</strong></p> 
<p><strong>修复后效果：</strong></p> 
<p><img alt="" height="239" src="https://img-blog.csdnimg.cn/20201016164711279.gif" width="135"></p> 
<p><strong>下面介绍一下实现流程 ，这里我们把info用户信息界面和登录界面放在单页面中，通过v-if条件渲染，条件是checkToken是否通过</strong></p> 
<p><strong>bussiness.js，验证token是否有效</strong></p> 
<pre><code class="language-javascript">import Vue from "vue";
import config from "../../config/config";
const { ServerApi, StorageName } = config;
export default class UserInfoBussiness extends Vue {
  constructor(_vueComponent) {
    super();
    this.vueComponent = _vueComponent;
  }
  checkToken() {//验证Token函数，若token正确，则直接登录成功，若未成功，则切换至登录界面
    let token = this.$storage.getStorage(StorageName.Token);
    if (!token || !token.length) return;
    this.$axios
      .get(ServerApi.token, {
        params: {
          token
        }
      })
      .then(res =&gt; {
        switch (res.result) {
          case -999://token请求抛发错误，token过期或错误
            this.vueComponent.isLogin = false;//显示登录页面
            this.$storage.clearStorage(StorageName.Token);//清除之前的token
            break;
          case 1://验证token成功
            this.vueComponent.userInfo = res.data;
            this.vueComponent.isLogin = true;//显示个人信息页面
            break;
          default:
            this.vueComponent.isLogin = false;
            this.$storage.clearStorage(StorageName.Token);
            break;
        }
      })
      .catch(err =&gt; {});
  }
}
</code></pre> 
<p><strong>&nbsp;info.vue组件</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;Top :title="isLogin?'我的':'登录'"&gt;&lt;/Top&gt;
    &lt;div class="content"&gt;
      &lt;UserInfo v-if="isLogin" :userInfo="userInfo"&gt;&lt;/UserInfo&gt;
      &lt;Login v-else&gt;&lt;/Login&gt;
    &lt;/div&gt;
    &lt;TabBar&gt;&lt;/TabBar&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import UserInfoBussiness from "./bussiness";
import TabBar from "../../components/tabBar/tabBar";
import UserInfo from "../../components/userInfo/userInfo";
import Login from "../../components/login/login";
import Top from "../../components/top/top";
import config from "../../config/config";
const { EventName } = config;
export default {
  components: {
    Top,
    UserInfo,
    Login,
    TabBar
  },
  data() {
    return {
      isLogin: false,
      userInfoBussiness: null,
      userInfo: null
    };
  },
  created() {
    this.userInfoBussiness = new UserInfoBussiness(this);
    this.$events.onEvent(EventName.IsLogin, () =&gt; {
      this.userInfoBussiness.checkToken();//退出登录响应事件，重重页面
    });
    this.userInfoBussiness.checkToken();//初始化先验证token
  },
  destroyed() {
    this.$events.offEvent(EventName.IsLogin);
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
&lt;/style&gt;</code></pre> 
<p><strong>在用户登录成功后，我们需要一个组件显示用户信息，这个没有任何逻辑，纯渲染，所以暂不做介绍</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;ul class="userInfo"&gt;
    &lt;router-link to="/UpdateInfo"&gt;
      &lt;li&gt;
        &lt;img :src="imgPath+userInfo.headPic" alt /&gt;
        &lt;span&gt;{<!-- -->{userInfo.username}}&lt;/span&gt;
        &lt;div class="iconfont icon-fanhui"&gt;&lt;/div&gt;
      &lt;/li&gt;
    &lt;/router-link&gt;
    &lt;li&gt;
      &lt;mt-cell :title="userInfo.phoneNum"&gt;&lt;/mt-cell&gt;
      &lt;mt-cell :title="userInfo.mailaddress+userInfo.mailurl"&gt;&lt;/mt-cell&gt;
      &lt;mt-cell :title="userInfo.alladdress.join('-')+'-'+userInfo.address"&gt;&lt;/mt-cell&gt;
      &lt;mt-cell :title="userInfo.descript"&gt;&lt;/mt-cell&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
const { RequestPath, StorageName } = Config;
import { Cell } from "mint-ui";
export default {
  name: "userinfotop",
  props: ["userInfo"],//父组件传递用户信息至当前组件，并渲染
  data() {
    return {
      imgPath: RequestPath
    };
  },

  created() {
    this.$storage.saveStorage(StorageName.UserInfo, this.userInfo);
  }
};
&lt;/script&gt;


&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.userInfo {
  li:nth-child(1) {
    .h(230);
    width: 100%;
    .mcolor();
    .l_h(230);
    margin-top: -1px;
    color: #fff;
    &gt; img,
    &gt; span {
      display: inline-block;
      vertical-align: middle;
      margin-left: unit(40 / @pxtorem, rem);
    }
    &gt; img {
      .w(145);
      .h(145);
      border-radius: 100%;
    }
    &gt; span {
      .f_s(40);
    }
    &gt; div {
      height: 100%;
      float: right;
      padding-left: unit(40 / @pxtorem, rem);
      transform: rotateY(180deg);
    }
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>通过点击头像框路由跳转至UpdateInfo，用户信息修改页，我们将头像上传单独写成组件</strong></p> 
<p><img alt="" height="307" src="https://img-blog.csdnimg.cn/2020101617371416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="173"></p> 
<p><strong>这里有一个原生js上传文件的坑：<br> axios上传post文件头文件需模拟&nbsp;"multipart/form-data"请求，而这种请求格式与application/x-www-form-urlencoded有所不同，需要声明一个分隔符‘boundary’。</strong></p> 
<pre><code class="language-javascript">headers: {
          "Content-Type": "multipart/form-data;boundary=ABC"//ABC内容自行填写
  },</code></pre> 
<p><strong>那么这时，坑人的地方来了，直接以ABC这种简单的分隔符内容上传文件可能会导致服务端对文件不识别，无法找到文件起始位置，所以我们需要一个复杂的字符，比如使用new&nbsp;Date().getTime()生成随机字符，修改后就有以下配置</strong></p> 
<pre><code class="language-javascript">headers: {
          "Content-Type": "multipart/form-data;boundary=" + new Date().getTime()
        },</code></pre> 
<p><strong>上传头像组件中，我们要自己写一个控件替代官方的input元素，也就是点击图片使用JS执行input文件上传事件，并提交到服务端，服务端存好缓存后将图片文件地址发送到前端，前端读取文件并展示，以下是头像上传的所有过程<br> uploadPic.vue</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div class="uploadPic"&gt;
    &lt;img :src="picPath" @click="clickHandler" alt /&gt;
    &lt;input class="picFile" id="picFile" type="file" @change="uploadPic" accept="image/*" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
import UploadBussiness from "./bussiness";
const { StorageName, RequestPath, UploadKey } = Config;
export default {
  name: "uploadPic",
  props: ["picFile"],
  data() {
    return {
      imgPath: RequestPath,
      picPath: ""
    };
  },
  created() {
    this.picPath = this.imgPath + this.picFile;
    this._uploadBussiness = new UploadBussiness(this);
  },
  methods: {
    clickHandler() {//点击头像模拟至点击文件上传input-file标签
      document.querySelector("#picFile").click();
    },
    uploadPic(e) {
      let _picFile = new FormData();//新建FormData文件
      _picFile.append("token", this.$storage.getStorage(StorageName.Token));//将token添加至文件属性中
      _picFile.append(UploadKey.headKey, e.target.files[0]);//文件校验字段
      this._uploadBussiness.uploadPic(_picFile);//上传文件
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.uploadPic {
  img {
    width: 100%;
    height: 100%;
  }
  .picFile {
    display: none;
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>bussiness.js</strong></p> 
<pre><code class="language-javascript">import Vue from 'vue'
import config from "../../config/config"
import {
  Toast
} from "mint-ui";
const {
  UploadName,
  EventName,
  UploadKey
} = config
export default class UploadBussiness extends Vue {
  constructor(_vueComponent) {
    super()
    this.vueComponent = _vueComponent
  }
  uploadPic(data) {
    this.$axios
      .post(UploadName.headPic, data, {
        headers: {
          "Content-Type": "multipart/form-data;boundary=" + new Date().getTime()//axios上传post文件头文件需模拟&nbsp;"multipart/form-data"请求，而这种请求格式与application/x-www-form-urlencoded有所不同，需要声明一个分隔符‘boundary’。
        },
      }).then(res =&gt; {
        Toast(res.msg);
        switch (res.result) {
          case 1://上传成功后显示图片
            let fileRead = new FileReader();//新建文件读取实例
            fileRead.readAsDataURL(data.get(UploadKey.headKey));//readAsDataURL读取本地图片信息
            fileRead.onload = () =&gt; {
              this.vueComponent.picPath = fileRead.result
            }
            this.$events.emitEvent(EventName.UploadPic, res.headPath)
            break;
          default:
            break;
        }
      })
  }
}
</code></pre> 
<p><strong>说完了上传头像组件后，来实现一下修改用户信息，之前上传的头像地址会通过组件传参传递到父组件中，伴随着其他信息一起提交到服务端，服务端将收到的头像缓存地址解析成文件并保存，修改用户信息组件中可以复用一个省市县选择器组件，即之前在商品详情中使用的商品数量选择，其他的表单元素都是基本的文本类型</strong></p> 
<p><strong>updataForm.vue</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div class="update"&gt;
    &lt;!-- &lt;img :src="imgPath+userInfo.headPic" alt /&gt; --&gt;
    &lt;UploadPic class="uploadPic" :picFile="userInfo.headPic"&gt;&lt;/UploadPic&gt;
    &lt;mt-field
      placeholder="请输入用户名"
      :state="userInfo.username.length?'success':'error'"
      v-model="userInfo.username"
    &gt;&lt;/mt-field&gt;
    &lt;mt-field
      placeholder="请输入手机号"
      :state="userInfo.phoneNum.length?'success':'error'"
      v-model="userInfo.phoneNum"
      type="number"
    &gt;&lt;/mt-field&gt;
    &lt;mt-radio v-model="userInfo.sex" :options="sexOption"&gt;&lt;/mt-radio&gt;
    &lt;mt-button class="btn" @click="selectAddress"&gt;{<!-- -->{userInfo.alladdress.join('-')}}&lt;/mt-button&gt;
    &lt;mt-field
      placeholder="请输入详细地址"
      :state="userInfo.address.length?'success':'error'"
      v-model="userInfo.address"
    &gt;&lt;/mt-field&gt;
    &lt;mt-field
      placeholder="请输入个性签名"
      :state="userInfo.descript.length?'success':'error'"
      v-model="userInfo.descript"
    &gt;&lt;/mt-field&gt;
    &lt;mt-button class="submit" type="primary" @click="submit"&gt;修改信息&lt;/mt-button&gt;
    &lt;div class="shopPicker"&gt;
      &lt;mt-popup v-model="popupVisible" position="bottom"&gt;
        &lt;mt-picker
          :slots="myAddressSlots"
          value-key="name"
          :visibleItemCount="7"
          @change="changeAddress"
        &gt;&lt;/mt-picker&gt;
      &lt;/mt-popup&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import UpdateBussiness from "./bussiness";
import Config from "../../config/config";
import { Field, Button, Picker, Popup, Radio } from "mint-ui";
import address from "../../config/city";
import UploadPic from "../uploadPic/uploadPic";
const { StorageName, RequestPath, EventName } = Config;
export default {
  name: "updateForm",
  data() {
    return {
      imgPath: RequestPath,
      updateBussiness: null,
      popupVisible: false,//控制picker显示
      selectArea: null,
      sexOption: [//性别配置
        {
          label: "男",
          value: "man"
        },
        {
          label: "女",
          value: "woman"
        }
      ],
      myAddressSlots: [//省市县联动配置
        {
          flex: 1,
          defaultIndex: 0,
          values: [],
          className: "slot1",
          textAlign: "center"
        },
        {
          divider: true,
          content: "-",
          className: "slot2"
        },
        {
          flex: 1,
          values: [],
          className: "slot3",
          textAlign: "center"
        },
        {
          divider: true,
          content: "-",
          className: "slot4"
        },
        {
          flex: 1,
          values: [],
          className: "slot5",
          textAlign: "center"
        }
      ],
      userInfo: this.$storage.getStorage(StorageName.UserInfo)//获取缓存的用户信息，用于显示默认项
    };
  },
  components: {
    UploadPic
  },
  created() {
    this.$events.onEvent(EventName.UploadPic, headPic =&gt; {//上传头像后将新地址保存至当前组件
      this.userInfo.headPic = headPic;
    });
    this.updateBussiness = new UpdateBussiness(this);
  },
  destroyed() {
    this.$events.offEvent(EventName.UploadPic);
  },
  methods: {
    selectAddress() {//显示picker
      this.myAddressSlots[0].values = address;
      this.popupVisible = true;
    },
    changeAddress(picker, values) {//三级联动
      if (values[0]) {
        this.userInfo.alladdress = [values[0].name];
        picker.setSlotValues(1, values[0].children);
        if (values[1]) {
          this.userInfo.alladdress.push(values[1].name);
          picker.setSlotValues(2, values[1].children);
          if (values[2]) {
            this.userInfo.alladdress.push(values[2].name);
          }
        }
      }
    },
    submit() {
      this.updateBussiness.submitData();//提交信息
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.update {
  .uploadPic {
    overflow: hidden;
    .w(200);
    .h(200);
    .mg(unit(30 / @pxtorem, rem) auto);
    border-radius: 100%;
  }
  .btn {
    width: 100%;
    .h(100);
    background: #fff;
  }
  .submit {
    margin-top: unit(30 / @pxtorem, rem);
    width: 100%;
    // z-index: 100;
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>bussiness.js</strong></p> 
<pre><code class="language-javascript">import Vue from 'vue'
import config from "../../config/config"
import {
  Toast
} from "mint-ui";
const {
  ServerApi,
  StorageName,
  EventName
} = config
export default class UpdateBussiness extends Vue {
  constructor(_vueComponent) {
    super()
    this.vueComponent = _vueComponent
  }
  submitData() {
    for (const key in this.vueComponent.userInfo) {//表单非空判断
      let value = this.vueComponent.userInfo[key]
      if (!value.length &amp;&amp; value != true &amp;&amp; value != 0 &amp;&amp; typeof value == 'string') {
        Toast('请填写完整的信息');
        return
      }
    }
    this.$axios
      .post(ServerApi.user.updateUser, {
        crypto: this.$crypto.setCrypto({
          token: this.$storage.getStorage(StorageName.Token),
          ...this.vueComponent.userInfo
        })
      }).then(res =&gt; {
        switch (res.result) {
          case 1:
            Toast(res.msg);
            history.go(-1)
            break;
          default:
            break;
        }
      })
  }
}
</code></pre> 
<p><strong>用户信息修改就介绍到这里，下一步将对项目的最后一步订单的前端部分进行分享</strong></p> 
<p><strong>订单的后端逻辑与接口在管理系统中已经介绍完毕，前端部分就是很简单的数据渲染和状态修改</strong></p> 
<p><img alt="" height="376" src="https://img-blog.csdnimg.cn/2020101621350963.gif" width="209"><img alt="" height="373" src="https://img-blog.csdnimg.cn/20201017113202183.gif" width="210"><br><strong>首先，订单是基于用户和商品绑定的，所以，我们在购物车中实现新增订单功能，添加成功后跳转至订单查询界面，除此之外，在用户信息界面，添加用户的所有订单列表可以查看和付款（由于只是一个项目案例，所以这里没有实现支付功能）</strong></p> 
<p><strong>orderList.vue组件，几乎都是页面渲染，没有什么逻辑功能，就不做说明</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div class="content"&gt;
    &lt;div class="orderTop"&gt;
      &lt;div&gt;
        &lt;div&gt;
          &lt;p class="fontcl"&gt;
            下单时间：
            &lt;span&gt;{<!-- -->{new Date(orderList.orderTime).toLocaleString()}}&lt;/span&gt;
          &lt;/p&gt;
          &lt;p class="fontcl"&gt;
            订单编号：
            &lt;span&gt;{<!-- -->{orderList.orderId}}&lt;/span&gt;
          &lt;/p&gt;
        &lt;/div&gt;
        &lt;div
          :class="orderList.orderState==0?'noPay':orderList.orderState==4?'isFinish':'isPay'"
        &gt;{<!-- -->{orderState[orderList.orderState||0].name}}&lt;/div&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;div&gt;
          &lt;span class="icon-yonghuming iconfont"&gt;{<!-- -->{orderList.username}}&lt;/span&gt;
          &lt;span class="icon-shoujihao iconfont"&gt;{<!-- -->{orderList.phoneNum}}&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="fontcl"&gt;{<!-- -->{orderList.address}}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;ul class="orderList"&gt;
      &lt;li v-for="(item,index) in orderList.shopList" :key="index"&gt;
        &lt;img :src="imgPath+item.shopPic" alt /&gt;
        &lt;div&gt;
          {<!-- -->{item.shopName+item.shopScale}}
          &lt;br /&gt;
          ￥{<!-- -->{item.shopPrice}}
        &lt;/div&gt;
        &lt;span&gt;×{<!-- -->{item.shopCount}}&lt;/span&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;div class="submitOrder"&gt;
      &lt;span&gt;付款合计：￥{<!-- -->{orderList.orderPrice}}&lt;/span&gt;
      &lt;span @click="submitOrder" v-show="orderList.orderState==0"&gt;去付款&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import OrderBussiness from "./bussiness";
import Config from "../../config/config";
import ShopType from "../../config/shopType";
export default {
  name: "orderList",
  data() {
    return {
      orderState: ShopType.orderState,
      imgPath: Config.RequestPath,
      orderList: [],//订单详情
      orderBussiness: null,
    };
  },
  created() {
    this.orderBussiness = new OrderBussiness(this);
    this.orderBussiness.getOrderList();
  },
  methods: {
    submitOrder() {
      this.orderBussiness.sendOrderPay(this.orderList);//支付
    },
  },
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.content {
  font-size: unit(32 / @pxtorem, rem);
  .fontcl {
    .cl(#979797);
  }
  .orderTop {
    &gt; div {
      padding-left: unit(35 / @pxtorem, rem);
      padding-right: unit(35 / @pxtorem, rem);
    }
    &gt; div:nth-child(1) {
      .h(160);
      border-bottom: unit(3 / @pxtorem, rem) solid #e8e8e8;
      &gt; div:nth-child(1) {
        float: left;
        p {
          .l_h(80);
          span {
            .cl(#000);
          }
        }
      }
      &gt; div:nth-child(2) {
        float: right;
        .h(160);
        .l_h(160);
      }
      .isFinish {
        .cl(@mainColor);
      }
      .isPay {
        .cl(#000);
      }
      .noPay {
        .cl(#A71A2D);
      }
    }
    &gt; div:nth-child(2) {
      .h(180);
      border-bottom: unit(30 / @pxtorem, rem) solid #f3f3f3;
      &gt; div:nth-child(1) {
        overflow: hidden;
        .l_h(100);
        span:nth-child(1) {
          float: left;
        }
        span:nth-child(2) {
          float: right;
        }
      }
      &gt; div:nth-child(2) {
        width: 100%;
      }
    }
  }
  .orderList {
    li {
      .h(250);
      padding-left: unit(20 / @pxtorem, rem);
      padding-right: unit(35 / @pxtorem, rem);
      &gt; div,
      &gt; span,
      img {
        display: inline-block;
        vertical-align: middle;
      }
      img {
        .w(220);
        .h(220);
        margin-right: unit(30 / @pxtorem, rem);
      }
      &gt; div {
        .l_h(60);
      }
      &gt; span {
        vertical-align: top;
        margin-top: unit(50 / @pxtorem, rem);
        float: right;
      }
    }
  }
  .submitOrder {
    .h(130);
    width: 100%;
    position: fixed;
    bottom: 0;
    background: #fff;
    border-top: unit(3 / @pxtorem, rem) solid #cdcdcd;
    span:nth-child(1) {
      float: left;
      .pd(unit(40 / @pxtorem, rem));
      .cl(#852332);
    }
    span:nth-child(2) {
      .mcolor();
      .pd(unit(45 / @pxtorem, rem) unit(110 / @pxtorem, rem));
      float: right;
      .cl(#fff);
    }
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>获取订单列表和提交订单支付状态的bussiness.js</strong></p> 
<pre><code class="language-javascript">import Vue from "vue";
import { MessageBox } from "mint-ui";
import config from "../../config/config";
import Clone from "../../utils/clone";
const { ServerApi, StorageName, EventName, DefaultPageConfig } = config;
export default class OrderBussiness extends Vue {
  constructor(_vueComponent) {
    super();
    this.vueComponent = _vueComponent;
    this._defaultPageConfig = Clone.shallowClone(DefaultPageConfig);
  }
  getOrderList() {//获取个人订单信息列表
    this._defaultPageConfig.token = this.$storage.getStorage(StorageName.Token);
    this._defaultPageConfig.orderId = this.vueComponent.$route.query.orderId;
    this.$axios
      .get(ServerApi.order.orderList, {
        params: {
          crypto: this.$crypto.setCrypto(this._defaultPageConfig)
        }
      })
      .then(res =&gt; {
        switch (res.result) {
          case 1:
            this.vueComponent.orderList = res.data.list[0];
            break;
          default:
            break;
        }
      });
  }
  sendOrderPay(data) {
    MessageBox("提示", "本案例仅为参考，未开通支付功能");
    data.orderState = 1;//修改订单状态为已支付
    data.token = this.$storage.getStorage(StorageName.Token);
    this.$axios
      .post(ServerApi.order.updateOrder, {
        crypto: this.$crypto.setCrypto(data)
      })
      .then(res =&gt; {
        switch (res.result) {
          case 1:
            break;
          default:
            break;
        }
      });
  }
}
</code></pre> 
<p><strong>订单功能完成</strong></p> 
<p><strong>项目整体打包</strong></p> 
<p><strong>通过运行&nbsp; &nbsp;npm run build&nbsp; &nbsp;进行webpack打包</strong></p> 
<p><strong>生产环境部署可以参照我<a href="https://blog.csdn.net/time_____/article/details/104439713">之前的一篇文章</a></strong></p> 
<p><strong>如果需要配置https环境可以参照<a href="https://blog.csdn.net/time_____/article/details/108050452">这篇文章</a></strong></p> 
<p><strong>文件夹的命名规则以及模块组件的分配在<a href="https://blog.csdn.net/time_____/article/details/104676690">这篇文章</a>有说到</strong></p> 
<h3><strong>希望这个系列的文章对你有帮助，如果你阅读完了整个系列或者某篇文章，非常感谢你的支持</strong></h3> 
<p><strong>总结：到这篇博客为止，《从零开始，搭建一个简单的购物平台》系列的文章全部完结，以下是本人完成整个项目的一个小总结以及一些注意点：</strong></p> 
<ul><li><strong>搭建环境及配置文件：对自己的技术栈以及优势需要深入了解，并且选择最适合自己或者是产品需求所需要的技术，完成项目目录的搭建，比如前端最好养成模块化，组件化开发的习惯，尽量将文件夹以及文件细分到每个基本组件。</strong></li><li><strong>以组件和框架的官方文档为核心，学会自己上网查找问题，自己动手解决问题非常有必要。</strong></li><li><strong>学会造轮子，虽然网上有大量的框架，组件，别人写好的js库，但是自己动手写函数，封装功能以及组件是非常有必要的，并不是节省时间或者其他方面的原因，自己写能提升自己编程思路和实际应用能力，而且当自己写出了一个比较成功的类或者组件，甚至方法时，会有很大的成就感</strong></li><li><strong>面向对象编程语言，减少代码耦合度，提高内聚性，使代码健壮性更加强大，这点我自己正在努力改善，这样写代码有利于把很多方法剥离，可以提升复用性，减少代码量，说白了，一个项目别人可能只需要3000行代码，而我可能需要5000行</strong></li><li><strong>这个项目我是全栈完成的，采用的是前后端分离，但是实际开发中，前后端可能是两个或者多个人开发，这时需要自测接口及功能，前端搭建mock.js或使用easymock来进行模拟请求，后端可以使用postman，SoapUI等工具进行接口访问</strong></li><li><strong>前端和后端需要防止多次重复请求，前端通过节流的方式，防止对后端重复请求，但是也要防止数据库的恶意攻击（这个项目中没有实现），通过参数附带时间戳，使一个ip或者一个用户只能在短时间内请求规定次数</strong></li><li><strong>巧用前后端缓存，前端使用cookie和localstorage，后端生成temp缓存文件</strong></li><li><strong>前后端加密处理，token，Crypto加密参数，Bcrypt加密密码</strong></li></ul>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十八）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806817.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806817.html</guid><description><![CDATA[
                    <p><strong>从零开始，搭建一个简单的购物平台（十七）前端商城部分：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108893925">https://blog.csdn.net/time_____/article/details/108893925</a><br><strong>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>上篇文章对购物车进行了简单的介绍，商城的所有基础功能已经全部实现，这篇文章开始将介绍一下用户信息和订单相关的功能实现，用户信息登录在后端管理中已经实现，我们需要实现一个注册功能，和邮箱验证功能，具体实现可参照<a href="https://blog.csdn.net/time_____/article/details/84774092">之前的一篇博客</a>或是<a href="https://blog.csdn.net/time_____/article/details/84714723">这篇文章</a></strong></p> 
<p><strong>实现效果如下,分别是用户名密码登录，邮箱验证登录，注册功能</strong></p> 
<p><img alt="" height="396" src="https://img-blog.csdnimg.cn/2020100417004540.gif" width="184"><img alt="" height="396" src="https://img-blog.csdnimg.cn/20201004171207952.gif" width="184"><img alt="" height="394" src="https://img-blog.csdnimg.cn/20201004171958223.gif" width="183"></p> 
<p><strong>登录部分</strong></p> 
<p><strong>账号密码登录与后台管理系统的登录一样，若用户输入用户名密码登录成功，则将用户部分信息加密成token传至前端并保存至本地，每次通过将token值发送后端进行继续操作</strong></p> 
<p><strong>邮箱验证</strong></p> 
<p><strong>在服务端的config文件中新建EmailTransporter静态变量，用来配置发送邮箱使用到的nodemailer模块</strong></p> 
<pre><code class="language-javascript">EmailTransporter: {
    // service: "qq", // 运营商  qq邮箱 网易  若使用QQ邮箱，则只需配置service：qq
    host: "smtp.163.com",// 若使用网易邮箱，则只需配置host：smtp.163.com
    port: 465, //端口
    auth: {
      user: "132*****516@163.com", //发送方的邮箱
      pass: "WAQM******WQEFKB", // pop3 授权码
    },
  },</code></pre> 
<p><strong>然后新建邮箱验证码配置EmailConfig</strong></p> 
<pre><code class="language-javascript">  EmailConfig: {
    time: 5,//验证码有效期，单位分钟
    codeLength: 4,//验证码长度
    sendTime: 1 * 60 * 1000,//后端验证码允许再次发送时间间隔，单位毫秒
    targetTime: 5 * 60 * 1000,//验证码有效期，单位毫秒
    title: "零食商贩",//验证码标题
  },</code></pre> 
<p><strong>接着在Utils中写一个生成随机验证码函数</strong></p> 
<pre><code class="language-javascript">  /* 生成随机
   * @method    codeLength   函数名
   * @for    Utils     附属于哪个类
   * @param {number/string} len  随机数长度
   * @return {string}  _count   生成len个随机数
   */
  static codeLength(len) {
    let _count = "";
    for (let i = 0; i &lt; len; i++) {
      _count += Math.floor(Math.random() * 10); //生成len个随机数
    }
    return _count;
  }</code></pre> 
<p><strong>在Utils生成时间戳函数，记录验证码及验证码发送时间和有效时间</strong></p> 
<pre><code class="language-javascript"> /* 生成时间戳
   * @method    randomCode
   * @for    Utils
   * @param
   * @return {object}  _count   生成len个随机数
   */
  static randomCode() {
    return {
      code: this.codeLength(EmailConfig.codeLength), //生成的随机数
      sendTime: new Date().getTime() + EmailConfig.sendTime, //发送时间
      targetTime: new Date().getTime() + EmailConfig.targetTime, //截止时间
    };
  }</code></pre> 
<p><strong>在Utils文件夹下新建SendMail.js并新建发送邮件模块，在utils中调用</strong></p> 
<pre><code class="language-javascript">const nodemailer = require("nodemailer");
const Config = require("../config/config");
module.exports = class SendMail {
  static transporter = nodemailer.createTransport(Config.EmailTransporter); //邮箱配置项
  static mailOptions = null; //邮箱配置
  /* 发送邮件模块
   * @method    sendEmail
   * @for       SendMail
   * @param   {String} mail  用户邮箱号
   * @param   {String} title  邮件标题
   * @param   {String} content  邮件内容
   * @return {Boolean}   是否发送成功
   */
  static async sendEmail(mail, title, content) {
    this.mailOptions = {
      from: '"邮箱验证" &lt;' + Config.EmailTransporter.auth.user + "&gt;",
      to: mail,
      subject: title,
      text: content,
    };
    try {
      let result = await this.transporter.sendMail(this.mailOptions);
      console.log("发送成功");
      return true;
    } catch (error) {
      console.log(error);
      console.log("发送失败");
      return false;
    }
  }
};
</code></pre> 
<p><strong>在utils中新建生成邮件内容的函数</strong></p> 
<pre><code class="language-javascript">/* 生成邮件内容
   * @method    sendEmailCode
   * @for    Utils
   * @param   {String} code  验证码内容
   * @param   {String} email   用户邮箱
   */
  static async sendEmailCode(code, email) {
    return await SendMail.sendEmail(
      email,
      EmailConfig.title,
      `您的验证码为:${code},${EmailConfig.time}分钟内有效`
    );
  }</code></pre> 
<p><strong>最后在utils编写一个异步发送邮箱的函数</strong></p> 
<pre><code class="language-javascript">/* 异步发送邮箱验证
   * @method    createEmailCode
   * @for    Utils
   * @param   {Object} codeList  邮箱验证码列表
   * @param   {String} email   用户邮箱
   * @param   {Object} findRes  数据库搜寻到的用户信息
   * @return {Boolean}  isSuccess   是否发送成功
   */
  static async createEmailCode(codeList, email, findRes) {
    if (!codeList[email] || new Date().getTime() &gt; codeList[email].sendTime) {
      //已过1分钟,防止多次请求邮箱
      codeList[email] = this.randomCode();
      codeList[email].info = findRes;
      return await this.sendEmailCode(codeList[email].code, email);
    } else {
      //未过1分钟
      return false;
    }
  }</code></pre> 
<p><strong>一个发送邮件的完整模块就实现完成，下一步要做的是验证码的验证功能</strong></p> 
<pre><code class="language-javascript"> /* 核对验证码
   * @method    checkEmailCode
   * @for    Utils
   * @param   {Object} codeList  用户验证码列表
   * @param   {String} key   用户邮箱
   * @param   {Object} _data   用户提交的表单信息
   * @return   {Object} res   请求响应返回值
   */
  static checkEmailCode(codeList, key, _data) {
    if (!codeList[key]) {
      //未发送验证码
      return {
        result: 0,
        msg: "验证码错误",
      };
    } else if (
      new Date().getTime() &lt; codeList[key].targetTime &amp;&amp;
      _data.mailcode == codeList[key].code
    ) {
      //验证码校对成功
      let _obj = {
        result: 1,
        token: Utils.createToken(
          codeList[key].info.userType || "",
          codeList[key].info.username || "",
          _data.remember || ""
        ),
        msg: "操作成功",
      };
      codeList[key] = null;
      return _obj;
    } else if (new Date().getTime() &gt; codeList[key].targetTime) {
      //验证码超时
      return {
        result: 0,
        msg: "验证码超时",
      };
    } else {
      return {
        result: 0,
        msg: "验证失败",
      };
    }
  }</code></pre> 
<p><strong>到这一步，关于验证码的所有准备工作已全部实现，下一步将实现注册登录功能，其中登录有两个途径，注册时邮箱为必填值，所以可以使用邮箱验证的方式进行登录</strong></p> 
<p><strong>服务端获取验证码接口，通过一个codeType区分用户登录获取验证码和注册获取验证码</strong></p> 
<pre><code class="language-javascript">router.get(Config.ServerApi.getMailCode, async (_req, res) =&gt; {
  //用户邮箱验证
  let _data = Util.getCrypto(Util.parseUrl(_req, res).crypto);//解密参数
  //查询用户是否存在，若未找到用户，则返回错误响应值，否则异步发送邮件验证码
  let findRes = await findData(Mod, {
    mailaddress: _data.username.split('@')[0],
    mailurl: '@' + _data.username.split('@')[1],
  });
  if ((!findRes.length || !findRes) &amp;&amp; _data.codeType !== 'reg') {//过滤区分用户注册登录
    res.send({
      result: 0,
      msg: "用户未注册"
    });
    return;
  }
  await Util.createEmailCode(userCodeList, _data.username, findRes[0] || {}) ? res.send({
    result: 1,
    msg: "发送成功",
  }) : res.send({
    result: 0,
    msg: "发送失败"
  });
});</code></pre> 
<p><strong>在实现注册部分之前，我们要写一个工具方法，用于验证码倒计时，在此期间用户无法再次点击发送请求</strong></p> 
<pre><code class="language-javascript">import Vue from "vue";
import Config from "../config/config";
const { GetCodeTime, CodeText } = Config;
class TimeTick {
  static timer = GetCodeTime / 1000;//倒计时时间
  static _timeTick = null;//定时器
  static timeTick(fn) {
    if (!TimeTick._timeTick) {
      TimeTick._timeTick = setInterval(() =&gt; {
        if (TimeTick.timer-- &lt;= 1) {
          // 重置倒计时和发送邮箱验证开关
          TimeTick.clearTick();
          fn({ content: CodeText, res: 1 });//倒计时归零
        } else {
          fn({ content: TimeTick.timer + "S", res: 0 });//倒计时中，阻止用户重复点击
        }
      }, 1000);
    }
  }
  static clearTick() {
    //清除定时器
    clearInterval(TimeTick._timeTick);
    TimeTick._timeTick = null;
  }
}
Vue.prototype.$timeTick = TimeTick;
</code></pre> 
<p><strong>&nbsp;用户注册界面</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div class="login"&gt;
    &lt;div&gt;
      &lt;mt-field
        placeholder="请输入用户名"
        :state="userInfo.username.length ? 'success' : 'error'"
        v-model="userInfo.username"
      &gt;&lt;/mt-field&gt;
      &lt;mt-field
        placeholder="请输入密码"
        :state="userInfo.password.length ? 'success' : 'error'"
        v-model="userInfo.password"
        type="password"
      &gt;&lt;/mt-field&gt;
      &lt;mt-field
        placeholder="请重复输入密码"
        :state="
          userInfo.repassword.length &amp;&amp; userInfo.password == userInfo.repassword
            ? 'success'
            : 'error'
        "
        v-model="userInfo.repassword"
        type="password"
      &gt;&lt;/mt-field&gt;
      &lt;mt-field
        placeholder="请输入邮箱"
        v-model="userInfo.mailaddress"
        :state="userInfo.mailaddress.length ? 'success' : 'error'"
      &gt;
        &lt;mt-button class="btn" @click="selectMail"&gt;{<!-- -->{
          userInfo.mailurl
        }}&lt;/mt-button&gt;
      &lt;/mt-field&gt;
      &lt;mt-field
        placeholder="请输入验证码"
        :state="userInfo.mailcode.length == 4 ? 'success' : 'error'"
        v-model="userInfo.mailcode"
        type="number"
      &gt;
        &lt;mt-button class="btn" :disabled="canGetCode" @click="getCode"&gt;{<!-- -->{
          codeTime
        }}&lt;/mt-button&gt;
      &lt;/mt-field&gt;
      &lt;mt-button class="btn" type="primary" @click="submit"&gt;注册&lt;/mt-button&gt;
      &lt;div class="shopPicker"&gt;&lt;/div&gt;
      &lt;ShopPicker :ShopMaxCount="address" pickerTitle="邮箱类型"&gt;&lt;/ShopPicker&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
import Mail from "../../config/mail";
import ShopPicker from "../shopPicker/shopPicker";
import { Field, Button, Picker, Popup } from "mint-ui";
import RegBussiness from "./bussiness";
const { GetCodeTime, EventName, CodeText } = Config;
const { address } = Mail;
export default {
  components: {
    ShopPicker,
  },
  data() {
    return {
      codeTime: CodeText, //获取验证码按钮显示值
      address, //邮箱默认地址
      canGetCode: false, //防止重复点击开关
      userInfo: {
        //注册表单默认数据
        username: "",
        password: "",
        repassword: "",
        mailurl: address[0],
        mailaddress: "",
        mailcode: "",
      },
    };
  },
  created() {
    this.regBussiness = new RegBussiness(this);
    this.$events.onEvent(EventName.ChangeCount, (_count) =&gt; {
      this.userInfo.mailurl = _count; //切换邮箱地址
    });
  },
  destroyed() {
    this.$events.offEvent(EventName.ChangeCount);
  },
  methods: {
    selectMail() {
      this.$events.emitEvent(EventName.ShowPicker);
    },
    getCode() {
      if (this.canGetCode) {
        //是否允许发送邮箱验证
        return;
      }
      this.regBussiness.sendCode().then((res) =&gt; {
        this.canGetCode = true;//关闭点击开关
        this.$timeTick.timeTick((state) =&gt; {
          this.codeTime = state.content;
          switch (state.res) {
            case 0:
              this.canGetCode = false;//允许用户点击
              break;
          }
        });
      });
    },
    submit() {
      this.regBussiness.submitData();
    },
  },
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";

.login {
  .btn {
    .f_s(34);
    width: 100%;
    .h(100);
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>注册业务逻辑部分，bussiness.js</strong></p> 
<pre><code class="language-javascript">import Vue from 'vue'
import {
  Toast
} from "mint-ui";
import config from "../../config/config"
const {
  ServerApi,
  StorageName,
  EventName
} = config
export default class LoginBussiness extends Vue {
  constructor(_vueComponent) {
    super()
    this.vueComponent = _vueComponent
  }
  sendCode() {
    return new Promise((resolve, reject) =&gt; {
      if (!this.vueComponent.userInfo.mailaddress.length) {//过滤邮箱长度为0
        Toast('请填写正确的邮箱');
        return
      }
      this.$axios
        .get(ServerApi.user.getMailCode, {
          params: {
            crypto: this.$crypto.setCrypto({
              codeType: "reg",//区分注册登录类型
              username: this.vueComponent.userInfo.mailaddress + this.vueComponent.userInfo.mailurl
            })
          },
        }).then(res =&gt; {
          switch (res.result) {
            case 1:
              Toast(res.msg);
              resolve(res)
              break;
            default:
              reject(res)
              break;
          }
        }).catch(err =&gt; {
          reject(err)
        })
    })

  }
  submitData() {
    for (const key in this.vueComponent.userInfo) {
      if (this.vueComponent.userInfo.hasOwnProperty(key) &amp;&amp; !this.vueComponent.userInfo[key].length) {//过滤表单项长度为0
        Toast('请填写完整的信息');
        return
      }
    }
    this.$axios
      .post(ServerApi.user.userReg, {
        crypto: this.$crypto.setCrypto({
          ...this.vueComponent.userInfo
        })
      }).then(res =&gt; {
        //成功后重置用户信息
        this.vueComponent.userInfo.password = "";
        this.vueComponent.userInfo.repassword = "";
        this.vueComponent.userInfo.mailcode = "";
        switch (res.result) {
          case 1:
            Toast(res.msg);
            history.go(-1)//返回登录页面
            break;
          default:
            break;
        }
      })
  }
}
</code></pre> 
<p><strong>注册部分完成，登录与注册功能类似，这里只介绍一下服务端token的生成</strong></p> 
<p><strong>在服务端user.js中修改接口，和管理系统登录一样，新增邮箱验证登录，区分管理员和用户登录</strong></p> 
<pre><code class="language-javascript">router.post(Config.ServerApi.userLogin, async (req, res) =&gt; {
  let _data = Util.getCrypto(Util.parseUrl(req, res).crypto); //解密前端入参
  switch (_data.loginType) {
    case "code"://验证码登录，验证邮箱验证码
      res.send(Util.checkEmailCode(userCodeList, _data.username, _data));
      break;
    case "psd"://密码登录
    default:
      let findRes = await findData(Mod, {
        $or: [
          {
            mailaddress: _data.username.split("@")[0],
            mailurl: "@" + _data.username.split("@")[1],
          },
          {
            username: _data.username,
          },
          {
            phoneNum: _data.username,
          },
        ],
      });
      if (findRes &amp;&amp; findRes.length &gt; 0) {
        Util.checkBcrypt(_data.password, findRes[0].password)
          ? res.send({
              result: 1,
              token: Util.createToken(//生成前端token
                findRes[0].userType,
                findRes[0].username,
                _data.remember
              ),
              msg: "登录成功",
            })
          : res.send({
              result: 0,
              msg: "密码错误",
            });
        return;
      }
      res.send({
        result: 0,
        msg: "用户不存在",
      });
      break;
  }
});</code></pre> 
<p><strong>总结<br> 本篇文章将用户的注册登录邮箱验证功能基本实现，主要功能参照之前的<a href="https://blog.csdn.net/time_____/article/details/84714723">邮箱验证登录注册的博客</a>，文章中的重点是邮箱验证功能模块，与注册登录配合使用，注册则新增用户，登录则更新token值。下一篇将介绍用户信息修改，及后续将实现订单的生成及查看功能</strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十六）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806819.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806819.html</guid><description><![CDATA[
                    <p><strong>从零开始，搭建一个简单的购物平台（十五）前端商城部分：<br><a href="https://blog.csdn.net/time_____/article/details/108680599">https://blog.csdn.net/time_____/article/details/108680599</a><br> 项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>在前几篇文章中，我们对首页，分类列表，公共组件，工具类进行了实现，这篇文章将实现商品详情页进行介绍，这里我们将商品详情页细化成多个组件，利用组件通信方式进行监听传递方式从而实现数据传递和效果逻辑<br> 先来看看效果</strong><br><img alt="" height="298" src="https://img-blog.csdnimg.cn/20200924110347986.gif" width="170"></p> 
<p><strong>这个界面我们可以把页面分解成几个组件，分别是顶部的Top，商品信息展示，商品选项框及加入购物车按钮，最后是下方的一个tab切换效果</strong></p> 
<h3><strong>商品选项框：</strong></h3> 
<p><strong>首先对mint-ui官方的Picker，Navbar进行简单的二次封装，然后在商品选项框及加入购物车按钮组件中触发picker组件，加入购物车中有一个添加的动画需要用到animate动画，并将全局购物车列表更新</strong></p> 
<ul><li><strong>shopPicker.vue,封装官方组件，通过商品最大数量显示列表</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div class="shopPicker"&gt;
    &lt;mt-popup v-model="popupVisible" position="bottom"&gt;
      &lt;mt-picker class="pickerItem" :slots="count" :showToolbar="true" @change="onValuesChange"&gt;
        &lt;div&gt;{<!-- -->{pickerTitle}}&lt;/div&gt;
      &lt;/mt-picker&gt;
    &lt;/mt-popup&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { Picker, Popup } from "mint-ui";
import Config from "../../config/config";
const { EventName } = Config;
export default {
  name: "shopPicker",
  props: ["ShopMaxCount","pickerTitle"],//最大购买数，picker的标题
  data() {
    return {
      popupVisible: false,//是否显示组件
      count: [{ flex: 1, values: [] }]//组件默认模板
    };
  },
  mounted() {
    this.createShopCount();//初始化组件
    this.$events.onEvent(EventName.ShowPicker, this.showPicker);//监听显示picker事件
  },
  destroyed() {
    this.$events.offEvent(EventName.ShowPicker);//注销显示picker事件
  },
  methods: {
    onValuesChange(comp, count) {//数据变化时触发counter中的显示商品数量
      this.$events.emitEvent(EventName.ChangeCount, count[0]);
    },
    showPicker() {
      this.popupVisible = true;
    },
    createShopCount() {//根据传进来的最大数量显示商品数量列表
      this.count[0].values = this.ShopMaxCount;
      for (let i = 0; i &lt; this.ShopMaxCount; i++) {
        this.count[0].values.push(i + 1);
      }
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";

&lt;/style&gt;</code></pre> </li><li><strong>&nbsp;修改navbar样式并应用至自己组件中</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div class="info"&gt;
    &lt;mt-navbar v-model="selected"&gt;
      &lt;mt-tab-item v-for="(item,index) in navTitle" :key="index" :id="item.val"&gt;{<!-- -->{item.name}}&lt;/mt-tab-item&gt;
    &lt;/mt-navbar&gt;
    &lt;mt-tab-container v-model="selected"&gt;
      &lt;mt-tab-container-item class="doc" id="0"&gt;
        &lt;div&gt;名称：{<!-- -->{shopName}}&lt;/div&gt;
        &lt;div&gt;类型：{<!-- -->{Type[shopType].name}}&lt;/div&gt;
        &lt;div&gt;数量：{<!-- -->{shopNum}}个&lt;/div&gt;
        &lt;div&gt;￥{<!-- -->{shopPrice}}元&lt;/div&gt;
      &lt;/mt-tab-container-item&gt;
      &lt;mt-tab-container-item class="doc" id="1"&gt;
        &lt;div&gt;净含量/克(g)：{<!-- -->{shopScale}}&lt;/div&gt;
        &lt;div&gt;口味：{<!-- -->{taste}}&lt;/div&gt;
        &lt;div&gt;产地：{<!-- -->{address}}&lt;/div&gt;
        &lt;div&gt;保质期：{<!-- -->{expiryDate}}&lt;/div&gt;
        &lt;div&gt;上架时间：{<!-- -->{time}}&lt;/div&gt;
      &lt;/mt-tab-container-item&gt;
      &lt;mt-tab-container-item id="2"&gt;
        &lt;h3&gt;7天包退&lt;/h3&gt;
        &lt;h3&gt;15天包换&lt;/h3&gt;
        &lt;h3&gt;一年保修&lt;/h3&gt;
      &lt;/mt-tab-container-item&gt;
    &lt;/mt-tab-container&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { Navbar, TabItem } from "mint-ui";
import NavConfig from "../../config/navConfig";
import ShopType from "../../config/shopType";

export default {
  name: "infoNav",
  data() {
    return {
      selected: "0",//默认选中第一项
      navTitle: NavConfig.NavTitle,
      Type: ShopType.shopType,
      ...this.$route.query//路由传参，将商品信息传递到data中
    };
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
@fontcolor: #bababa;
.info {
  .mg(20px auto);
  .navBar();
  h3 {
    text-align: center;
    color: @mainColor;
  }
  .doc div {
    text-align: center;
    padding: 0.625rem 0;
  }
}
&lt;/style&gt;</code></pre> <p>&nbsp;</p> </li><li> <p><strong>&nbsp;这里的一个难点是加入购物车的动画，想了很多种方法，<br> 最后采用一个标签隐藏，另一个标签执行动画的方式让动画效果更好，<br> 通过showAnimate变量进行控制执行动画的标签v-show</strong><br><img alt="" height="359" src="https://img-blog.csdnimg.cn/20200925202414436.gif" width="205"></p> <p><strong>在动画标签里使用animate.css中的zoomOutUp 效果</strong></p> <pre><code class="language-html">&lt;transition enter-active-class="animated zoomOutUp slow"&gt;
        &lt;span v-show="showAnimate" class="icon-jiarugouwuche iconfont addIcon"&gt;&lt;/span&gt;
&lt;/transition&gt;</code></pre> <p><strong>&nbsp;当点击加入购物车时触发事件</strong></p> <pre><code class="language-javascript">addShopCar() {
      this.showAnimate = true;//显示元素
      setTimeout(() =&gt; {//延时的目的是等待动画完成
        this.shopCar.countShopItem({//缓存添加购物车数据
          ...this.$route.query,
          shopCount: this.shopCount
        });
        this.showAnimate = false;//隐藏元素
      }, 1000);
    }</code></pre> <p><strong>完整的counter组件</strong></p> <pre><code class="language-html">&lt;template&gt;
  &lt;ul class="counter"&gt;
    &lt;li @click="showPicker"&gt;
      数量
      &lt;span&gt;{<!-- -->{shopCount}}&lt;/span&gt;
    &lt;/li&gt;
    &lt;li @click="addShopCar"&gt;
      加入购物车
      &lt;span class="icon-jiarugouwuche iconfont"&gt;&lt;/span&gt;
      &lt;transition enter-active-class="animated zoomOutUp slow"&gt;
        &lt;span v-show="showAnimate" class="icon-jiarugouwuche iconfont addIcon"&gt;&lt;/span&gt;
      &lt;/transition&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
const { EventName } = Config;
export default {
  name: "Counter",
  data() {
    return {
      shopCount: 1,//默认购买商品数量
      showAnimate: false//动画标签隐藏
    };
  },
  created() {
    this.$events.onEvent(EventName.ChangeCount, _count =&gt; {//添加事件监听，监听商品数量变化
      this.shopCount = _count;
    });
    this.shopCar = new this.$store.ShopCar();
  },
  destroyed() {
    this.$events.offEvent(EventName.ChangeCount);
  },
  methods: {
    showPicker() {
      this.$events.emitEvent(EventName.ShowPicker);
    },
    addShopCar() {
      this.showAnimate = true;//显示元素
      setTimeout(() =&gt; {//延时的目的是等待动画完成
        this.shopCar.countShopItem({//缓存添加购物车数据
          ...this.$route.query,
          shopCount: this.shopCount
        });
        this.showAnimate = false;//隐藏元素
      }, 1000);
    }
  }
};
&lt;/script&gt;
&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.counter {
  .h(120);
  .w(850);
  background: @mainColor;
  border-radius: 4rem;
  margin: 0 auto;
  .l_h(120);
  li {
    width: 49%;
    display: inline-block;
    .h(46);
    .l_h(46);
    .titleFont();
    .f_s(32);
    text-align: center;
  }
  li:nth-child(2) {
    margin-left: -2px;
    border-left: 1px dashed #dacda3;
    .addIcon {
      position: fixed;
      .f_s(75);
      z-index: -1;
      color: black;
    }
  }
}
&lt;/style&gt;</code></pre> <p><strong>最后在全局<a href="https://blog.csdn.net/time_____/article/details/108514710">store</a>中添加购物车变量处理方法</strong></p> <pre><code class="language-javascript"> countShopItem(_data) {
    if (!_data._id) {//阻塞商品id为空现象
      return
    }
    let _shopCar = this.state//获取原购物车列表
    let list = _shopCar.filter(function (item) {
      return item._id === _data._id;//通过id查找购物车中传递项
    });
    if (list.length == 0) {//未找到时新建购物车商品
      _data.sum = _data.shopCount * _data.shopPrice;//商品总价
      _data.isSelect = false//是否选中商品，购物车界面默认值
      _shopCar.push(_data);
    } else if ((_data.shopNum &gt; list[0].shopCount + _data.shopCount) &amp;&amp; (list[0].shopCount + _data.shopCount &lt;= 9) &amp;&amp; list[0].shopCount + _data.shopCount &gt; 0) {//找到时更新商品
      list[0].shopCount += _data.shopCount;
      list[0].sum = list[0].shopCount * list[0].shopPrice;
    } else if (list[0].shopCount + _data.shopCount &lt;= 0) {//购物车允许最小值
      this.$events.emitEvent(EventName.CountShop, 'min');
      return;
    } else {//购物车允许最大值
      this.$events.emitEvent(EventName.CountShop, 'max');
      return;
    }
    this.state = _shopCar
    this.$events.emitEvent(EventName.CountShop);
  }</code></pre> <p><strong>这样，一个简单的商品详情页面就完成了</strong></p> </li></ul>
<h3><strong>下一篇文章，将介绍购物车的其他功能实现，包括删除商品，全选，添加订单接口等</strong></h3>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十五）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806820.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806820.html</guid><description><![CDATA[
                    <p><strong>从零开始，搭建一个简单的购物平台（十四）前端商城部分：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108545330">https://blog.csdn.net/time_____/article/details/108545330</a><br><strong>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>上篇文章对主页和部分公共组件进行了界面和功能实现，之前对项目用到的工具类，路由，全局状态进行了封装，这篇文章将对商品分类，商品主题界面进行介绍，实现过程同样是用到了组件内单独异步请求，减少数据堵塞</strong></p> 
<h3><strong>商品分类：</strong></h3> 
<p><strong>界面样式及效果</strong></p> 
<p><img alt="" height="410" src="https://img-blog.csdnimg.cn/20200919143346881.gif" width="234"></p> 
<p><strong>注意：由于分类商品列表和主页的商品不会时常发生变化，我们可以使用Vue中的keep-alive组件，它的作用是在组件切换时将状态保留在内存中，防止重复渲染DOM，也就是保存组件不被销毁，防止每次加载页面都做不必要的请求，实现效果如下</strong></p> 
<p><img alt="" height="403" src="https://img-blog.csdnimg.cn/20200919151037384.gif" width="230"></p> 
<p><strong>在app.vue中添加keep-alive组件包裹路由组件</strong></p> 
<pre><code class="language-html">&lt;keep-alive include="Home,Kind"&gt;
   &lt;router-view class="appView"&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre> 
<p><strong>这里我们将分类列表左右分别分成两个组件，组成一个tab切换栏，通过左边的分类菜单进行选择切换，从而重新渲染右边的商品列表</strong></p> 
<ul><li><strong>左边切换组件leftMenu.vue</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div id="left"&gt;
    &lt;div
      v-for="(item,index) in list"
      :key="index"
      @click="sel(item.val)"
      :class="item.val==onesel?'selec':''"
    &gt;{<!-- -->{item.name}}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
import ShopType from "../../config/shopType";
const { EventName } = Config;
export default {
  data() {
    return {
      list: ShopType.shopType,
      onesel: "0"//默认选中第一项
    };
  },
  methods: {
    sel(item) {
      if (this.onesel == item) return;//防止重复点击同一个选项
      this.onesel = item;
      this.$events.emitEvent(EventName.SelectKind, item);//触发选中商品类型事件
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
#left {
  .w(215);
  height: 100%;
  position: fixed;
  .f_s(34);
  border-right: unit(1 / @pxtorem, rem) solid #d6d6d6;
  margin-right: unit(215 / @pxtorem, rem);
  div {
    .h(125);
    .l_h(125);
    text-align: center;
  }
  .selec {
    border-left: unit(8 / @pxtorem, rem) solid @mainColor;
    text-indent: unit(-8 / @pxtorem, rem);
    color: @mainColor;
  }
}
&lt;/style&gt;</code></pre> <p>&nbsp;</p> </li><li> <p><strong>右边商品列表组件rightShop.vue</strong></p> <pre><code class="language-html">&lt;template&gt;
  &lt;transition name="fade"&gt;
    &lt;div class="rightShop" v-if="transitionSwitch"&gt;
      &lt;h2 id="head"&gt;
        &lt;img :src="imgPath+themeList.shopPic" v-if="themeList.shopPic" alt /&gt;
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;li v-for="(item,index) in list" :key="index" @click="clickHandler(item)"&gt;
          &lt;img :src="imgPath+item.shopPic" /&gt;
          &lt;span&gt;{<!-- -->{item.shopName}} {<!-- -->{item.shopScale}}克&lt;/span&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;
&lt;script&gt;
import Config from "../../config/config";
import RightShopBussiness from "./bussiness";
const { EventName } = Config;
export default {
  data() {
    return {
      themeList: {},
      list: [],
      imgPath: Config.RequestPath,
      rightShopBussiness: null,
      transitionSwitch: true,
      beforeIndex: 0
    };
  },
  created() {
    this.rightShopBussiness = new RightShopBussiness(this);
    this.rightShopBussiness.initPageConfig(this.beforeIndex);
    this.$events.onEvent(EventName.SelectKind, data =&gt; {//监听选择种类事件
      this.transitionSwitch = false;//通过v-show实现fade动画效果
      this.rightShopBussiness.initPageConfig(data);
    });
  },
  destroyed() {
    this.$events.offEvent(EventName.SelectKind);//销毁事件监听
  },
  methods: {
    clickHandler(data) {
      this.$router.push({ name: "ShopInfo", query: { ...data } });
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.rightShop {
  padding-left: unit(215 / @pxtorem, rem);
  img {
    width: 90%;
    display: block;
    margin: unit(40 / @pxtorem, rem) auto;
  }
  ul {
    margin-top: unit(70 / @pxtorem, rem);
    margin-bottom: unit(110 / @pxtorem, rem);
    li {
      display: inline-block;
      width: 33%;
      vertical-align: top;
      text-align: center;
      img {
        width: 70%;
        margin: 0 auto;
      }
      span {
        .f_s(28);
        text-align: center;
      }
    }
  }
}
&lt;/style&gt;</code></pre> <p>&nbsp;</p> </li><li> <p><strong>将商品分类页面加入到router配置中，与主页和购物车界面同级page下新建kind页面，商品分类页面就已经完成</strong>&nbsp;</p> <pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;Top title="分类"&gt;&lt;/Top&gt;
    &lt;div class="content"&gt;
      &lt;leftMenu&gt;&lt;/leftMenu&gt;
      &lt;rightShop&gt;&lt;/rightShop&gt;
    &lt;/div&gt;
    &lt;TabBar&gt;&lt;/TabBar&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import TabBar from "../../components/tabBar/tabBar";
import Top from "../../components/top/top";
import leftMenu from "../../components/leftMenu/leftMenu";
import rightShop from "../../components/rightShop/rightShop";
export default {
  name: "Kind",
  components: {
    Top,
    leftMenu,
    rightShop,
    TabBar
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
&lt;/style&gt;</code></pre> <p>&nbsp;</p> </li></ul>
<h3><strong>商品主题</strong></h3> 
<p><strong>商品主题页是用户通过点击首页的轮播图和主题模块进入到主题商品列表子页面，其中商品列表的单个商品可以通过主页的组件进行复用</strong></p> 
<p><img alt="" height="310" src="https://img-blog.csdnimg.cn/20200919164618282.gif" width="177"></p> 
<p><strong>其中themeList是广告标题图片，通过shopType区分首页的商品列表和主题页的商品列表，从而引入shopItem组件</strong></p> 
<ul><li><strong>themeList.vue广告标题</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div class="themeContent"&gt;
    &lt;h2&gt;
      &lt;img v-if="themeList.shopPic" :src="imgPath+themeList.shopPic" alt /&gt;
    &lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
import ThemeListBussiness from "./bussiness";
export default {
  data() {
    return {
      themeList: {},
      imgPath: Config.RequestPath,
      themeListBussiness: null
    };
  },
  created() {
    this.themeListBussiness = new ThemeListBussiness(this);
    this.themeListBussiness.initPageConfig(this.$route.query);
  },
  methods: {}
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.themeContent {
  h2 {
    width: 100%;
    img {
      width: 100%;
    }
  }
}
&lt;/style&gt;</code></pre> <br> &nbsp;</li><li><strong>最后新建shopTheme的page页面，引入之前两个组件</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;Top :title="title" :isBack="true"&gt;&lt;/Top&gt;
    &lt;div class="content"&gt;
      &lt;ThemeList&gt;&lt;/ThemeList&gt;
      &lt;ShopItem :shopType="shopType"&gt;&lt;/ShopItem&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Top from "../../components/top/top";
import ThemeList from "../../components/themeList/themeList";
import ShopItem from "../../components/shopItem/shopItem";
export default {
  name: "ShopTheme",
  data() {
    return {
      shopType: this.$route.query._type,
      title: this.$route.query._shopName
    };
  },
  components: {
    Top,
    ThemeList,
    ShopItem
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.content {
  padding-bottom: 0;
}
&lt;/style&gt;</code></pre> <p><strong>至此商品分类和主题列表页面就实现完成</strong><br> &nbsp;</p> </li></ul>
<p><strong>最后提供商品数据库数据下载（都是一个一个手动输入的），<a href="https://gitee.com/DieHunter/myCode/blob/master/shopping/shop.txt">远程仓库地址</a>，可以通过Robo3t进行导入</strong><br><strong>本篇文章结束，下一篇将介绍商品详情页的实现</strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十七）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806818.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:38:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806818.html</guid><description><![CDATA[
                    <p><strong>从零开始，搭建一个简单的购物平台（十六）前端商城部分：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108769229">https://blog.csdn.net/time_____/article/details/108769229</a><br><strong>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>上篇文章讲到了商品详情页面实现，最后一个功能是加入购物车，也就是通过列表对比商品是否存在，若存在，则对现有商品数据进行修改，若不存在，则初始化商品，并添加至购物车列表中，这篇文章将介绍对购物车数据进行操作功能</strong></p> 
<p><strong>购物车功能包括<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;修改商品数量&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 删除单个商品&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;全选/反选&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;批量删除</strong></p> 
<p><img alt="" height="430" src="https://img-blog.csdnimg.cn/2020100217110615.gif" width="200"><img alt="" height="430" src="https://img-blog.csdnimg.cn/20201002171635715.gif" width="200"><img alt="" height="428" src="https://img-blog.csdnimg.cn/20201002171956566.gif" width="199"><img alt="" height="426" src="https://img-blog.csdnimg.cn/20201002172227950.gif" width="198"></p> 
<p><strong>这个页面，将其分解成四个组件，分别是顶部的Title，菜单栏Tabbar，单件商品shopCarItem和下面的批量操作shopCarOrder</strong></p> 
<p><strong>修改商品数量在<a href="https://blog.csdn.net/time_____/article/details/108769229">上篇文章</a>中已介绍，通过countShopItem方法进行修改</strong></p> 
<p><strong>删除单个商品</strong></p> 
<pre><code class="language-javascript">delShopItem(_id) {
    let _shopCar = this.state//获取现有购物车列表
    _shopCar.splice(_id, 1)//数组删除第_id项
    this.state = _shopCar//刷新购物车列表
    this.$events.emitEvent(EventName.CountShop);//刷新界面
  }</code></pre> 
<p><strong>全选/反选，这里有两个注意的地方，全选/反选的实现有两种状态，一是每个商品单选被全选或反选后全选按钮也会跟随状态，二是全选按钮全选或反选后所有单选按钮也会跟随状态</strong></p> 
<p><strong>我们首先在store的action加一个方法，用于总计商品的全选状态，商品总数，及总价格。每当商品被选中，就触发这个方法，刷新数据</strong></p> 
<pre><code class="language-javascript">  filterSelect() {//修改商品全选，单个商品驱动全选按钮，刷新数据
    let shopConfig = {//所有商品总计初始值
      _count: 1,//是否全选
      _selCount: 0,//商品总数
      _sum: 0//商品总价
    }
    this.state.forEach(item =&gt; {
      shopConfig._selCount += item.isSelect ? 1 : 0;
      shopConfig._count *= item.isSelect;//判断是否全选，初始值0，若全为false，相乘等于0，若全为true，相乘为1，即等于1是全选，等于0是未全选
      shopConfig._sum += item.isSelect ? item.sum : 0
    });
    this.$events.emitEvent(EventName.SelectParent, shopConfig);
  }</code></pre> 
<p><strong>此外，我们需要再写个方法，用于全选按钮修改各个商品的选中状态</strong></p> 
<pre><code class="language-javascript">  selAllChild(_sel) {//修改商品全选，全选按钮驱动单个商品，刷新数据
    this.state = this.state.map(item =&gt; {
      item.isSelect = _sel;//当全选按钮选中，修改所有商品状态
      return item;
    });
    this.$events.emitEvent(EventName.SelectAllChild);
  }</code></pre> 
<p><strong>于是在单件商品shopCarItem组件中，我们进行调用action中的方法，修改全局state值</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;ul v-if="shopList.length" class="shopCar"&gt;
      &lt;li v-for="(item,index) in shopList" :key="index"&gt;
        &lt;span class="mint-checkbox" @click="selectHandler(index)"&gt;
          &lt;input class="mint-checkbox-input" type="checkbox" :checked="item.isSelect" /&gt;
          &lt;span class="mint-checkbox-core"&gt;&lt;/span&gt;
        &lt;/span&gt;
        &lt;img :src="imgPath+item.shopPic" alt /&gt;
        &lt;div class="shopInfo"&gt;
          &lt;div&gt;
            &lt;span&gt;{<!-- -->{item.shopName}} {<!-- -->{item.shopScale}}克&lt;/span&gt;
            &lt;span&gt;￥{<!-- -->{item.shopPrice}}&lt;/span&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;mt-button class="minus" type="default" @click="minusShopHandler(item)"&gt;-&lt;/mt-button&gt;
            &lt;span&gt;{<!-- -->{item.shopCount}}&lt;/span&gt;
            &lt;mt-button class="add" type="default" @click="addShopHandler(item)"&gt;+&lt;/mt-button&gt;
            &lt;mt-button class="del" type="default" @click="delShopHandler(index)"&gt;×&lt;/mt-button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;div v-else class="noShop"&gt;
      &lt;div class="icon-jiarugouwuche iconfont"&gt;&lt;/div&gt;
      &lt;span&gt;购物车为空&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
import { Toast } from "mint-ui";
const { EventName } = Config;
export default {
  name: "shopCarItem",
  data() {
    return {
      shopCar: null,//初始化购物车
      shopList: [],//购物车列表state
      imgPath: Config.RequestPath,//静态文件根目录
      selectAll: false,//全选
    };
  },
  created() {
    this.shopCar = new this.$store.ShopCar();
    this.shopList = this.shopCar.state;
    this.$events.onEvent(EventName.CountShop, this.countHandler);//商品数量监听
    this.$events.onEvent(EventName.SelectAllChild, this.selAllHandler);//商品全选监听
  },
  mounted() {
    this.shopCar.filterSelect();//初始化全选，商品数量，商品总价
  },
  destroyed() {
    this.$events.offEvent(EventName.CountShop, this.countHandler);
    this.$events.offEvent(EventName.SelectAllChild, this.selAllHandler);
  },
  methods: {
    countHandler(res) {//修改商品数量，刷新数据
      this.shopList = this.shopCar.state;
      this.shopCar.filterSelect();
    },
    selectHandler(_id) {//修改商品全选，单个商品驱动全选按钮，刷新数据
      this.shopList[_id].isSelect = !this.shopList[_id].isSelect;
      this.shopCar.state = this.shopList;
      this.shopCar.filterSelect();
    },
    selAllHandler() {//修改商品全选，全选按钮驱动单个商品，刷新数据
      this.shopList = this.shopCar.state;
      this.shopCar.filterSelect();
    },
    addShopHandler(_data) {//添加商品，刷新数据
      _data.shopCount = 1;
      this.shopCar.countShopItem({
        ..._data,
      });
    },
    minusShopHandler(_data) {//减少商品，刷新数据
      _data.shopCount = -1;
      this.shopCar.countShopItem({
        ..._data,
      });
    },
    delShopHandler(_id) {//删除单个商品，刷新数据
      this.shopCar.delShopItem(_id);
    },
  },
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.noShop {
  width: 100%;
  height: 100%;
  text-align: center;
  span {
    .f_s(36);
  }
  div {
    .w(200);
    .h(200);
    border-radius: 100%;
    background: @mainColor;
    .titleFont();
    box-shadow: 5px 5px 8px #777;
    .l_h(200);
    text-align: center;
    margin: 100px auto 20px;
    .f_s(100);
  }
}
.shopCar {
  .padbottom(130);
  width: 100%;
  li {
    border-bottom: 1px solid #d3d3d3;
    padding-left: unit(35 / @pxtorem, rem);
    .h(320);
    .mint-checkbox {
      .h(320);
      .l_h(320);
      display: inline-block;
      vertical-align: middle;
    }
    .mint-checkbox-input:checked + .mint-checkbox-core {
      background: #ea3e3c;
      border-color: #ea3e3c;
    }
    img {
      .h(265);
      .w(265);
      margin-left: unit(20 / @pxtorem, rem);
      display: inline-block;
      vertical-align: middle;
      background: #f5f6f5;
    }
    .shopInfo {
      .h(235);
      width: 50%;
      .padtop(30);
      padding-left: unit(10 / @pxtorem, rem);
      display: inline-block;
      vertical-align: middle;
      div:nth-child(1) {
        overflow: hidden;
        span {
          float: left;
        }
        span:nth-child(2) {
          float: right;
        }
      }
      div:nth-child(2) {
        margin-top: unit(85 / @pxtorem, rem);
        span {
          display: inline-block;
          vertical-align: middle;
          padding: 0 unit(50 / @pxtorem, rem);
        }
        .add,
        .minus,
        .del {
          display: inline-block;
          vertical-align: middle;
          background: white;
          box-shadow: none;
          .f_s(50);
        }
        .del {
          float: right;
        }
      }
    }
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>在批量操作shopCarOrder组件中同理</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div class="shopOrder"&gt;
    &lt;span class="mint-checkbox" @click="selectHandler"&gt;
      &lt;input class="mint-checkbox-input" type="checkbox" :checked="isSelAll" /&gt;
      &lt;span class="mint-checkbox-core"&gt;&lt;/span&gt;
    &lt;/span&gt;
    &lt;span&gt;全选({<!-- -->{selCount}})&lt;/span&gt;
    &lt;span @click="delSelShop"&gt;删除({<!-- -->{selCount}})&lt;/span&gt;
    &lt;span&gt;
      &lt;span&gt;￥{<!-- -->{sum}}&lt;/span&gt;
      &lt;span class="icon-qianjin iconfont" @click="sendOrder"&gt;&lt;/span&gt;
    &lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Config from "../../config/config";
import ShopCarOrderBussiness from "./bussiness";
import { Toast } from "mint-ui";
const { EventName } = Config;
export default {
  name: "shopCarOrder",
  data() {
    return {
      shopCar: null,
      isSelAll: false,//全选
      selCount: 0,//商品数量
      sum: 0,//商品总价
      orderList: null,//提交订单请求参数
      shopCarOrderBussiness: null,
    };
  },
  created() {
    this.shopCar = new this.$store.ShopCar();
    this.shopCarOrderBussiness = new ShopCarOrderBussiness(this);
    this.$events.onEvent(EventName.SelectParent, this.selAllHandler);//全选按钮监听，通过监听所有商品都选中或未全选，修改状态
  },
  destroyed() {
    this.$events.offEvent(EventName.SelectParent, this.selAllHandler);
  },
  methods: {
    selectHandler() {//驱动修改所有商品选中状态
      this.isSelAll = !this.isSelAll;
      this.shopCar.selAllChild(this.isSelAll);
    },
    selAllHandler({ _count, _selCount, _sum }) {
      this.isSelAll = _count;
      this.selCount = _selCount;
      this.sum = _sum;
    },
    delSelShop() {//删除选中商品
      this.shopCar.delSelShop();
    },
    sendOrder() {//提交订单
      this.shopCarOrderBussiness.sendOrderList();
    },
  },
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.shopOrder {
  .f_s(34);
  color: #fff;
  position: fixed;
  .mcolor();
  bottom: unit(130 / @pxtorem, rem);
  width: 100%;
  .h(130);
  .l_h(130);
  &gt; span:nth-child(1),
  &gt; span:nth-child(2) {
    padding-left: unit(35 / @pxtorem, rem);
  }
  &gt; span:nth-child(3) {
    padding-left: unit(200 / @pxtorem, rem);
  }

  &gt; span:nth-child(4) {
    float: right;
    margin-right: unit(50 / @pxtorem, rem);
    &gt; span:nth-child(1) {
      padding-left: unit(20 / @pxtorem, rem);
      border-left: 1px dashed #fff;
    }
    &gt; span:nth-child(2) {
      padding-left: unit(50 / @pxtorem, rem);
    }
  }
  &gt; span {
    display: inline-block;
  }
  .mint-checkbox-input + .mint-checkbox-core {
    background: transparent;
    border-color: #fff;
  }
  .mint-checkbox-input:checked + .mint-checkbox-core {
    .mcolor();
  }
}
&lt;/style&gt;</code></pre> 
<p><strong>在action中，我们还需要写一个函数，用于删除选中商品</strong></p> 
<pre><code class="language-javascript">delSelShop() {//直接通过遍历商品选中状态值进行删除，并刷新数据
    let _list = []
    this.state.map(item =&gt; {
      if (!item.isSelect) {
        _list.push(item)
      }
    });
    this.state = _list
    this.$events.emitEvent(EventName.CountShop);
  }</code></pre> 
<p><strong>最后，在shopCar.vue界面中引入这四个组件，页面实现完成</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;Top title="购物车"&gt;&lt;/Top&gt;
    &lt;div class="content"&gt;
      &lt;ShopCarItem&gt;&lt;/ShopCarItem&gt;
      &lt;ShopCarOrder&gt;&lt;/ShopCarOrder&gt;
    &lt;/div&gt;
    &lt;TabBar&gt;&lt;/TabBar&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Top from "../../components/top/top";
import ShopCarItem from "../../components/shopCarItem/shopCarItem";
import ShopCarOrder from "../../components/shopCarOrder/shopCarOrder";
import TabBar from "../../components/tabBar/tabBar";
export default {
  name: "shopCar",
  data() {
    return {};
  },
  components: {
    Top,
    ShopCarItem,
    ShopCarOrder,
    TabBar
  },
  created() {}
};
&lt;/script&gt;
&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
&lt;/style&gt;</code></pre> 
<p><strong>本篇文章主要对商品购物车操作进行了介绍，其中运用了数据刷新视图的基本操作，将数据，逻辑，视图三者分开，结合vue的数据绑定渲染页面。下篇文章将实现用户的注册，登录功能（简单的用户名密码注册，登录，和邮箱验证模块）</strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十四）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806821.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:37:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806821.html</guid><description><![CDATA[
                    <p id="articleContentId"><strong>从零开始，搭建一个简单的购物平台（十三）前端商城部分：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108514710">https://blog.csdn.net/time_____/article/details/108514710</a><br><strong>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>本篇文章介绍实现部分组件和首页部分，首页组件如下，首页中的数据通过分批异步加载，也就是每个组件的数据单独请求，减少数据请求堵塞，下面介绍一下实现过程</strong><br><img alt="" height="267" src="https://img-blog.csdnimg.cn/20200912100130255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="150"><img alt="" height="268" src="https://img-blog.csdnimg.cn/20200912100228766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="151"></p> 
<h3>pageTitle（页面标题）</h3> 
<ul><li><strong>首先要考虑到标题的返回功能，在methods里写个路由返回函数</strong> <pre><code class="language-javascript"> methods: {
    goBack() {
      this.$router.go(-1);
    }
  }</code></pre> <p>&nbsp;</p> </li><li> <p><strong>接着通过组件属性传参数（标题内容，是否有返回按钮）&nbsp;，通过props将组件属性放在当前data中</strong></p> <pre><code class="language-javascript">props: ["title", "isBack"],</code></pre> <p>&nbsp;</p> </li><li> <p><strong>标签中根据isBack决定是否有返回按钮，并显示title值</strong></p> <pre><code class="language-html">&lt;template&gt;
  &lt;div id="top"&gt;
    &lt;span v-if="isBack" class="back iconfont icon-fanhui" @click="goBack"&gt;&lt;/span&gt;
    &lt;span class="title"&gt;{<!-- -->{title}}&lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre> <p>&nbsp;</p> </li></ul>
<h3>banner（主页轮播）</h3> 
<ul><li><strong>轮播图组件中的图片是单独请求的，所以用了model管理数据，bussiness进行请求，后面的组件有数据请求交互都是用这种写法</strong><br><img alt="" height="86" src="https://img-blog.csdnimg.cn/20200912111431120.png" width="238"></li><li><strong>model.js内容，保存banner列表，vue实例，页面配置信息</strong> <pre><code class="language-javascript">export default class BannerModel {//banner数据存取
  constructor() {
    this._bannerList = []
    this._pageConfig = {}
  }
  static getInstance() { //单例写法
    if (!BannerModel._instance) {
      Object.defineProperty(BannerModel, "_instance", {
        value: new BannerModel()
      })
    }
    return BannerModel._instance;
  }
  set vueComponent(val) {
    this._vueComponent = val
  }
  get vueComponent() {
    return this._vueComponent
  }
  set pageConfig(val) {
    this._pageConfig = val
    this._pageConfig.picType = 1
  }
  get pageConfig() {
    return this._pageConfig
  }
  set bannerList(val) {
    this._bannerList = val
    this._vueComponent.list = this.bannerList
  }
  get bannerList() {
    return this._bannerList
  }
}
</code></pre> </li><li><strong>bussiness.js 做请求和逻辑处理</strong> <pre><code class="language-javascript">import Vue from 'vue'
import config from "../../config/config"
import BannerModel from "./model";
import Clone from "../../utils/clone"
const {
  DefaultPageConfig,
  ServerApi
} = config
export default class BannerBussiness extends Vue {//业务处理
  constructor(_vueComponent) {
    super()
    BannerModel.getInstance().vueComponent = _vueComponent//取到显示层vue实例
    this.initPageConfig()
    this.getBanner()
  }
  initPageConfig() {//拷贝分页默认配置，并且不更改原常量
    BannerModel.getInstance().pageConfig = Clone.shallowClone(DefaultPageConfig)
  }
  getBanner() {//请求处理，this.$crypto.setCrypto加密
    this.$axios
      .get(ServerApi.shop.shopList, {
        params: {
          crypto: this.$crypto.setCrypto(BannerModel.getInstance().pageConfig)
        },
      }).then(res =&gt; {
        switch (res.result) {
          case 1:
            BannerModel.getInstance().bannerList = res.data.list
            break;
          default:
            break;
        }
      })
  }
}
</code></pre> </li><li><strong>banner.vue页面展示</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div class="swiper"&gt;
    &lt;mt-swipe :auto="3000"&gt;
      &lt;mt-swipe-item v-for="(item,index) in list" :key="index"&gt;
        &lt;img class="imgs" :src="imgPath+item.shopPic" @click="clickHandler(item)" /&gt;
      &lt;/mt-swipe-item&gt;
    &lt;/mt-swipe&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { Swipe, SwipeItem } from "mint-ui";
import Config from "../../config/config";
import BannerBussiness from "./bussiness";
export default {
  name: "banner",
  data() {
    return {
      list: [],//图片列表
      imgPath: Config.RequestPath//图片根路径
    };
  },
  created() {
    this.init();
  },
  methods: {
    init() {
      new BannerBussiness(this);//初始化banner请求
    },
    clickHandler(_shop) {//banner点击跳转
      this.$router.push({
        name: "ShopTheme",
        query: { _type: _shop.shopType, _shopName: _shop.shopName }
      });
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.imgs {
  .h(500);
  width: 100%;
}
.swiper {
  width: 100%;
  .h(500);
}
&lt;/style&gt;</code></pre> </li></ul>
<h3>&nbsp;tableBar（导航栏）</h3> 
<ul><li><strong>在iconfont下载相对应的图标字体资源，我这里直接下载在<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping/client/shopclient/src/style">style目录</a>下，用类名的方式显示，在tabbar文件夹新建model.js用于取数据（其实这个可以放到config）</strong> <pre><code class="language-javascript">export default class TableBarModel {
  static MenuList = [{
      name: "主页",
      path: "/Home",
      icon: "icon-shouye li iconfont"
    },
    {
      name: "分类",
      path: "/Kind",
      icon: "icon-fenlei li iconfont"
    },
    {
      name: "购物车",
      path: "/ShopCar",
      icon: "icon-daohang-gouwuche li iconfont"
    },
    {
      name: "我的",
      path: "/Info",
      icon: "icon-wode li iconfont"
    }
  ]
}
</code></pre> </li><li><strong>tabbar.vue ,通过列表</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;ul id="tab"&gt;
    &lt;router-link
      v-for="(item, index) in menuList"
      :key="index"
      :to="item.path"
      tag="li"
      :class="item.icon"
      active-class="change"
      replace
    &gt;
      &lt;br /&gt;
      {<!-- -->{item.name}}
    &lt;/router-link&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
import tableBarModel from "./model";
export default {
  name: "tabBar",
  data() {
    return {
      menuList: tableBarModel.MenuList
    };
  }
};
&lt;/script&gt;

&lt;style lang='less' scoped&gt;
@import "../../style/init.less";
#tab {
  display: flex;
  
  box-shadow: -1px 0 8px #999;
  z-index: 100;
  justify-content: space-around;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  .h(130);
  .bcolor();
  .li {
    .h(130);
    box-sizing: border-box;
    padding-top: unit(10 / @pxtorem, rem);
    width: 25%;
    text-align: center;
    .fontColorOff();
  }
  .li::before {
    .f_s(58);
  }
  .li {
    .f_s(26);
  }
  .change {
    .fontColorOn();
  }
}
&lt;/style&gt;</code></pre> </li></ul>
<h3>title（标题）</h3> 
<ul><li><strong>title用h2简单做了个样式修改</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;{<!-- -->{title}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ["title"]
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
h2 {
  .h2Font();
}
&lt;/style&gt;</code></pre> </li></ul>
<h3>shopItem（商品列表）&nbsp;</h3> 
<ul><li><strong>新建model.js存放可读写商品列表，vue组件实例和默认分页配置</strong> <pre><code class="language-javascript">export default class ItemModel {//存放可读写商品列表，vue组件实例和默认分页配置
  constructor() {
    this._shopList = []//商品列表
    this._pageConfig = {}//默认分页配置
  }
  static getInstance() { //单例写法
    if (!ItemModel._instance) {
      Object.defineProperty(ItemModel, "_instance", {
        value: new ItemModel()
      })
    }
    return ItemModel._instance;
  }
  set vueComponent(val) {
    this._vueComponent = val
  }
  get vueComponent() {
    return this._vueComponent
  }
  set pageConfig(val) {
    this._pageConfig = val
    this._pageConfig.picType = 0//默认商品类型：单个商品
  }
  get pageConfig() {
    return this._pageConfig
  }
  set shopList(val) {
    this._shopList = val
    this._vueComponent.list = this._shopList//获取到商品列表后重新渲染
  }
  get shopList() {
    return this._shopList
  }
}
</code></pre> </li><li><strong>新建做业务处理的bussiness.js</strong> <pre><code class="language-javascript">import Vue from 'vue';
import config from "../../config/config";
import ItemModel from "./model";
import Clone from "../../utils/clone";
const {
  DefaultPageConfig,
  ServerApi
} = config
export default class ItemBussiness extends Vue {
  constructor(_vueComponent) {
    super()
    ItemModel.getInstance().vueComponent = _vueComponent//Vue组件实例
    this.initPageConfig(_vueComponent.shopType)
    this.getShopItem()
  }
  initPageConfig(_shopType) {//获取默认分页配置
    ItemModel.getInstance().pageConfig = Clone.shallowClone(DefaultPageConfig)
    ItemModel.getInstance().pageConfig.shopType = _shopType
  }
  getShopItem() {//获取商品列表
    this.$axios
      .get(ServerApi.shop.shopList, {
        params: {
          crypto: this.$crypto.setCrypto(ItemModel.getInstance().pageConfig)
        },
      }).then(res =&gt; {
        switch (res.result) {
          case 1:
            ItemModel.getInstance().shopList = res.data.list//渲染页面
            break;
          default:
            break;
        }
      })
  }
}
</code></pre> </li><li><strong>在shopItem.vue中进行列表渲染，并添加点击事件，跳转至商品详情页</strong> <pre><code class="language-html">&lt;template&gt;
  &lt;ul class="more"&gt;
    &lt;li v-for="(item,index) in list" :key="index" @click="clickHandler(item)"&gt;
      &lt;img :src="imgPath+item.shopPic" alt :class="'imgs'+index" /&gt;
      &lt;span&gt;{<!-- -->{item.shopName}} {<!-- -->{item.shopScale}}克&lt;/span&gt;
      &lt;div&gt;￥{<!-- -->{item.shopPrice}}&lt;/div&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
import ShopBussiness from "./bussiness";
import Config from "../../config/config";
export default {
  name: "shopItem",
  props: ["shopType"],
  data() {
    return {
      list: [],
      imgPath: Config.RequestPath
    };
  },
  mounted() {
    new ShopBussiness(this);
  },
  methods: {
    clickHandler(data) {
      this.$router.push({ name: "ShopInfo", query: { ...data } });
    }
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
.more {
  li {
    .shopItem();
  }
}
&lt;/style&gt;</code></pre> </li></ul>
<p><strong>最后的商品主题组件和商品列表相似，添加点击事件跳转至主题详情页</strong></p> 
<h3>home页面</h3> 
<p><strong>在page文件夹下新建home文件夹以及home.vue文件，将以上组件在home中引入并构成页面，效果如下</strong><img alt="" height="416" src="https://img-blog.csdnimg.cn/20200919115822724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="234"><img alt="" height="415" src="https://img-blog.csdnimg.cn/20200919115844541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="234"></p> 
<p><strong>home.vue</strong></p> 
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;Top title="零食商贩"&gt;&lt;/Top&gt;
    &lt;div class="content"&gt;
      &lt;Banner&gt;&lt;/Banner&gt;
      &lt;H2 title="精选主题"&gt;&lt;/H2&gt;
      &lt;Theme&gt;&lt;/Theme&gt;
      &lt;H2 title="最近新品"&gt;&lt;/H2&gt;
      &lt;ShopItem :shopType="shopType"&gt;&lt;/ShopItem&gt;
    &lt;/div&gt;
    &lt;TabBar&gt;&lt;/TabBar&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import TabBar from "../../components/tabBar/tabBar";
import Top from "../../components/top/top";
import Banner from "../../components/banner/banner";
import Theme from "../../components/theme/theme";
import ShopItem from "../../components/shopItem/shopItem";
import H2 from "../../components/h2/h2";
export default {
  name: "Home",
  data() {
    return {
      shopType: ""
    };
  },
  components: {
    Top,
    H2,
    Banner,
    Theme,
    ShopItem,
    TabBar
  }
};
&lt;/script&gt;

&lt;style lang="less" scoped&gt;
@import "../../style/init.less";
&lt;/style&gt;</code></pre> 
<p><strong>以上就是主页功能实现及部分公共组件的实现，下篇文章将对商品分类列表，商品主题界面及功能进行介绍</strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十三）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806822.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:37:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806822.html</guid><description><![CDATA[
                    <p><strong>从零开始，搭建一个简单的购物平台（十二）前端商城部分</strong><strong>：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108471436">https://blog.csdn.net/time_____/article/details/108471436</a><br><strong>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>这篇文章我们来实现一下前端商城的工具类，其他配置和全局状态</strong></p> 
<h3><strong>工具类：</strong></h3> 
<ul><li><strong>工具类我们统一放在utils文件夹下，并部署在Vue原型上（与Axios的一样）</strong></li><li><strong>首先我们要实现两个对象深复制的方法，<a href="https://blog.csdn.net/time_____/article/details/85392699">之前博客</a>也有介绍到，后续对全局静态变量做操作时，只能将其定义为只读，也就是不能改变他的值，所以深复制是很有必要的，对于简单的数据用json方式即可，遇上含有function，set，get等属性时需要用到递归版。</strong><br><strong>JSON：</strong> <pre><code class="language-javascript">export default class Clone {
  static shallowClone(org) {
    return JSON.parse(JSON.stringify(org));
  }
}
</code></pre> <p><strong>递归：</strong></p> <pre><code class="language-javascript">export default class Clone {
  static deepClone(org, tag) {
    var tag = tag || {};
    var name = Object.getOwnPropertyNames(org);
    for (var i = 0; i &lt; name.length; i++) {
      var desc = Object.getOwnPropertyDescriptor(org, name[i]);
      if (typeof desc.value === "object" &amp;&amp; desc.value !== null) {
        var obj = desc.value.toString() === "[object Object]" ? {} : [];
        Object.defineProperty(tag, name[i], {
          configurable: desc.configurable,
          enumerable: desc.enumerable,
          writable: desc.writable,
          value: obj
        });
        Clone.deepClone(desc.value, obj);
      } else {
        Object.defineProperty(tag, name[i], desc);
      }
    }
    return tag;
  }
}
</code></pre> <p>&nbsp;</p> </li><li> <p>&nbsp;</p> <p><strong>本地缓存的封装</strong></p> <p>&nbsp;</p> <pre><code class="language-javascript">import Vue from "vue";
class Storage {
  static saveStorage(key, val) {
    localStorage.setItem(key, JSON.stringify(val));
  }
  static getStorage(key) {
    try {
      return JSON.parse(localStorage.getItem(key)) || [];
    } catch (error) {}
  }
  static clearStorage(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {}
  }
}
Vue.prototype.$storage = Storage;</code></pre> <p>&nbsp;</p> </li></ul>
<h3>其他配置：</h3> 
<ul><li><strong>Events：对全局事件做一个封装，这里针对每一个组件和每一个自定义事件用了一个简单的工厂模式，</strong><strong>降低代码的耦合性，解决事件封闭，但是缺点是在每一个组件销毁时需要作事件取消监听（销毁），否则会导致之前的监听事件执行两次，虽然每个子工厂生产出来的都是独特的产品，但是会导致性能降低，所以要做事件销毁处理</strong> <pre><code class="language-javascript">import Vue from "vue";
class Events extends Vue {//继承Vue的自定义事件，使其直接调用
  constructor() {
    super();
  }
  static getInstance() {//返回当前实例的单例
    if (!Events._instance) {
      Object.defineProperty(Events, "_instance", {
        value: new Events()
      });
    }
    return Events._instance;
  }
  onEvent(_event, _fn) {
    this.$on(_event, _fn);
  }
  onceEvent(_event, _fn) {
    this.$once(_event, _fn);
  }
  emitEvent(_event, _data) {
    this.$emit(_event, _data);
  }
  offEvent(_event, _fn) {
    this.$off(_event, _fn)
  }
}
Vue.prototype.$events = Events.getInstance()
</code></pre> <p>&nbsp;</p> </li><li> <p><strong>全国省市县的JSON文件</strong><br><a href="https://gitee.com/DieHunter/myCode/blob/master/shopping/client/shopclient/src/config/city.js">https://gitee.com/DieHunter/myCode/blob/master/shopping/client/shopclient/src/config/city.js</a>&nbsp;</p> </li><li> <p><strong>静态Config文件</strong></p> <pre><code class="language-javascript">export default class Config {
  static Agreement = "http://"; //协议
  static BaseUrl = "127.0.0.1"; //请求ip或域名
  static ServerUrl = ""; //多级路径名
  static ServerPort = ":1024"; //端口
  static Path = "/"; //静态文件目录
  static CryptoKey = "tokenkey"; //加密信息关键字
  static RequestPath =
    Config.Agreement + Config.BaseUrl + Config.ServerPort + Config.Path; //服务端静态目录
  static RequestTimeOut = 10 * 1000; //请求超时时间
  static GetCodeTime = 60 * 1000; //邮箱验证码重发时间
  static ShopMaxCount = [1, 2, 3, 4, 5, 6, 7, 8, 9]; //每件商品可购买数量（选择器配置）
  static ServerApi = {
    //接口名
    token: "user/checkToken", //验证token
    user: {
      userLogin: "user/userLogin", //用户登录
      getMailCode: "user/getMailCode", //获取验证码
      updateUser: "user/updateUser", //更新用户
      userReg: "user/userReg" //注册（移动端）
    },
    shop: {
      shopList: "shop/shopList" //获取商品列表
    },
    order: {
      orderList: "order/orderList", //获取订单列表
      addOrder: "order/addOrder", //新增订单
      delOrder: "order/delOrder", //删除订单
      updateOrder: "order/updateOrder" //更新订单状态
    }
  };
  static UploadName = {
    headPic: "upload/headPic" //图片路径
  };
  static UploadKey = {
    headKey: "headPic" //头像上传关键字
  };
  static StorageName = {
    //本地缓存
    Token: "token",
    ShopCar: "shopCar", //购物车列表
    UserInfo: "userInfo" //用户信息
  };
  static EventName = {
    //自定义事件
    SelectKind: "selectKind", //分类选择
    ChangeCount: "changeCount", //修改商品数量
    ShowPicker: "showPicker", //显示，隐藏Picker
    CountShop: "countShop", //购物车商品总价
    SelectAllChild: "selectAllChild", //全选子选项
    SelectParent: "selectParent", //全选父选项
    IsLogin: "isLogin", //登录成功
    UploadPic: "uploadPic" //上传图片
  };
  static DefaultPageConfig = {
    //默认分页配置
    shopType: "",
    picType: "",
    keyWord: "",
    page: 1,
    isactive: true,
    pageSize: "",
    totalPage: 1,
    orderId: "",
    sort: "1",
    orderState: ""
  };
}
</code></pre> <p>&nbsp;</p> </li><li> <p><strong>邮箱类型选择配置&nbsp;</strong></p> <pre><code class="language-javascript">export default class Mail {
  static address = [
    "@qq.com",
    "@gmail.com",
    "@yahoo.com",
    "@msn.com",
    "@hotmail.com",
    "@aol.com",
    "@ask.com",
    "@live.com",
    "@0355.net",
    "@163.com",
    "@163.net",
    "@263.net",
    "@3721.net",
    "@yeah.net",
    "@googlemail.com",
    "@mail.com"
  ];
}
</code></pre> <p>&nbsp;</p> </li><li> <p><strong>商品类型</strong></p> <pre><code class="language-javascript">export default class ShopType {
  //商品类型，图片类型，订单状态
  static shopType = [
    { name: "炒货", val: "0" },
    { name: "果味", val: "1" },
    { name: "蔬菜", val: "2" },
    { name: "点心", val: "3" },
    { name: "粗茶", val: "4" },
    { name: "淡饭", val: "5" }
    // { name: "其他", val: "6" },
  ];
  static picType = [
    { name: "单个商品", val: "0" },
    { name: "轮播图", val: "1" },
    { name: "分类", val: "2" },
    { name: "主题", val: "3" },
    { name: "其他", val: "4" }
  ];
  static orderState = [
    { name: "未付款", val: "0" },
    { name: "已付款", val: "1" },
    { name: "未发货", val: "2" },
    { name: "已发货", val: "3" },
    { name: "已完成", val: "4" },
    { name: "已退款", val: "5" }
  ];
}
</code></pre> <p>&nbsp;</p> </li></ul>
<h3>全局Store</h3> 
<ul><li><strong>全局store没有用Vuex,而是用本地缓存做了一个数据存储，在src下新建store文件夹，并新建store.js文件将所有的状态值汇总并暴露，这里我们简单搭建一下购物车，在shopCar中新建数据model层state和命令控制controller层action</strong><br><img alt="" height="135" src="https://img-blog.csdnimg.cn/20200911114237326.png" width="279"></li><li><strong>store.js</strong> <pre><code class="language-javascript">import Vue from 'vue'
import ShopCar from "./shopCar/action"
Vue.prototype.$store = {
  ShopCar
}
</code></pre> &nbsp;</li><li><strong>state.js</strong> <pre><code class="language-javascript">import Vue from "vue"
import Config from "../../config/config"
export default class State extends Vue {
  constructor() {
    super()
  }
  set shopCar(val) {//写数据
    this.$storage.saveStorage(Config.StorageName.ShopCar, val)
  }
  get shopCar() {//读数据
    return this.$storage.getStorage(Config.StorageName.ShopCar) || []
  }
}
</code></pre> <p>&nbsp;</p> </li><li> <p><strong>&nbsp;action.js</strong></p> <pre><code class="language-javascript">import State from "./state"
import Vue from "vue"
import Config from "../../config/config"
const {
  EventName
} = Config;
export default class Action extends Vue {
  constructor() {
    super()
    this._state = new State()
  }
  set state(val) {
    this._state.shopCar = val
  }
  get state() {
    return this._state.shopCar
  }
  countShopItem() {//修改商品数量
    
  }
  delShopItem() {//删除商品
    
  }
  selAllChild() {//全选
    
  }
  filterSelect() {//刷新商品列表
    
  }
  delSelShop() {//删除选择商品
    
  }
}
</code></pre> <p>&nbsp;</p> </li></ul>
<h3>引入所有包</h3> 
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App'
import router from './router'
import "./style/main.less"
import 'mint-ui/lib/style.css'
import MintUI from 'mint-ui'
import './utils/axios'
import './utils/cryptoTool'
import './utils/storage'
import "./event/event"
import "./store/store"
Vue.use(MintUI);
Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  components: {
    App
  },
  template: '&lt;App/&gt;'
})
</code></pre> 
<p><strong>到此为止，前端商城准备工作全部完成，下一篇文章正式开始进入开发</strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十二）前端商城部分</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806823.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:37:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806823.html</guid><description><![CDATA[
                    <p id="articleContentId"><strong>从零开始，搭建一个简单的购物平台（十一）：</strong><br><strong><a href="https://blog.csdn.net/time_____/article/details/108447234">https://blog.csdn.net/time_____/article/details/108447234</a><br> 项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong></p> 
<p><strong>从这篇文章开始对前端商城开发进行介绍，当然中间也会穿插着后端的新增模块一起介绍<br> 效果图地址：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping/pic">https://gitee.com/DieHunter/myCode/tree/master/shopping/pic</a><br> 效果图也附上：<br> 主页&nbsp; &nbsp; &nbsp; &nbsp;分类&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 购物车&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我的&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;商品详情&nbsp; &nbsp; &nbsp; &nbsp; 主题区&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;订单详情&nbsp; &nbsp; &nbsp;&nbsp;修改信息</strong><br><img alt="" height="206" src="https://img-blog.csdnimg.cn/20200908163819434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="36"><img alt="" height="206" src="https://img-blog.csdnimg.cn/20200908163935796.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="95"><img alt="" height="204" src="https://img-blog.csdnimg.cn/20200908164056168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="94"><img alt="" height="205" src="https://img-blog.csdnimg.cn/20200908164210585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="94"><img alt="" height="204" src="https://img-blog.csdnimg.cn/20200908164247803.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="94"><img alt="" height="204" src="https://img-blog.csdnimg.cn/2020090816433148.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="94"><img alt="" height="202" src="https://img-blog.csdnimg.cn/20200908164544345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="93"><img alt="" height="202" src="https://img-blog.csdnimg.cn/20200908164732556.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="93"></p> 
<p><strong>由于小程序和App或移动端有差别，所以个人信息页面另做修改<br> 本篇文章主要介绍一下准备工作和项目的搭建，在<a href="https://blog.csdn.net/time_____/article/details/105191286">第一篇文章</a>中已经对webpack配置以及Vue脚手架工具配置，以及其他依赖的安装进行了一个简单叙述，这里开始对准备工作做一个详细介绍，以及项目中的一些临时调整做一个说明</strong></p> 
<ul><li><strong>使用vue init webpack + 项目的名字（我这里是shopclient，名称不能有大写字母）&nbsp; &nbsp;初始化项目（一般直接全回车继续，eslink和test可选择不装）</strong></li><li><strong>&nbsp;安装完成后，我们可以简单配置一下webpack，在自动生成的config文件夹下，index.js中的配置是我们使用webpack进行build和dev时用得上的配置，这里简单介绍几个常用的：<br> dev属性：<a href="https://www.webpackjs.com/configuration/dev-server/#devserver-proxy">proxyTable</a>，用于开发环境中的代理，解决跨域，以及使用自定义接口重定向</strong> <pre><code class="language-javascript">proxyTable: {
        '/testApi':{//代理接口名，请求到/testApi会定向到http://127.0.0.1:1024/testApi下
            target:'http://127.0.0.1:1024',//目标域名
            changeOrigin:true,//是否允许跨域
            pathRewrite:{"^/testApi":''} // 把testApi替换成空
        }
    },</code></pre> <p><strong>host:&nbsp;'127.0.0.1'：本地dev项目服务器地址，通过127.0.0.1加端口号访问项目主页<br> port:&nbsp;8080：本地dev项目端口，通过服务器地址加8080访问项目主页<br> autoOpenBrowser：开发环境下项目编译完成后是否在默认浏览器自动打开项目<br> assetsPublicPath：静态文件地址，如果写成/static则通过根目录（根据上面的配置是127.0.0.1:8080/static）+/static可访问静态文件<br> build属性：index，打包后的主页路径<br> assetsRoot：打包输出路径<br> productionGzipExtensions：代码压缩类型，一般是['js',&nbsp;'css']，打包后将会压缩成min.js和min.css</strong></p> </li><li> <p><strong>配置完成之后，开始下载其他依赖，用到的有，</strong><strong>devDependencies：less，less-loader，dependencies：vue-router，axios，crypto-js，mint-ui</strong></p> </li><li> <p><strong>新建以下文件夹</strong><br><img alt="" height="206" src="https://img-blog.csdnimg.cn/20200910102613577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="132"></p> </li><li> <p><strong>配置</strong><strong>less常用的初始值，我这里是这样配置的，其中icon用的是<a href="https://www.iconfont.cn/">阿里的icon</a>，将字体和样式包下载至style，animate用的是<a href="https://animate.style/">Animate.css</a>，transition.less是自己写的一个导航切换时的过渡动画，后面通过全局路由守卫进行切换动画，init中主要对初始样式声明变量，reset.less是设置页面默认样式</strong><br><img alt="" height="267" src="https://img-blog.csdnimg.cn/20200910103016391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="307"></p> </li><li> <p><strong>配置mint-ui，在main.js下引入mint-ui和css,以及按需引入组件，我这里项目中在每个组件中按需引入，建议在全局按需引入，减少重复代码</strong></p> <pre><code class="language-javascript">import Vue from 'vue'
import 'mint-ui/lib/style.css'
import MintUI from 'mint-ui'

Vue.use(MintUI);</code></pre> <p>&nbsp;</p> </li><li> <p><strong>配置axios请求方法拦截器，为了方便调用，我们将axios部署在Vue原型上，通过组件中的this.$axios进行调用，以下是拦截器配置，其中config是常量配置文件</strong></p> <pre><code class="language-javascript">import Vue from "vue";
import Axios from "axios";
import Config from "../config/config";
import { Toast, Indicator } from "mint-ui";
Axios.defaults.baseURL = Config.RequestPath; //默认请求地址
Axios.defaults.timeout = Config.RequestTimeOut; //请求超时
// 添加请求拦截器
Axios.interceptors.request.use(
  function(config) {
    Indicator.open("加载中...");
    // 在发送请求之前做些什么
    return config;
  },
  function(error) {
    Indicator.close();
    // 对请求错误做些什么
    return Promise.reject(error);
  }
);
// 添加响应拦截器
Axios.interceptors.response.use(
  function(response) {
    Indicator.close();
    // 对响应数据做点什么
    if (response.data.result != 1) {
      Toast(response.data.msg);
    }
    if (response.data.result === -999) {
      //token验证失败
    }
    return response.data;
  },
  function(error) {
    Indicator.close();
    Toast("加载失败");
    // 对响应错误做点什么
    return Promise.reject(error);
  }
);

Vue.prototype.$axios = Axios;
</code></pre> <p>&nbsp;</p> </li><li> <p><strong>&nbsp;配置vue-router，我们直接在config中添加vue-router的界面配置项，考虑到路由跳转的过渡动画，我们将router的每个界面进行了一个分级，形成这样的效果</strong></p> <p><img alt="" height="340" src="https://img-blog.csdnimg.cn/20200910143036709.gif" width="189"><br><strong>在config文件夹中新建routeConfig，内容如下</strong></p> <pre><code class="language-javascript">import Home from "../page/home/home";//商品首页
import Kind from "../page/kind/kind";//分类界面
import ShopCar from "../page/shopCar/shopCar";//购物车
import Info from "../page/info/info";//个人主页
import Order from "../page/order/order";//订单管理界面
import ShopTheme from "../page/shopTheme/shopTheme";//主题界面
import ShopInfo from "../page/shopInfo/shopInfo";//商品详情
import Register from "../page/register/register";//注册界面
import UpdateInfo from "../page/updateInfo/updateInfo";//个人信息修改

export default class RouteConfig {
  static routes = [
    {
      path: "/",
      redirect: "/Home"
    },
    {
      path: "/Home",
      name: "Home",
      component: Home,
      meta: {
        index: 0
      }
    },
    {
      path: "/Kind",
      name: "Kind",
      component: Kind,
      meta: {
        index: 0
      }
    },
    {
      path: "/ShopCar",
      name: "ShopCar",
      component: ShopCar,
      meta: {
        index: 0
      }
    },
    {
      path: "/Info",
      name: "Info",
      component: Info,
      meta: {
        index: 0
      }
    },
    {
      path: "/ShopTheme",
      name: "ShopTheme",
      component: ShopTheme,
      meta: {
        index: 1
      }
    },
    {
      path: "/ShopInfo",
      name: "ShopInfo",
      component: ShopInfo,
      meta: {
        index: 2
      }
    },
    {
      path: "/Register",
      name: "Register",
      component: Register,
      meta: {
        index: 1
      }
    },
    {
      path: "/UpdateInfo",
      name: "UpdateInfo",
      component: UpdateInfo,
      meta: {
        index: 1
      }
    },
    {
      path: "/Order",
      name: "Order",
      component: Order,
      meta: {
        index: 1
      }
    }
  ];
}
</code></pre> <p><strong>在router文件夹的index下引用该配置</strong></p> <pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import routeConfig from "../config/routeConfig"
const {
  routes
} = routeConfig
Vue.use(Router)
export default new Router({
  routes
})
</code></pre> <p>&nbsp;</p> </li></ul>
<p><strong>&nbsp; &nbsp; &nbsp; 配置全局watch监听路由跳转，在App.vue中新增watch函数监听路由</strong></p> 
<pre><code class="language-javascript">watch: {
    $route(to, from) {
      if (to.meta.index &gt; from.meta.index) {
        this.transitionName = "slide-left";//下一层，进入子页面
      } else if (to.meta.index &lt; from.meta.index) {
        this.transitionName = "slide-right";//上一层，返回
      } else {
        this.transitionName = "fade";//同级
      }
    }
  }</code></pre> 
<p><strong>到此为止，前端商城部分基本配置已完成，下一篇将介绍工具类和其他需要使用的配置，以及storage全局状态实现</strong><br> &nbsp;</p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十一）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806824.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:35:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806824.html</guid><description><![CDATA[
                    <p id="articleContentId"><strong>从零开始，搭建一个简单的购物平台（十）：</strong><br><a href="https://blog.csdn.net/time_____/article/details/108442619">https://blog.csdn.net/time_____/article/details/108442619</a><br><strong>项目源码（持续更新）：</strong><strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></strong><br><strong>这篇文章接着上篇的订单管理后端接口，对前端功能进行实现，主要功能有：新增订单，订单列表，订单删除，订单状态修改。</strong></p> 
<h3><strong>前端：</strong></h3> 
<p><img alt="" height="123" src="https://img-blog.csdnimg.cn/20200907103806881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="269"><img alt="" height="125" src="https://img-blog.csdnimg.cn/20200907103836504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="274"></p> 
<ul><li><strong>首先先实现新增订单功能，照着之前的新增用户和商品的方法修改一些代码，提交的form表单也要修改一下，AntD表单中有一个</strong><strong>动态增减嵌套字段的功能，可以用于订单商品的增减</strong><br><img alt="" height="214" src="https://img-blog.csdnimg.cn/20200908104123690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="417"><img alt="" height="156" src="https://img-blog.csdnimg.cn/20200908105429602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="411"><br><strong>使用Form.List提供一个渲染函数，其中有两个参数，分别是需要操作的数组和操作方式对象（add：新增，remove：删除，move：移动）</strong> <pre><code class="language-html">&lt;Form.List name="shopList"&gt;
          {(shopList, { add, remove }) =&gt; (
            &lt;div&gt;
              {shopList.map((field) =&gt; (
                &lt;Row gutter={20} key={field.key}&gt;
                  &lt;Col span={10}&gt;
                    &lt;Form.Item
                      {...field}
                      name={[field.name, "shopName"]}
                      fieldKey={[field.fieldKey, "shopName"]}
                      rules={[{ required: true, message: "请输入商品名称" }]}
                    &gt;
                      &lt;Input placeholder="请输入商品名称" allowClear /&gt;
                    &lt;/Form.Item&gt;
                  &lt;/Col&gt;
                  &lt;Col span={8}&gt;
                    &lt;Form.Item
                      {...field}
                      name={[field.name, "shopCount"]}
                      fieldKey={[field.fieldKey, "shopCount"]}
                      rules={[{ required: true, message: "请输入购买数量" }]}
                    &gt;
                      &lt;InputNumber
                        style={<!-- -->{ width: "100%" }}
                        min={1}
                        max={99}
                        placeholder="数量"
                        allowClear
                      /&gt;
                    &lt;/Form.Item&gt;
                  &lt;/Col&gt;
                  &lt;Col span={2}&gt;
                    &lt;MinusCircleOutlined
                      onClick={() =&gt; {
                        remove(field.name);
                      }}
                    /&gt;
                  &lt;/Col&gt;
                &lt;/Row&gt;
              ))}
              &lt;Row gutter={20}&gt;
                &lt;Col span={20}&gt;
                  &lt;Button
                    type="dashed"
                    onClick={() =&gt; {
                      add();
                    }}
                    style={<!-- -->{ width: "100%" }}
                  &gt;
                    &lt;PlusOutlined /&gt; 添加商品
                  &lt;/Button&gt;
                &lt;/Col&gt;
              &lt;/Row&gt;
            &lt;/div&gt;
          )}
        &lt;/Form.List&gt;</code></pre> <strong>实现效果</strong><br><img alt="" height="261" src="https://img-blog.csdnimg.cn/20200908111750607.gif" width="312"></li><li><strong>实现提交功能并对接接口，提交函数与之前的新增用户和新增商品一致，只是参数不同，所以可以直接复用，提交的函数和shopList结构以及data结构如下</strong> <pre><code class="language-javascript">sendData(val) {
    console.log(val.shopList)
    if (!val.shopList || !val.shopList.length) {
      message.warning("请选择至少一件商品");
      return;
    }
    val.token = this.$utils.getStorage(StorageName.token);
    console.log(val)
    Bussiness.sendInfo.bind(this, ServerApi.order.addOrder, val)();
  }</code></pre> <br><img alt="" height="178" src="https://img-blog.csdnimg.cn/202009081120513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="290"><img alt="" height="169" src="https://img-blog.csdnimg.cn/2020090811213390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="252"><img alt="" height="167" src="https://img-blog.csdnimg.cn/20200908112147922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="151"></li><li><strong>新增功能完成后，下面实现订单列表的展示功能，与之前的表格展示相同，在table组件中传入不同的参数（即表单字段及配置）以实现不同表格显示的效果，这里有一个表格嵌套的问题，每一个订单对应着不同的多个商品，所以前端的效果应该是这样的</strong><br><img alt="" height="173" src="https://img-blog.csdnimg.cn/20200908113129781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="418"><img alt="" height="171" src="https://img-blog.csdnimg.cn/20200908113149856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="393"><br><strong>这里涉及到的子表格可以用一个新的表格子组件来显示，在table组件下新建一个新的组件，命名expandTab.js，用于显示订单中购买的商品列表</strong> <pre><code class="language-javascript">import React from "react";
import config from "../../config/config";
import ShopType from "../../config/shopType";
const { shopType } = ShopType;
const { FilePath } = config;
export default class expandTab {
  constructor(_this) {
    return [
      {
        align: "center",
        title: "商品名",
        key: "shopName",
        dataIndex: "shopName",
        width: 50,
      },
      {
        align: "center",
        title: "商品类型",
        key: "shopType",
        dataIndex: "shopType",
        width: 50,
        render: (text) =&gt; {
          return &lt;div&gt;{shopType[text].name}&lt;/div&gt;;
        },
      },
      {
        align: "center",
        title: "商品图片",
        key: "shopPic",
        dataIndex: "shopPic",
        width: 60,
        render: (imgPath) =&gt; {
          return (
            &lt;img
              src={FilePath + imgPath}
              alt=""
              style={<!-- -->{ width: 60, margin: "0 auto" }}
            /&gt;
          );
        },
      },
      {
        align: "center",
        title: "单价",
        key: "shopPrice",
        dataIndex: "shopPrice",
        width: 30,
        render: (price) =&gt; {
          return &lt;div&gt;{price + "元"}&lt;/div&gt;;
        },
      },{
        align: "center",
        title: "购买数量",
        key: "shopCount",
        dataIndex: "shopCount",
        width: 30,
      },
    ];
  }
}
</code></pre> <strong>在Table组件中做一个适配，其中expandable属性是新增的属性，根据是否是order来判断订单列表显示状态，showOrderItem函数的作用是生成子表格</strong> <pre><code class="language-html">        &lt;Table
          scroll={<!-- -->{ x: 1000 }}
          rowKey={(record) =&gt; record._id}
          columns={this.state.columns}
          dataSource={this.state.list}
          expandable={
            this.state.tableType === "order"
              ? {
                  indentSize: 0,
                  expandedRowRender: this.showOrderItem,
                }
              : null
          }
          pagination={false}
        &gt;&lt;/Table&gt;</code></pre> <p><strong>showOrderItem函数（生成新的Table子组件）</strong>&nbsp;</p> <pre><code class="language-javascript">  showOrderItem = (record) =&gt; {
    return (
      &lt;Table
        rowKey={(record) =&gt; record._id}
        scroll={<!-- -->{ x: 1000 }}
        columns={new expandTab(this)}
        dataSource={record.shopList}
        pagination={false}
      &gt;&lt;/Table&gt;
    );
  };</code></pre> <strong>其余函数与功能和商品及用户管理相同</strong></li><li><strong>修改订单状态和删除订单，删除订单可以直接在上述生成的表格中添加按钮，执行到主界面的删除事件，在table.js中之前写过一个clickHandler函数</strong> <pre><code class="language-javascript">{
        align: "center",
        title: "操作",
        width: 50,
        fixed: "right",
        render: (record) =&gt; {
          return (
            &lt;div&gt;
              &lt;Popconfirm
                title="是否删除？"
                onConfirm={_this.clickHandler.bind(_this, record, "delete")}
                okText="是"
                cancelText="否"
                disabled={record.userType === "admin" ? true : false}
              &gt;
                &lt;Button
                  type="danger"
                  disabled={record.userType === "admin" ? true : false}
                &gt;
                  删除
                &lt;/Button&gt;
              &lt;/Popconfirm&gt;
            &lt;/div&gt;
          );
        },
      },</code></pre> <strong>clickHandler函数（用于所有对表格数据操作的汇总，再分配到主页面中，触发对应事件）：</strong> <pre><code class="language-javascript"> clickHandler(record, type) {
    switch (type) {
      case "add": //添加
        this.props.addInfo();
        break;
      case "change": //修改
        this.props.changeInfo(record);
        break;
      case "delete": //删除
        this.props.deleteInfo(record);
        break;
      case "allow": //冻结
        this.props.freezeInfo(record);
        break;
      case "state": //订单状态
        this.props.orderState(...arguments);
        break;
      default:
        break;
    }
  }</code></pre> <strong>以下是订单管理主页面中的方法：</strong> <pre><code class="language-javascript">  addOrder = () =&gt; {//新增订单，触发bussiness中的新增接口
    Events.emit(EventName.ADD_ORDER, FormDefaultVal.shop);
    this.drawerChild.showDrawer("addOrder");
  };
  changePage = (pageConfig) =&gt; {//分页
    this.setState({ pageConfig });
    this.getList();
  };
  orderState = (data, type, state) =&gt; {//修改订单状态，触发bussiness中的修改接口
    data.token = this.$utils.getStorage(StorageName.token);
    data.orderState = state;
    Bussiness.orderState.bind(this, ServerApi.order.updateOrder, data)();
  };
  getList = () =&gt; {//获取订单列表，触发bussiness中的获取列表函数
    Bussiness.getInfo.bind(this, ServerApi.order.orderList)();
  };
  deleteOrder = (record) =&gt; {//删除订单，触发bussiness中的删除接口
    Bussiness.delInfo.bind(this, ServerApi.order.delOrder, record)();
  };</code></pre> <strong>将这些方法绑定到父组件属性中作为子组件局部方法，以供子组件调用，修改订单与删除相同，达到以下效果，要在修改时添加下拉列表修改事件，同样执行clickHandler函数，并且将数据通过接口传到后端</strong><br><img alt="" height="231" src="https://img-blog.csdnimg.cn/20200908115816463.gif" width="544"></li><li><strong>以上就是新增的订单管理前端部分所有内容</strong></li></ul>
<p><strong>下一期将开始商城的前端板块介绍，后期将结合App和uniapp打包及使用</strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（十）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806825.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 08 Oct 2020 03:35:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/10/08/13806825.html</guid><description><![CDATA[
                    <p><strong>从零开始，搭建一个简单的购物平台（九）：</strong><br><a href="https://blog.csdn.net/time_____/article/details/105465499">https://blog.csdn.net/time_____/article/details/105465499</a><br><strong>项目源码（持续更新）：</strong><strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping">https://gitee.com/DieHunter/myCode/tree/master/shopping</a><br> 拖更时间较长，公司这几个月项目高峰期，请见谅</strong></p> 
<p><strong>这篇文章主要讲述后端管理系统新增的订单模块的部分内容（前端在之前的计划下稍稍改动，引入了订单的功能，但不包含支付功能），由于与用户管理和商品管理稍有不同，所以单独拎出来介绍一下</strong></p> 
<h3>前端效果：<br><img alt="" height="136" src="https://img-blog.csdnimg.cn/20200907103806881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="298"><img alt="" height="135" src="https://img-blog.csdnimg.cn/20200907103836504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="296"><img alt="" height="131" src="https://img-blog.csdnimg.cn/20200907104145800.gif" width="297"></h3> 
<p><strong>对于订单模块，主要功能有订单列表显示，订单状态修改（不涉及订单状态外其他数据修改），删除订单，新增订单（新增订单方面只做了简单的通过商品名索引来添加，考虑到管理系统的订单新增不是主要的功能，几乎用不上，所以没有细化功能），这篇文章主要介绍后端订单管理实现，接口对接。</strong></p> 
<h3>服务端：</h3> 
<ul><li><strong>首先我们需要在服务端配置一下数据库表结构，主要包含以下几个字段</strong> <pre><code class="language-javascript">    Order: {
      modelName: "orders",
      data: {
        orderId: {
          // 订单号
          type: String,
          required: true,
        },
        username: {
          //用户名
          type: String,
          required: true,
        },
        phoneNum: {
          //手机号
          type: String,
          required: true,
        },
        address: {
          //具体地址
          type: String,
          required: true,
        },
        orderState: {
          //订单状态
          type: String,
          required: true,
        },
        orderPrice: {
          // 订单总价
          type: String,
          required: true,
        },
        shopList: {
          //商品列表
          type: Array,
          required: true,
        },
        orderTime: {
          //订单创建时间
          type: String,
          required: true,
        },
      },
    },</code></pre> <p>&nbsp;</p> </li><li><strong>使用npm start启动server</strong></li><li><strong>然后在src目录下controller目录中新建order文件夹，用于订单接口，逻辑的实现，mod文件和之前一样，新建order表</strong><br><img alt="" height="244" src="https://img-blog.csdnimg.cn/20200907105255723.png" width="118"><img alt="" height="241" src="https://img-blog.csdnimg.cn/20200907105318153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="440"></li><li><strong>在order中引入依赖包，要注意的是，新增订单不仅仅是需要order一个表，还需要和user和shop表进行联动，因此我们需要调用其他接口逻辑中的方法，引入的包名如下</strong> <pre><code class="language-javascript">const router = require("express").Router();//路由
const UserMod = require("../user/mod");//user表联动
const ShopMod = require("../shopList/mod");//shop表联动
const Mod = require("./mod");//order表
const Util = require("../../../utils/utils");//工具类
const Config = require("../../../config/config");//配置文件
const Bussiness = require("../../bussiness/bussiness");//接口逻辑
const { addData, updateData, findData } = require("../../command/command");//数据库操作</code></pre> <p>&nbsp;</p> </li><li> <p>&nbsp;<strong>首先是新增订单接口，这个接口也是需要注意的和坑最多的地方，以下是检测用户，用户地址，商品是否存在</strong></p> <pre><code class="language-javascript">let userFindRes = await Bussiness.hasUser(req, res, UserMod);//检测用户及地址是否存在
  if (!userFindRes) {
    return;
  }
  if (!userFindRes[0].alladdress || !userFindRes[0].address) {
    res.send({
      result: -1,
      msg: "添加失败，请完善收货地址",
    });
    return;
  }
  let shopFindRes = await findData(ShopMod, {//检测商品是否存在
    shopName: {
      $in: res._data.shopList.map((item) =&gt; {
        return item.shopName;
      }),
    },
  });
  if (
    !shopFindRes ||
    !shopFindRes.length ||
    shopFindRes.length != res._data.shopList.length
  ) {
    res.send({
      result: -2,
      msg: "有商品不存在",
    });
    return;
  }</code></pre> <p><strong>下一步，将取出数据库信息（注意：数据库信息是只读，只能用数据库命令修改，所以不能用常规的堆内存存取需要用一个简单的堆变量复制）</strong></p> <pre><code class="language-javascript">static deepCopy(org) {
    //简单的对象复制
    return JSON.parse(JSON.stringify(org));
  }</code></pre> <p><strong>使用拷贝函数，将数据库信息取出并进行后续修改</strong></p> <pre><code class="language-javascript">let _shopFindRes = Util.deepCopy(shopFindRes); //解决数据库对象只读属性</code></pre> <p><strong>在返回前端之前，计算出总价和订单添加时间</strong></p> <pre><code class="language-javascript">let _orderPrice;//初始化商品总价
  let _shopFindRes = Util.deepCopy(shopFindRes); //解决数据库对象只读属性
  _shopFindRes.forEach((item, index) =&gt; {//合计总费用
    if (index == 0) {
      _orderPrice = 0;
    }
    _shopFindRes[index].shopCount = res._data.shopList[index].shopCount;
    _orderPrice +=
      _shopFindRes[index].shopCount * _shopFindRes[index].shopPrice;
  });

  res._data = {
    ...res._data,
    username: userFindRes[0].username,
    phoneNum: userFindRes[0].phoneNum,
    address: userFindRes[0].alladdress.join("") + userFindRes[0].address,
    orderId: Util.createOrderNo(),
    orderTime: Util.joinDate(),
    shopList: _shopFindRes,
    orderPrice: _orderPrice,
  };
  let addRes = await addData(Mod, res._data);
  if (!addRes || !addRes.length) {
    res.send({
      result: 0,
      msg: "添加失败",
    });
    return;
  }
  res.send({
    result: 1,
    msg: "添加成功",
    orderId: res._data.orderId,
  });</code></pre> <p>&nbsp;</p> </li><li> <p>&nbsp;<strong>与订单查询，删除，修改相比新增订单是个逻辑不同的功能，代码能复用的地方较少，其余三个功能均可仿照商品和用户接口写法实现</strong></p> </li><li> <p><strong>获取订单列表</strong></p> <pre><code class="language-javascript">router.get(Config.ServerApi.orderList, Util.checkToken, async (req, res) =&gt; {
  Bussiness.findInfo(
    req,
    res,
    Mod,
    {
      orderTime: res._data.sort,//时间排序
    },
    {
      orderId: new RegExp(res._data.orderId, "i"),//orderId（订单号）模糊过滤
      username: new RegExp(res._data.keyWord, "i"),//订单用户名模糊过滤
      orderState: new RegExp(res._data.orderState, "i"),//订单状态模糊过滤
    }
  );
});</code></pre> <p>&nbsp;</p> </li><li> <p>&nbsp;</p> <p><strong>删除订单</strong></p> <p>&nbsp;</p> <pre><code class="language-javascript">router.get(Config.ServerApi.delOrder, Util.checkToken, async (req, res) =&gt; {
  if (!Bussiness.isAdmin(res)) {
    return;
  }
  Bussiness.delInfo(req, res, Mod);
});</code></pre> <p>&nbsp;</p> </li><li> <p>&nbsp;</p> <p><strong>修改订单状态</strong></p> <pre><code class="language-javascript">router.post(Config.ServerApi.updateOrder, Util.checkToken, async (req, res) =&gt; {
  let updateRes = await updateData(Mod, res._data._id, res._data);
  if (updateRes) {
    res.send({
      result: 1,
      msg: "修改成功",
    });
    return;
  }
  res.send({
    result: 0,
    msg: "修改失败",
  });
});</code></pre> <p><strong>以上就是订单管理服务端接口和逻辑部分</strong></p> </li></ul>
<h3>总结：</h3> 
<p><strong>编写面向对象代码与实现其功能时，尽量减少函数之间的耦合度（函数与函数之间的联系），使其复用性增强，大大节省开发效率</strong></p>
                ]]></description></item><item><title>搭建一个线上版远程视频聊天</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/08/17/13806826.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 17 Aug 2020 09:28:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/08/17/13806826.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;">&nbsp;</p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p> 
<p id="%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFhttps%E8%AE%BF%E9%97%AE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFhttps%E8%AE%BF%E9%97%AE%EF%BC%9A">搭建前端https访问：</a></p> 
<p id="%E9%85%8D%E7%BD%AE%E5%90%8E%E7%AB%AFhttps%E8%AF%B7%E6%B1%82%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%85%8D%E7%BD%AE%E5%90%8E%E7%AB%AFhttps%E8%AF%B7%E6%B1%82%EF%BC%9A">配置后端https请求：</a></p> 
<hr id="hr-toc">
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p><strong>在<a href="https://blog.csdn.net/time_____/article/details/104801205">另一篇博客</a>中已经实现了远程视频聊天，然而这种方式只能运行在本地或者https服务下，因为navigator.mediaDevices.getUserMedia需要运行在安全模式下，所以这篇文章将对视频聊天做一个改进，达到真正的远程聊天功能<br> 之前的案例：<a href="https://blog.csdn.net/time_____/article/details/104801205">使用JS+socket.io+WebRTC+nodejs+express搭建一个简易版远程视频聊天</a></strong></p> 
<h2 id="%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFhttps%E8%AE%BF%E9%97%AE%EF%BC%9A"><strong>搭建前端https访问：</strong></h2> 
<p>搭建https的第一步得有一个服务器，相关的配置说明在我另一篇文章有提到<br><strong><a href="https://blog.csdn.net/time_____/article/details/104439713">案例：本地项目上线流程</a></strong><br> 然后，购买域名并备案，第一次要久一点，大概20天左右<br> 在域名界面进行域名解析和ssl证书下载（后续配置https）<br><img alt="" height="84" src="https://img-blog.csdnimg.cn/20200817114950588.png" width="486"><br> 将域名绑定服务器外网ip</p> 
<p><img alt="" height="38" src="https://img-blog.csdnimg.cn/20200817115151901.png" width="542"><br> 域名界面点进管理，购买免费证书并下载，这里用的是Nginx<br><img alt="" height="154" src="https://img-blog.csdnimg.cn/20200817115741565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="335"><img alt="" height="152" src="https://img-blog.csdnimg.cn/20200817115604189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="333"><img alt="" height="135" src="https://img-blog.csdnimg.cn/20200817115910986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="151"></p> 
<p>把下载的key和pem放在Nginx根目录下，部署视频聊天前端文件夹Video至根目录，打开conf文件夹下的nginx.conf文件并编辑<br><img alt="" height="130" src="https://img-blog.csdnimg.cn/20200817152152668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="297"><img alt="" height="131" src="https://img-blog.csdnimg.cn/20200817145531110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="186"><br> 在nginx.conf文件中添加代码，代理Video文件夹下的video.html文件至12345端口</p> 
<pre><code class="language-objectivec"># Video
    server {
        listen       12345;
        server_name  localhost;
        location / {
            root   Video;
            index  video.html;
        }
    }
</code></pre> 
<p>在nginx.conf文件中添加以下代码配置https证书，将上面的代理网站部署https证书</p> 
<pre><code class="language-objectivec"> # HTTPS server
    #
    server {
       listen       443  ssl;
       server_name  localhost;

       ssl_certificate      ../cert.pem;
       ssl_certificate_key  ../cert.key;

       ssl_session_cache    shared:SSL:1m;
       ssl_session_timeout  5m;

        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;

        location  /Video/{
           proxy_pass   http://127.0.0.1:12345/;
        }
    }</code></pre> 
<p><strong>最后通过访问<a href="">https://域名/Video/</a>的方式打开前端页面</strong></p> 
<h2 id="%E9%85%8D%E7%BD%AE%E5%90%8E%E7%AB%AFhttps%E8%AF%B7%E6%B1%82%EF%BC%9A"><strong>配置后端https请求：</strong></h2> 
<p>将之前下载的证书文件复制到server目录，或者其他目录，server能访问到即可</p> 
<p><img alt="" height="78" src="https://img-blog.csdnimg.cn/20200817154313619.png" width="293"><br> 打开server修改代码，之前我们的写法是</p> 
<pre><code class="language-javascript">const express = require("express");
const app = express();
const server = require("http").Server(app);
const io = require("socket.io")(server);
</code></pre> 
<p>现在得做个小修改，其他代码不动</p> 
<pre><code class="language-javascript">const express = require('express')
const app = express();
const fs = require('fs');
const options = {//读取证书文件
  key: fs.readFileSync('cert.key'),
  cert: fs.readFileSync('cert.pem')
};
const server = require('https').createServer(options,app);
const io = require('socket.io')(server);</code></pre> 
<p><strong>后端修改成https的目的</strong>是因为前端部分放在https服务器上，而后端用http请求方式，浏览器会报http的请求错误<br><img alt="" height="69" src="https://img-blog.csdnimg.cn/20200817160942504.png" width="206"><img alt="" height="67" src="https://img-blog.csdnimg.cn/20200817160220448.png" width="279"></p> 
<p><strong>然后把请求地址改为https即可访问</strong></p> 
<p><strong>最后我们看看效果<br> 由于电脑上的摄像头无法被两个页面调用，所以我用手机和电脑进行远程视频<br> 电脑端的录屏</strong><br><img alt="" height="211" src="https://img-blog.csdnimg.cn/20200817171142829.gif" width="262"><br><strong>手机端录屏</strong><br><img alt="" height="230" src="https://img-blog.csdnimg.cn/20200817171521268.gif" width="181"><br><strong>总结：由于视频聊天涉及隐私问题，自己试着研究一下还可以，所以就不放案例试用链接，<a href="https://gitee.com/DieHunter/myCode/tree/master/videoSteam">之前的视频聊天案例</a></strong></p>
                ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（九）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/14/13514432.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 14 Apr 2020 00:57:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/14/13514432.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（八）：<a href="https://blog.csdn.net/time_____/article/details/105452765">https://blog.csdn.net/time_____/article/details/105452765</a></strong><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p><strong>这篇文章将前后端管理功能完成，也就是将最后修改用户信息功能实现（由于商品管理与用户管理类似，所以不做描述），并讲述一下遇到的坑</strong></p>

<p><strong>修改用户数据后端其实就是根据用户id，将从前端传来的字段对应的值更新，如果头像有变化，则删除之前用户的头像，前端相对服务端反而更繁琐一些，当用户点击修改用户信息按钮后，将用户信息初始化到form表单中（头像同样需要加载），这里考虑到初始化用户信息的实现可以直接获取表格中的数据，可减少一次请求，但是有个小坑，当用户点击修改时，Drawer组件中的form表单初始化是异步的，需要两个解决操作：1.将Drawer中的子组件预加载（开启Drawer中的forceRender属性）。2.将form初始化操作放到form更新渲染完成之后（componentDidUpdate</strong><strong>），如果放在componentDidMount中，组件初始化只会进行第一次，下一步，直接开始整后端</strong></p>

<ul><li><strong>服务端在command中新增update方法</strong></li>
</ul><pre><code class="language-javascript"> /* 更新数据
   * @param {object} mod       数据库model
   * @param {string} _id       数据唯一标识
   * @param {object} data      更新字段及值
   */
  static updateData(mod, _id, data) {
    //改
    return mod
      .updateOne(
        {
          _id,
        },
        data
      )
      .then((res) =&gt; {
        return res;
      })
      .catch((err) =&gt; {
        return false;
      });
  }</code></pre>

<ul><li><strong>在user.js文件中添加接口用于更新用户信息</strong></li>
</ul><pre><code class="language-javascript">router.post(Config.ServerApi.updateUser, Util.checkToken, async (req, res) =&gt; {
  if (!res._data.headPic.length) {//这里判断是否是修改头像，若是新增，则是上传相关的头像信息，是个object类型，length属性不存在
    let findRes = await findData(Mod, {
      _id: res._data._id,
    });
    if (findRes[0].headPic != "public/assets/img/default.gif") {
      Util.delPicFile(findRes[0].headPic);
    }
    res._data.headPic = Util.readPicFile(res._data.headPic || "") || "";
  }
  res._data.password = Util.createBcrypt(res._data.password);//密码盐加密
  let updateRes = await updateData(Mod, res._data._id, res._data);
  if (updateRes) {
    res.send({
      result: 1,
      msg: "修改成功",
    });
    return;
  }
  Util.delPicFile(res._data.headPic);
  res.send({
    result: 0,
    msg: "修改失败",
  });
});</code></pre>

<p><strong>之后我们看看前端功能实现</strong></p>

<p><strong>前端需要在之前实现的新增用户中做修改，达到相关目的</strong></p>

<ul><li>在upload.js组件中添加初始化显示图片功能，也就是渲染组件时给个src，并且把方法传递给父组件以供调用（放到componentDidMount中），在父组件通过组件属性为子组件设置this中的属性达到调用。当然也可以使用全局events传递参数</li>
</ul><pre><code class="language-javascript">this.props.onUpdateRef(this);//放在子组件中，使父组件调用当前组件</code></pre>

<pre><code class="language-javascript">onUpdateRef={(child) =&gt; {//放在父组件的子组件的属性里，通过this.updateChild调用子组件的this
    this.updateChild = child;
 }}</code></pre>

<p><img alt="" height="191" src="https://img-blog.csdnimg.cn/20200413094147831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="373"></p>

<pre><code class="language-javascript"> updatePic(url) {
    if (url &amp;&amp; url.length &gt; 0) {
      this.setState({
        fileList: [
          {
            uid: "-1",
            name: url,
            status: "done",
            url,
          },
        ],
      });
    }
  }</code></pre>

<ul><li>全部实现后，可以在自定义的drawer.js组件进行新增用户和修改用户的区分</li>
</ul><pre><code class="language-javascript">showDrawer = (record) =&gt; {
    if (record) {//传递了参数说明是更新信息，否则是新增用户
      this.setState({
        formType: "updata",
        visible: true,
        record,
      });
      this.updateChild.updatePic(FilePath + record.headPic);//调用上传头像组件，显示图片
    } else {
      this.setState({
        formType: "add",
        visible: true,
        record: {//新增用户的初始值
          sex: "man",
          userType: "user",
          mailurl: "@qq.com",
        },
      });
    }
  };</code></pre>

<ul><li>在componentDidUpdata中添加更新form方法，将state中的record初始化至form中</li>
</ul><pre><code class="language-javascript">componentDidUpdate() {
    this.formRef.current.setFieldsValue(this.state.record);
}</code></pre>

<ul><li>在Drawer隐藏方法中将表单初始化并清空state中的record</li>
</ul><pre><code class="language-javascript">onClose = () =&gt; {
    this.formRef.current.resetFields();
    this.setState({
      visible: false,
      record: null,
    });
 };</code></pre>

<p><strong>效果如下</strong></p>

<p><img alt="" height="197" src="https://img-blog.csdnimg.cn/20200413103310217.gif" width="428"></p>

<p>最后，我们试试将数据提交至后端</p>

<p><img alt="" height="193" src="https://img-blog.csdnimg.cn/20200413105151571.gif" width="420"></p>

<p><strong>总结：</strong></p>

<p><strong>到现在为止，项目中的用户管理前端+服务端功能已全部实现，商品管理的功能实现与用户同理，但是字段名不同，不做说明，下一篇文章直接开始搭建商城前端及后端功能</strong></p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（八）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/13/13514434.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 13 Apr 2020 06:07:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/13/13514434.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（七）：<a href="https://blog.csdn.net/time_____/article/details/105448383">https://blog.csdn.net/time_____/article/details/105448383</a></strong><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p><strong>后端管理的界面与前端不同，在样式上可以没有前端精细，毕竟是给内部管理员看的，所以我们就不做的那么仔细了（其实还是因为我懒），这期主要讲讲前后端冻结，激活用户状态和删除用户功能</strong></p>

<ul><li><strong>首先在上篇已实现用户列表分页查找功能上，在表格配置的文件中添加两个按钮，冻结（激活）和删除用户</strong></li>
</ul><pre><code class="language-javascript">{
        align: "center",
        title: "操作",
        width: 230,
        fixed: "right",
        render: (record) =&gt; {
          return (
            &lt;div&gt;
              &lt;Popconfirm
                title="是否删除？"
                onConfirm={_this.clickHandler.bind(_this, record, "delete")}
                okText="是"
                cancelText="否"
                disabled={record.userType == "admin" ? true : false}
              &gt;
                &lt;Button
                  type="danger"
                  disabled={record.userType == "admin" ? true : false}
                &gt;
                  删除
                &lt;/Button&gt;
              &lt;/Popconfirm&gt;
              &lt;Button
                disabled={record.userType == "admin" ? true : false}
                type={record.isactive ? "danger" : "primary"}
                onClick={_this.clickHandler.bind(_this, record, "allow")}
              &gt;
                {record.isactive ? "禁止" : "允许"}
              &lt;/Button&gt;
            &lt;/div&gt;
          );
        },
      },</code></pre>

<ul><li>下一步，在ListTable组件上添加删除和冻结用户方法，由于删除是比较敏感操作，所以就不做批量删除了</li>
</ul><pre><code class="language-javascript">    &lt;ListTable
          tableType="user"
          onTableRef={(child) =&gt; {
            this.tableChild = child;
          }}
          showDrawer={this.showDrawer}
          deleteUser={this.deleteUser}
          freezeUser={this.freezeUser}
          changeInfo={this.changeInfo}
          changePage={this.changePage}
    &gt;&lt;/ListTable&gt;</code></pre>

<ul><li><strong>在table组件中添加clickHandler事件监听</strong></li>
</ul><pre><code class="language-javascript">clickHandler(record, type) {
    switch (type) {
      case "change": //修改
        this.props.changeInfo(record);
        break;
      case "delete": //删除
        this.props.deleteUser(record);
        break;
      case "allow": //冻结
        this.props.freezeUser(record);
        break;
      default:
        break;
    }
  }</code></pre>

<ul><li><strong>在userList界面中进行两个功能的请求，通过用户_id查找用户并操作</strong><br><strong>冻结，将用户状态设置为false（true）更新数据库并重新渲染：</strong>

	<pre><code class="language-javascript">freezeUser = (record) =&gt; {//record是用户在表格内的所有信息，主要获取数据库自动生成的_id就行
    let data = {
      token: this.$utils.getStorage(StorageName.token),
      _id: record._id,
      isactive: !record.isactive,
    };
    this.$axios
      .get(ServerApi.user.freezeUser, {
        params: { crypto: this.$crypto.setCrypto(data) },
      })
      .then((res) =&gt; {
        message.success(res.msg);
        this.getUserList();//操作成功后刷新列表
      });
  };</code></pre>
	<strong>删除，将头像源文件删除，并删除用户信息，更新页面：</strong>

	<pre><code class="language-javascript"> deleteUser = (record) =&gt; {
    let data = {
      token: this.$utils.getStorage(StorageName.token),
      _id: record._id,
      headPic: record.headPic,//上传用户头像地址减少服务端二次查找数据库
    };
    this.$axios
      .get(ServerApi.user.delUser, {
        params: { crypto: this.$crypto.setCrypto(data) },
      })
      .then((res) =&gt; {
        message.success(res.msg);
        this.getUserList();
      })
      .catch((err) =&gt; {});
  };</code></pre>
	</li>
</ul><p><strong>在服务端新增两个接口，分别做冻结用户和删除用户功能</strong></p>

<ul><li>冻结用户</li>
</ul><pre><code class="language-javascript">router.get(Config.ServerApi.freezeUser, Util.checkToken, async (req, res) =&gt; {
  if (res._data.userTokenType != "admin") {
    //非管理员
    res.send({
      result: -999,
      msg: "请用管理员账号登录",
    });
    return;
  }
  let freezeRes = await updateData(Mod, res._data._id, {
    isactive: res._data.isactive,
  });
  if (freezeRes) {
    res.send({
      result: 1,
      msg: res._data.isactive ? "激活成功" : "冻结成功",
    });
    return;
  }
  res.send({
    result: 0,
    msg: res._data.isactive ? "激活失败" : "冻结失败",
  });
});</code></pre>

<ul><li>完成后，我们测试一下效果</li>
</ul><p><img alt="" height="197" src="https://img-blog.csdnimg.cn/20200411161724407.gif" width="485"></p>

<ul><li>删除用户</li>
</ul><pre><code class="language-javascript">router.get(Config.ServerApi.delUser, Util.checkToken, async (req, res) =&gt; {
  if (res._data.userTokenType != "admin") {
    //非管理员
    res.send({
      result: -999,
      msg: "请用管理员账号登录",
    });
    return;
  }
  if (
    res._data.headPic &amp;&amp;
    res._data.headPic.length &gt; 0 &amp;&amp;
    res._data.headPic != "public/assets/img/default.gif"
  ) {//判断是否有图片，或者使用了默认图片，默认图片不删
    Util.delPicFile(res._data.headPic);
  }
  deleteRes = await delData(Mod, res._data._id);
  if (deleteRes) {
    res.send({
      result: 1,
      msg: "删除成功",
    });
    return;
  }
  res.send({
    result: 0,
    msg: "删除失败",
  });
});</code></pre>

<ul><li>最后，我们也试试删除功能</li>
</ul><p><img alt="" height="191" src="https://img-blog.csdnimg.cn/20200411162035977.gif" width="468"></p>

<p><strong>到此为止，项目的用户管理已经实现90%，剩余一个修改用户的实现留在下一篇，商品管理与用户管理功能实现类似，所以不做过多的说明</strong></p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（七）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/13/13514435.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 13 Apr 2020 00:23:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/13/13514435.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（六）：<a href="https://blog.csdn.net/time_____/article/details/105440818">https://blog.csdn.net/time_____/article/details/105440818</a></strong><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p><strong>到现在为止，项目前后端功能已实现登录，token获取验证，上传头像，添加用户，这篇文章主要讲述实现前后端用户列表分页查找，模糊查询，用户列表渲染功能</strong></p>

<ul><li><strong>首先是分页查找，</strong>后端实现方式通过数据库查找表的长度，配合数据库函数<strong>skip(n)（跳过前n条数据），和limit(m)（向后查找m条数据），通过db.find().skip((page&nbsp;-&nbsp;1)&nbsp;*&nbsp;pageSize).limit(pageSize)（page代表第几页，从0开始，第一页则不需要跳过。pageSize表示分页后每页数据条数），</strong>所以我们在command.js中新建两个方法，用于查询表的长度和关键字查询并分页</li>
</ul><pre><code class="language-javascript"> /* 查询分页
   * @param {object} mod       数据库model
   * @param {number} sort      排序顺序   负数倒序 正数顺序
   * @param {number} page      当前页数
   * @param {number} pageSize  分页大小
   * @param {object} pageSize  关键字模糊查询
   */
  static async findByPage(mod, sort, page, pageSize, keyWord) {
    //分页查
    return await mod
      .find(keyWord)
      .sort(sort)
      .skip((page - 1) * pageSize)
      .limit(pageSize);
  }
 /* 查询分页
   * @param {object} mod       数据库model
   * @param {number} pageSize  分页大小
   */
 static async getTotalPage(mod, pageSize) {
    let allNum = await mod.find().estimatedDocumentCount();
    return { totalPage: parseInt(allNum / pageSize) + 1, allNum };
  }</code></pre>

<ul><li><strong>在users.js中添加获取用户列表的接口，通过电子邮件或者用户名查找，分页</strong></li>
</ul><pre><code class="language-javascript">router.get(Config.ServerApi.userList, Util.checkToken, async (req, res) =&gt; {
  if (res._data.userTokenType != "admin") {
    //非管理员
    res.send({
      result: -999,
      msg: "请用管理员账号登录",
    });
    return;
  }
  let total = await getTotalPage(Mod, res._data.pageSize);
  let query = new RegExp(res._data.keyWord, "i"); //模糊查找正则条件
  res.send({
    result: 1,
    data: {
      page: res._data.page,
      pageSize: res._data.pageSize,
      totalPage: total.totalPage,
      allNum: total.allNum,
      list: await findByPage(
        Mod,
        {
          time: res._data.sort,
        },
        res._data.page,
        res._data.pageSize,
        res._data.keyWord.length
          ? {
              $or: [
                {
                  mailaddress: query,
                },
                {
                  username: query,
                },
              ],
            }
          : {}
      ),
    },
    msg: "查找成功",
  });
});</code></pre>

<p><strong>后端部分实现完成后，开始编写前端，需要用到表格组件，分页组件和input查找组件，这里可以将表格组件单独写出来，写成我们自己的组件，以供后期商品列表重复使用</strong></p>

<ul><li>先配置一下用户表格字段，封装到一个class里</li>
</ul><pre><code class="language-javascript">import React from "react";
import {
  Button,
  Popconfirm,
} from "antd";
import config from "../../config/config";

const { FilePath } = config;
export default class UserTable {
  constructor(_this) {
    return [
      { align: "center", title: "用户名", dataIndex: "username", width: 200 },
      {
        align: "center",
        title: "邮箱",
        dataIndex: "mailaddress",
        width: 200,
        render: (text, data) =&gt; {
          return &lt;div&gt;{text + data.mailurl}&lt;/div&gt;;
        },
      },
      {
        align: "center",
        title: "密码",
        dataIndex: "password",
        width: 300,
      },
      {
        align: "center",
        title: "头像",
        dataIndex: "headPic",
        width: 150,
        render: (imgPath) =&gt; {
          return (
            &lt;img
              src={FilePath + imgPath}
              alt=""
              style={{ width: 60, margin: "0 auto" }}
            /&gt;
          );
        },
      },
      {
        align: "center",
        title: "性别",
        dataIndex: "sex",
        width: 200,
        render: (sex) =&gt; {
          return &lt;div&gt;{sex == "man" ? "男" : "女"}&lt;/div&gt;;
        },
      },
      {
        align: "center",
        title: "收货地址",
        dataIndex: "alladdress",
        width: 200,
        render: (text, data, index) =&gt; {
          return &lt;div&gt;{text.join("-") + data.address}&lt;/div&gt;;
        },
      },
      {
        align: "center",
        title: "个性签名",
        dataIndex: "descript",
        width: 200,
      },
      {
        align: "center",
        title: "用户类型",
        dataIndex: "userType",
        width: 200,
        render: (type) =&gt; {
          return &lt;div&gt;{type == "admin" ? "管理员" : "用户"}&lt;/div&gt;;
        },
      },
      {
        align: "center",
        title: "注册时间",
        dataIndex: "time",
        width: 200,
      },
    ];
  }
}
</code></pre>

<ul><li>在表格渲染前判断一下表格类型，是显示用户还是商品，达到组件复用功能，将分页组件与pageconfig绑定，达到切换页面的效果</li>
</ul><pre><code class="language-javascript">import React from "react";
import {
  Table,
  Button,
  Card,
  Pagination,
  Input,
  Col,
  Row,
} from "antd";
import userTab from "./userTab";
import { PlusOutlined } from "@ant-design/icons";
const { Search } = Input;
export default class ListTable extends React.Component {
  state = {
    tableType: this.props.tableType,
    pageConfig: {
      totalPage: 0,
      page: 0,
      pageSize: 0,
      allNum: 0,
    },
    columns: [],
    list: [],
  };
  componentDidMount() {
    if (this.state.tableType == "user") {
      this.setState({
        columns: new userTab(this)
      });
    } else {
      
    }
    this.props.onTableRef(this);
  }
  render() {
    return (
      &lt;Card title="用户列表"&gt;
        &lt;Row gutter={16}&gt;
          &lt;Col span={12}&gt;
            &lt;Button onClick={this.props.showDrawer} type="primary"&gt;
              &lt;PlusOutlined /&gt;
              新增用户
            &lt;/Button&gt;
          &lt;/Col&gt;
          &lt;Col span={12}&gt;
            &lt;Search
              style={{ float: "right" }}
              placeholder="输入用户名/邮箱"
              enterButton="查找"
              size="large"
              allowClear
              onSearch={(val) =&gt; {
                let { pageConfig } = this.state;
                pageConfig.keyWord = val;
                this.setState({
                  pageConfig,
                });
                this.props.changePage(pageConfig);
              }}
            /&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
        &lt;Table
          scroll={{ x: 2000 }}
          rowKey={(record) =&gt; record._id}
          columns={this.state.columns}
          dataSource={this.state.list}
          pagination={false}
        &gt;&lt;/Table&gt;
        &lt;Pagination
          style={{ marginTop: 50 }}
          hideOnSinglePage
          total={this.state.pageConfig.allNum}
          current={this.state.pageConfig.page}
          pageSize={this.state.pageConfig.pageSize}
          showSizeChanger
          showQuickJumper
          showTotal={(total) =&gt; `共 ${total} 条`}
          onChange={this.changePage}
          onShowSizeChange={this.changePage}
        /&gt;
      &lt;/Card&gt;
    );
  }
  changePage = (page, pageSize) =&gt; {
    let pageConfig = this.state.pageConfig;
    pageConfig.page = page;
    pageConfig.pageSize = pageSize;
    this.setState({
      pageConfig,
    });
    this.props.changePage(pageConfig);
  };
}
</code></pre>

<ul><li>最后在userlist中调用，与表格中的page达到一个数据双向绑定效果</li>
</ul><pre><code class="language-javascript">import React from "react";
import ListTable from "../../../components/table/table";
import {
  message,
} from "antd";
import config from "../../../config/config";
const { ServerApi, StorageName } = config;

export default class UserList extends React.Component {
  state = {
    userType: "adduser",
    pageConfig: {
      token: this.$utils.getStorage(StorageName.token),
      keyWord: "",
      page: 1,
      pageSize: 2,
      totalPage: 1,
      sort: 1,
    },
  };
  componentDidMount() {
    this.getUserList();
  }
  render() {
    return (
      &lt;div&gt;
        &lt;ListTable
          tableType="user"
          onTableRef={(child) =&gt; {
            this.tableChild = child;
          }}
          showDrawer={this.showDrawer}
          changePage={this.changePage}
        &gt;&lt;/ListTable&gt;
        &lt;ListDrower
          getUserList={this.getUserList}
          userType={this.state.userType}
          onDrowerRef={(child) =&gt; {
            this.drawerChild = child;
          }}
        &gt;&lt;/ListDrower&gt;
      &lt;/div&gt;
    );
  }
  showDrawer = () =&gt; {
    this.drawerChild.showDrawer();
  };
  changePage = (pageConfig) =&gt; {
    this.setState({ pageConfig });
    this.getUserList();
  };

  getUserList = () =&gt; {
    let data = { ...this.state.pageConfig };
    this.$axios
      .get(ServerApi.user.userList, {
        params: { crypto: this.$crypto.setCrypto(data) },
      })
      .then((res) =&gt; {
        let { list, totalPage, allNum } = res.data;
        let { pageConfig } = this.state;
        pageConfig.allNum = allNum;
        pageConfig.totalPage = totalPage;
        this.tableChild.setState({ pageConfig, list });
      })
      .catch((err) =&gt; {});
  };
}
</code></pre>

<ul><li><strong>全部完成后，测试一下</strong></li>
</ul><p><img alt="" height="205" src="https://img-blog.csdnimg.cn/20200411144655868.gif" width="504"></p>

<p><strong>总结</strong></p>

<p>在组件化开发的前端代码中，组件复用可以使代码可维护性提升，通过修改state或者初始状态值对相对应的组件进行使用，大大提升代码效率</p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（六）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/12/13514436.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 12 Apr 2020 02:03:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/12/13514436.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（五）：<a href="https://blog.csdn.net/time_____/article/details/105437534">https://blog.csdn.net/time_____/article/details/105437534</a></strong><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p>在<a href="https://blog.csdn.net/time_____/article/details/105414410">第四篇文章</a>中实现了服务端的文件上传以及添加用户的后端功能，并进行了测试，这篇文章主要实现前端上传头像和添加用户的功能</p>

<p><strong>首先我们引入antd中的文件上传组件，并将其封装到我们的组件中</strong></p>

<ul><li>我们限制用户只能上传一张图片，<strong>其中上传组件中的action表示上传的路径，也就是我们在第四篇中的测试上传文件地址，name是文件标识名，data是传的参数，这里我们是用的token</strong></li>
</ul><p><img alt="" height="171" src="https://img-blog.csdnimg.cn/20200409204528165.gif" width="358"></p>

<pre><code class="language-javascript">import React from "react";
import { Upload,  message } from "antd";
import { PlusOutlined } from "@ant-design/icons";
import config from "../../config/config";
let {
  UploadName,
  Agreement,
  BaseUrl,
  ServerPort,
  Path,
  UploadKey,
  StorageName,
} = config;
export default class UpdataPic extends React.Component {
  state = {
    fileList: [],
  };
  
  
  handleChange = ({ fileList, file }) =&gt; {
    this.setState({ fileList });
    if (file["response"] &amp;&amp; file.status == "done") {
      let res = file["response"];
      message.success(res.msg);
    }
    if (file["status"] == "removed") {
      
    }
  };
  render() {
    const { fileList } = this.state;
    const uploadButton = (
      &lt;div&gt;
        &lt;PlusOutlined /&gt;
        &lt;div className="ant-upload-text"&gt;上传头像&lt;/div&gt;
      &lt;/div&gt;
    );
    return (
      &lt;div className="clearfix"&gt;
        &lt;Upload
          action={Agreement + BaseUrl + ServerPort + Path + UploadName.headPic}
          name={UploadKey.headKey}
          listType="picture-card"
          fileList={fileList}
          onChange={this.handleChange}
          data={{ token: this.$utils.getStorage(StorageName.token) }}
        &gt;
          {fileList.length &gt;= 1 ? null : uploadButton}
        &lt;/Upload&gt;
      &lt;/div&gt;
    );
  }
}

</code></pre>

<ul><li><strong>然后我们在某个页面引入该组件试试效果</strong></li>
</ul><p><img alt="" height="204" src="https://img-blog.csdnimg.cn/20200410211212265.gif" width="427"></p>

<p><strong>上传功能实现后，我们就可以开始实现添加用户了</strong></p>

<ul><li>新增用户，我打算放到右边的抽屉组件中，也就是Drawer组件，将form表单嵌入至抽屉中（<strong>修改用户和新增用户有着类似之处，我们做修改用户信息直接在新增用户Drawer中赋予form初始值即可</strong>）</li>
</ul><p><img alt="" height="455" src="https://img-blog.csdnimg.cn/20200410211820298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="351"></p>

<ul><li><strong>有几个注意点</strong>，1.antd的form需要使用React.createRef()将组件加载。2.表单数据赋予初始值时，需要调表单的this.formRef.current.setFieldsValue（）方法，<strong>然而这里有个坑，</strong>当Drawer组件显示时，form组件还未载入，这时如果直接赋值，就会因异步导致赋值不成功，解决方法（官方给的处理方式是用redux全局管理，我这里是用生命周期函数解决的）：<strong>首先在Drawer组件中启用预加载功能（forceRender，预渲染 Drawer 内元素</strong><strong>），然后在生命周期（componentDidUpdate</strong><strong>）中获取state中的值，调用this.formRef.current.setFieldsValue（）即可（修改用户信息与此相同）</strong></li>
</ul><pre><code class="language-javascript">import React from "react";
import Mail from "../../config/mail";
import {
  Drawer,
  Form,
  Button,
  Col,
  Row,
  Input,
  Select,
  Radio,
  Cascader,
  message,
} from "antd";
import config from "../../config/config";
import City from "../../config/city";
import UpdataPic from "../updata/updata";
const { ServerApi, StorageName, FilePath } = config;
const { Option } = Select;

export default class ListDrower extends React.Component {
  formRef = React.createRef();
  state = {
    visible: false,
    record: {},
  };
  componentDidMount() {
    this.props.onDrowerRef(this);
  }
  componentDidUpdate() {
    this.formRef.current.setFieldsValue(this.state.record);
  }

  showDrawer = () =&gt; {//显示Drawer
      this.setState({
        formType: "add",
        visible: false,
        record: {
          sex: "man",
          userType: "user",
          mailurl: "@qq.com",
        },
      });
    this.setState({
      visible: true,
    });
  };
  onClose = () =&gt; {//隐藏Drawer
    this.formRef.current.resetFields();
    this.setState({
      visible: false,
      record: null,
    });
  };
  getPic = (data) =&gt; {//上传头像后刷新表单头像信息
    this.formRef.current.setFieldsValue({
      headPic: data.headPath,
    });
  };
  delPic = () =&gt; {//删除头像后同时删除表单图片信息
    this.formRef.current.setFieldsValue({
      headPic: null,
    });
  };
  sendData(val) {//提交用户信息
    val.token = this.$utils.getStorage(StorageName.token);
    let data = this.$crypto.setCrypto(val);
    let _t = this;
    this.$axios
      .post(ServerApi.user.addUser, { crypto: data })
      .then((res) =&gt; {
        switch (res.result) {
          case 1:
            message.success(res.msg);
            _t.onClose();
            _t.props.getUserList();
            break;
          case 0:
            message.warning(res.msg);
            break;
          default:
            // message.warning(res.msg);
            break;
        }
      })
      .catch((err) =&gt; {
        message.error("操作失败");
      });
  }
  render() {
    return (
      &lt;Drawer
        title="新增用户"
        width={720}
        onClose={this.onClose}
        visible={this.state.visible}
        forceRender //加上预加载，防止表单异步生成，导致this.formRef.current为空
        bodyStyle={{ paddingBottom: 80 }}
        footer={
          &lt;div
            style={{
              textAlign: "right",
            }}
          &gt;
            &lt;Button onClick={this.onClose} style={{ marginRight: 20 }}&gt;
              取消
            &lt;/Button&gt;
          &lt;/div&gt;
        }
      &gt;
        &lt;Form
          layout="vertical"
          hideRequiredMark
          ref={this.formRef}
          onFinish={this.sendData.bind(this)}
        &gt;
          &lt;Row gutter={16}&gt;
            &lt;Col span={10}&gt;
              &lt;Form.Item name="headPic" label="头像"&gt;
                &lt;UpdataPic
                  onUpdateRef={(child) =&gt; {
                    this.updateChild = child;
                  }}
                  picTarget={this.getPic}
                  picDelete={this.delPic}
                &gt;&lt;/UpdataPic&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
            &lt;Col span={10}&gt;
              &lt;Form.Item
                name="userType"
                label="用户类型"
                rules={[{ required: true, message: "请选择用户类型" }]}
              &gt;
                &lt;Radio.Group buttonStyle="solid"&gt;
                  &lt;Radio.Button value="admin"&gt;管理员&lt;/Radio.Button&gt;
                  &lt;Radio.Button value="user"&gt;用户&lt;/Radio.Button&gt;
                &lt;/Radio.Group&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
          &lt;Row gutter={16}&gt;
            &lt;Col span={12}&gt;
              &lt;Form.Item
                name="username"
                label="用户名"
                rules={[{ required: true, message: "请输入用户名" }]}
              &gt;
                &lt;Input placeholder="请输入用户名" allowClear /&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
            &lt;Col span={12}&gt;
              &lt;Form.Item
                name="password"
                label="密码"
                rules={[{ required: true, message: "请输入密码" }]}
              &gt;
                &lt;Input.Password
                  type="password"
                  placeholder="请输入密码"
                  allowClear
                /&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
          &lt;Row gutter={16}&gt;
            &lt;Col span={5}&gt;
              &lt;Form.Item
                name="sex"
                label="性别"
                rules={[{ required: true, message: "请选择性别" }]}
              &gt;
                &lt;Radio.Group buttonStyle="solid"&gt;
                  &lt;Radio.Button value="man"&gt;男&lt;/Radio.Button&gt;
                  &lt;Radio.Button value="woman"&gt;女&lt;/Radio.Button&gt;
                &lt;/Radio.Group&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
            &lt;Col span={16}&gt;
              &lt;Form.Item label="邮箱"&gt;
                &lt;Input.Group compact&gt;
                  &lt;Form.Item
                    name="mailaddress"
                    rules={[{ required: true, message: "请输入正确邮箱" }]}
                  &gt;
                    &lt;Input defaultValue="" allowClear /&gt;
                  &lt;/Form.Item&gt;
                  &lt;Form.Item
                    name="mailurl"
                    rules={[{ required: true, message: "请选择邮箱类型" }]}
                  &gt;
                    &lt;Select onChange={this.changeMail} style={{ width: 150 }}&gt;
                      {(() =&gt; {
                        return Mail.address.map((item) =&gt; {
                          return (
                            &lt;Option key={item.mail} value={item.mail}&gt;
                              {item.mail}
                            &lt;/Option&gt;
                          );
                        });
                      })()}
                    &lt;/Select&gt;
                  &lt;/Form.Item&gt;
                &lt;/Input.Group&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
          &lt;Row gutter={20}&gt;
            &lt;Col span={16}&gt;
              &lt;Form.Item label="收货地址" required={false}&gt;
                &lt;Input.Group compact&gt;
                  &lt;Form.Item
                    name="alladdress"
                    // rules={[{ required: true, message: "请选择收货地址" }]}
                  &gt;
                    &lt;Cascader options={City} placeholder="请选择收货地址" /&gt;
                  &lt;/Form.Item&gt;
                  &lt;Form.Item
                    name="address"
                    // rules={[{ required: true, message: "请填写收货地址" }]}
                  &gt;
                    &lt;Input placeholder="请输入详细地址" allowClear /&gt;
                  &lt;/Form.Item&gt;
                &lt;/Input.Group&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
          &lt;Row gutter={16}&gt;
            &lt;Col span={24}&gt;
              &lt;Form.Item name="descript" label="个性签名"&gt;
                &lt;Input.TextArea rows={4} placeholder="个性签名" /&gt;
              &lt;/Form.Item&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
          &lt;Form.Item&gt;
            &lt;Button
              type="primary"
              htmlType="submit"
              className="login-form-button"
            &gt;
              提交
            &lt;/Button&gt;
          &lt;/Form.Item&gt;
        &lt;/Form&gt;
      &lt;/Drawer&gt;
    );
  }
}
</code></pre>

<ul><li><strong>最后，我们请求服务端试一试</strong></li>
</ul><p><img alt="" height="198" src="https://img-blog.csdnimg.cn/20200411103351463.gif" width="372"></p>

<p><strong>总结</strong></p>

<p>React是一个基于view显示层实现的dom优化框架，其对全局状态管理插件redux是将部分共享变量全局化，就相当于在原生window作用域中定义全局变量，虽然有一定的便捷，但是能不用的地方，最好是少用</p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（五）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/11/13514437.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 11 Apr 2020 06:26:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/11/13514437.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（四）：<a href="https://blog.csdn.net/time_____/article/details/105414410">https://blog.csdn.net/time_____/article/details/105414410</a></strong><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p>前面几篇文章将项目配置以及部分功能实现，这篇主要把前端的路由跳转功能实现一下，话不多说，直接开始盘</p>

<p><strong>说到路由，菜单栏是必不可少的。</strong></p>

<ul><li>首先在心中构思一下数据管理的结构，管理系统一般是顶部菜单和侧边菜单，这里我们用侧边栏进行路由</li>
</ul><p><img alt="" height="239" src="https://img-blog.csdnimg.cn/20200410174350875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="386"></p>

<ul><li>来做基本的架子，在antd找到layout布局</li>
</ul><p><img alt="" height="125" src="https://img-blog.csdnimg.cn/20200410175423608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="383"></p>

<ul><li>将四个部分分别做成组件，放到component中，头和脚内容不多，直接跳过，开始实现侧边栏功能，直接复制一下官方的组件，在上头加个logo就好了，但是由于侧边栏需要实现路由功能，所以将其配置数据剥离出来，新建menuList.js文件，放在config文件夹中（当然，也可以添加图标，这里主要因为懒(◍´꒳`◍)，所以没加）</li>
</ul><pre><code class="language-javascript">export default class MenuList {
  static leftMenu = [
    {
      name: "商品管理",
      list: [
        { name: "查找商品", route: "/admin/findshop" },
        { name: "新增商品", route: "/admin/addshop" },
        { name: "修改商品", route: "/admin/updatashop" }
      ]
    },
    {
      name: "用户管理",
      list: [
        { name: "用户列表", route: "/admin/userlist" },
      ]
    }
  ];
}
</code></pre>

<ul><li>在侧边栏组件中引入menuList并开始实现界面</li>
</ul><pre><code class="language-javascript">import React from "react";
import "./left.less";
import { Menu } from "antd";
import { Link } from "react-router-dom";
import MenuData from "../../config/menuList";

const { SubMenu } = Menu;
export default class Left extends React.Component {
  createMenu(data) {
    return data.map((item) =&gt; {
      if (item.list) {
        //递归生成子项
        return (
          &lt;SubMenu key={item.name} title={item.name}&gt;
            {this.createMenu(item.list)}
          &lt;/SubMenu&gt;
        );
      } else {
        return (
          &lt;Menu.Item key={item.name} title={item.name}&gt;
            &lt;Link to={item.route}&gt;{item.name}&lt;/Link&gt;
          &lt;/Menu.Item&gt;
        );
      }
    });
  }
  render() {
    return (
      &lt;div className="leftBox"&gt;
        &lt;Menu
          defaultSelectedKeys={["1"]}
          defaultOpenKeys={["sub1"]}
          mode="inline"
          theme="dark"
        &gt;
          {this.createMenu(MenuData.leftMenu)}
        &lt;/Menu&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><img alt="" height="244" src="https://img-blog.csdnimg.cn/2020041018065012.png" width="97"><img alt="" height="234" src="https://img-blog.csdnimg.cn/20200410180753422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="511"></p>

<ul><li>侧边栏实现后，我们需要配置一下路由，和侧边栏相似，新建routeList用于配置路由数据，将所有界面引入到routeList（需要新建所有的界面，在render中随便返回一个标识就好了）</li>
</ul><pre><code class="language-javascript">import FindShop from "../page/shop/findItem/find";
import AddShop from "../page/shop/addItem/add";
import UpdataShop from "../page/shop/findItem/find";
import UserList from "../page/user/userList/userList";
export default class RouteList {
  static leftMenu = [
    { name: "查找商品", route: "/admin/findshop", comp: FindShop },
    { name: "新增商品", route: "/admin/addshop", comp: AddShop },
    { name: "修改商品", route: "/admin/updatashop", comp: UpdataShop },
    { name: "用户列表", route: "/admin/userlist", comp: UserList },
  ];
}
</code></pre>

<ul><li>接着是构建路由</li>
</ul><pre><code class="language-javascript">import React from "react";
import {
  HashRouter as Router,
  Route,
  Switch,
  Redirect
} from "react-router-dom";
import RouteList from "../config/routeList";
import Login from "../page/login/login";
import Home from "../page/home/home";
import NotFind from "../page/errpage/404";
export default class RoutrModel extends React.Component {
  render() {
    return (
      &lt;Router&gt;
        &lt;Switch&gt;
          &lt;Route exact path="/"&gt;
            &lt;Redirect to="login"&gt;&lt;/Redirect&gt;
          &lt;/Route&gt;
          &lt;Route path="/login" component={Login}&gt;&lt;/Route&gt;
          &lt;Route exact path="/admin"&gt;
            &lt;Redirect to="/admin/findshop"&gt;&lt;/Redirect&gt;
          &lt;/Route&gt;
          &lt;Route
            path="/admin"
            render={props =&gt; {
              return (
                &lt;Home {...props}&gt;
                  &lt;Switch&gt;
                    {this.createRoute()}
                    &lt;Route component={NotFind}&gt;&lt;/Route&gt;
                  &lt;/Switch&gt;
                &lt;/Home&gt;
              );
            }}
          &gt;&lt;/Route&gt;
          &lt;Route component={NotFind}&gt;&lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    );
  }
  createRoute = props =&gt; {
    return RouteList.leftMenu.map(item =&gt; {
      return (
        &lt;Route path={item.route} component={item.comp} key={item.route}&gt;&lt;/Route&gt;
      );
    });
  };
}
</code></pre>

<ul><li>在App.js中引入route组件，将之前固定的login界面替换成route组件，达到以下效果</li>
</ul><p><img alt="" height="184" src="https://img-blog.csdnimg.cn/20200410194431220.gif" width="630"></p>

<pre><code class="language-javascript">import React from "react";
import Route from "./route/route";
function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Route&gt;&lt;/Route&gt;
    &lt;/div&gt;
  );
}
export default App;</code></pre>

<p><strong>总结&nbsp;</strong></p>

<p>组件化开发的核心是组件复用，同一个组件配置项和传递参数不同，其效果功能也不同</p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（四）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/11/13514438.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 11 Apr 2020 01:22:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/11/13514438.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（三）：</strong><strong><a href="https://blog.csdn.net/time_____/article/details/105411636">https://blog.csdn.net/time_____/article/details/105411636</a></strong><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p><strong>本篇文章延续上篇的登录界面搭建完成后，进行用户管理后端的编写，主要功能包括：</strong></p>

<p><strong>添加用户，上传头像</strong></p>

<p><strong>目录结构如下：</strong><br><img alt="" height="222" src="https://img-blog.csdnimg.cn/20200409170131809.png" width="87"></p>

<p><strong>首先实现上传头像功能</strong></p>

<p>上传文件流程：用户选择文件上传，服务端读取文件并生成唯一命名的缓存文件（二进制文件），将文件信息回传到前端，前端提交表单时将文件信息和用户信息一同上传至服务端，服务端读取对应文件，保存至public的img文件夹（此时生成的是图片文件），最后将图片路径存至数据库中</p>

<p><strong>具体实现</strong></p>

<ul><li>在controller文件夹下新建upload文件夹，在文件夹中新增upload.js用于上传头像，引入multer模块并进行文件暂存
	<pre><code class="language-javascript">const router = require("express").Router();
const Util = require("../../../utils/utils");
var multer = require("multer");
var upload = multer({
  dest: "./public/temp",//缓存目录
});
router.post(
  "/headPic",
  upload.single("headPic"),//单张图片，图片标识名
  Util.checkToken,//验证token
  (req, res) =&gt; {
    res.send({
      result: 1,
      msg: "上传成功",
      headPath: req.file,
    });
  }
);

module.exports = router;
</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>在router中添加upload.js的路由地址&nbsp;&nbsp; app.use("/upload",&nbsp;upload);<br>
	运行项目，做个测试，在postman中输入相对应地址和参数后点上传，服务端返回缓存文件信息并保存到缓存目录<br><img alt="" height="185" src="https://img-blog.csdnimg.cn/20200409204528165.gif" width="386"></li>
	<li>添加上传功能后，只是保证文件上传，还要把它转换成图片格式，<strong>所以在utils.js文件中新增几个方法（要引入fs模块）</strong>，分别是：<br><strong>读取文件</strong>
	<pre><code class="language-javascript"> static readPicFile(_file) {
    let { path, mimetype } = _file;//获取文件路径和文件类型
    let file = fs.readFileSync(path);//将文件转换成二进制
    let fileName =//用时间戳加随机数命名文件
      new Date().getTime() +
      parseInt(Math.random() * Math.random() * 1000000) +
      "." +
      mimetype.split("/")[1];
    this.delPicFile(path);//删除之前的缓存文件
    return this.writePicFile(file, fileName);//写文件
  }</code></pre>
	<strong>保存（写入）文件</strong>

	<pre><code class="language-javascript">  static writePicFile(_file, _fileName) {
    let fileName = "./public/assets/img/" + _fileName;//文件路径
    fs.writeFileSync(fileName, _file);
    return fileName.split("./")[1];
  }</code></pre>
	<strong>删除文件&nbsp;</strong>

	<pre><code class="language-javascript">static delPicFile(_path) {
    fs.unlink(_path, (err) =&gt; {
      if (err) {
        console.log("删除失败");
      }
    });
  }</code></pre>
	</li>
	<li><strong>全部完成后，上传文件也已完成&nbsp;</strong></li>
</ul><p><strong>添加用户功能</strong></p>

<ul><li>在users.js界面中调取之前写的command（数据库增，删，改，查操作）</li>
	<li>由于增加操作可能是移动端用户注册，所以暂时不加token验证，由于邮箱和用户名是唯一值，所以需要先进行查找用户
	<pre><code class="language-javascript">let findRes = await findData(Mod, {
    $or: [
      {
        mailaddress: res._data.mailaddress,
        mailurl: res._data.mailurl,
      },
      {
        username: res._data.username,
      },
      {
        mailaddress: res._data.username,
      },
      {
        username: res._data.mailaddress + res._data.mailurl,
      },
    ],
  });
  if (findRes &amp;&amp; findRes.length &gt; 0) {
    res.send({
      result: 0,
      msg: "添加失败,用户已存在",
    });
    Util.delPicFile(res._data.headPic);
    return;
  }</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>&nbsp;判断到无此用户时，将其添加到数据库中
	<pre><code class="language-javascript">  if (res._data.headPic) {
    res._data.headPic = Util.readPicFile(res._data.headPic || "") || "";//保存头像
  }
  res._data.time = Util.joinDate();//添加时间
  res._data.password = Util.createBcrypt(res._data.password);//盐加密
  res._data.isactive = true;
  let addRes = await addData(Mod, res._data);
  if (addRes) {
    res.send({
      result: 1,
      msg: "添加成功",
    });
    return;
  }
  Util.delPicFile(res._data.headPic);
  res.send({
    result: 0,
    msg: "添加失败",
  });</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>完成之后用postman测试一下，后端提示添加成功，数据库也成功添加该用户<br><img alt="" height="136" src="https://img-blog.csdnimg.cn/20200409213356560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="250">&nbsp;<img alt="" height="135" src="https://img-blog.csdnimg.cn/20200409213437192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="248"></li>
</ul><p><strong>文章到此，头像上传，用户添加就已经全部实现</strong></p>

<p><strong>总结</strong></p>

<p>前后端项目请求应进行节流处理（即限制用户多次快速单击提交按钮），前后端双重保险，即可提升用户体验，又减少服务端压力，由于此项目主要以功能为主，在细节方面没有十分注重，真实线上项目必须添加节流</p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（三）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/10/13514439.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Fri, 10 Apr 2020 08:50:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/10/13514439.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（二）：</strong><a href="https://blog.csdn.net/time_____/article/details/105408640"><strong>https://blog.csdn.net/time_____/article/details/105408640</strong></a><br><strong>项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a></p>

<p><strong>这篇文章在上次的服务端登录基础上增加前端界面</strong></p>

<p>在开始前我们可以简单用postman测试一下token和登录的功能，可以先在后端生成一段token从前端请求</p>

<p><strong>验证token（成功和失败）</strong></p>

<p><img alt="" height="123" src="https://img-blog.csdnimg.cn/20200409153223111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="244"><img alt="" height="127" src="https://img-blog.csdnimg.cn/20200409153400506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="235"></p>

<p><strong>紧接着验证一下用户登录（前提事先在数据库添加用户信息，添加过程及加密不做详细说明）</strong><br><img alt="" height="180" src="https://img-blog.csdnimg.cn/20200409153918430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="333"></p>

<p><strong>测试成功后我们开始配置编写前端部分（只实现功能，对界面要求不高）</strong></p>

<p><strong>文件结构：</strong></p>

<p><img alt="" height="333" src="https://img-blog.csdnimg.cn/20200409160552259.png" width="137"></p>

<ul><li><strong>配置config.js文件夹，新建config.js文件用于存放配置常量（和服务端config.js一样）</strong>

	<pre><code class="language-javascript">export default class Config {
  static Agreement = "http://";
  static BaseUrl = "127.0.0.1";
  static ServerUrl = "";
  static ServerPort = ":1024";
  static Path = "/";
  static CryptoKey = "tokenkey";//加密信息关键字
  static FilePath = this.Agreement + this.BaseUrl + this.ServerPort + this.Path;
  static ServerApi = {//接口名
    token: "checkToken",
    user: {
      userLogin: "user/userLogin",
    }
  };
  static StorageName = {//本地缓存localstorage名称
    token: "token",
    userInfo: "userInfo"
  };
}</code></pre>
	</li>
	<li><strong>在utils文件中新建方法</strong>，将其放在react.component的原型中，使继承组件可以直接调用<br><strong>storage：</strong>
	<pre><code class="language-javascript">import { Component } from "react";
class Utils {
  static saveStorage(key, val) {//添加缓存
    localStorage.setItem(key, JSON.stringify(val));
  }
  static getStorage(key) {//获取缓存
    try {
      return JSON.parse(localStorage.getItem(key));
    } catch (error) {}
  }
  static clearStorage(key) {//清除缓存
    try {
      localStorage.removeItem(key);
    } catch (error) {}
  }
}
Component.prototype.$utils = Utils;
</code></pre>

	<p><strong>axios:</strong></p>

	<pre><code class="language-javascript">import Config from "../config/config";
import Axios from "axios";
import { Component } from "react";
import { message } from "antd";
Axios.defaults.baseURL =
  Config.Agreement + Config.BaseUrl + Config.ServerPort + Config.Path;
// 添加请求拦截器
Axios.interceptors.request.use(
  function (config) {
    // 在发送请求之前做些什么
    return config;
  },
  function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  }
);
// 添加响应拦截器
Axios.interceptors.response.use(
  function (response) {
    // 对响应数据做点什么
    if (response.data.result === -999) {
      //token验证失败
      return message.error(response.data.msg);
    }
    return response.data;
  },
  function (error) {
    console.log(error)
    // 对响应错误做点什么
    message.error("操作失败");
    return Promise.reject(error);
  }
);

Component.prototype.$axios = Axios;
</code></pre>

	<p><strong>Crypto:</strong></p>

	<pre><code class="language-javascript">import * as CryptoJS from "crypto-js";
import { Component } from "react";
import config from "../config/config";
const { CryptoKey } = config;
class CryptoTool {
  /* Crypto加密方法
   * @param {object} _data       对用户请求后端的参数进行加密
   */
  static setCrypto(_data) {
    let key = CryptoJS.enc.Utf8.parse(CryptoKey);
    let encrypted = CryptoJS.AES.encrypt(JSON.stringify(_data), key, {
      mode: CryptoJS.mode.ECB,
      padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.toString();
  }
   /* Crypto解密方法
   * @param {string} _token       将秘文解密成对象形式
   */
  static getCrypto(_token) {
    let key = CryptoJS.enc.Utf8.parse(CryptoKey);
    let decrypt = CryptoJS.AES.decrypt(_token, key, {
      mode: CryptoJS.mode.ECB,
      padding: CryptoJS.pad.Pkcs7
    });
    return JSON.parse(CryptoJS.enc.Utf8.stringify(decrypt).toString());
  }
}
Component.prototype.$crypto = CryptoTool;
</code></pre>

	<p>&nbsp;</p>
	</li>
	<li><strong>在index.js中添加这些函数</strong>
	<pre><code class="language-javascript">import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import "./util/axios";
import "./util/utils";
import "./util/cryptoTool";</code></pre>

	<p>&nbsp;</p>
	</li>
	<li><strong>&nbsp;随后在page/login中新增login.js，简单配置一下login页面后，在App.js中引入login页面</strong>
	<pre><code class="language-javascript">import React from "react";
import Login from "./page/login/login"

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Login&gt;&lt;/Login&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>
	</li>
	<li>在antd官网找到登录界面实例，直接把大部分复制到login界面，用less微调一下后实现以下界面<br><img alt="" height="163" src="https://img-blog.csdnimg.cn/2020040916101681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="357">&nbsp;<img alt="" height="162" src="https://img-blog.csdnimg.cn/20200409161128913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="354"></li>
	<li><strong>login.js</strong>
	<pre><code class="language-javascript">import React from "react";
import "./login.less";
import { Card, Form, Input, Button, Checkbox, message } from "antd";
import { UserOutlined, LockOutlined } from "@ant-design/icons";
import config from "../../config/config";
const { ServerApi, StorageName } = config;
export default class Login extends React.Component {
  constructor(props) {
    super(props);
    this.checkToken(); //验证用户token是否过期
  }
  render() {
    return (
      &lt;div className="cardBox"&gt;
        &lt;Card title="登录"&gt;
          &lt;Form
            name="normal_login"
            className="login-form"
            initialValues={{ remember: true }}
            onFinish={this.sendData}
          &gt;
            &lt;Form.Item
              name="username"
              rules={[
                {
                  required: true,
                  message: "请输入用户名/邮箱",
                },
              ]}
            &gt;
              &lt;Input
                className="infoInput"
                prefix={&lt;UserOutlined className="site-form-item-icon" /&gt;}
                placeholder="用户名/邮箱"
              /&gt;
            &lt;/Form.Item&gt;
            &lt;Form.Item
              name="password"
              rules={[
                {
                  required: true,
                  message: "请输入密码",
                },
              ]}
            &gt;
              &lt;Input
                className="infoInput"
                prefix={&lt;LockOutlined className="site-form-item-icon" /&gt;}
                type="password"
                placeholder="密码"
              /&gt;
            &lt;/Form.Item&gt;
            &lt;Form.Item&gt;
              &lt;Form.Item name="remember" valuePropName="checked" noStyle&gt;
                &lt;Checkbox&gt;3天内免密&lt;/Checkbox&gt;
              &lt;/Form.Item&gt;
              &lt;a className="login-form-forgot" href="#aaa"&gt;
                忘记密码
              &lt;/a&gt;
            &lt;/Form.Item&gt;
            &lt;Form.Item&gt;
              &lt;Button
                type="primary"
                htmlType="submit"
                className="login-form-button"
              &gt;
                登录
              &lt;/Button&gt;
              或者&lt;a href="#aaa"&gt;注册&lt;/a&gt;
            &lt;/Form.Item&gt;
          &lt;/Form&gt;
        &lt;/Card&gt;
      &lt;/div&gt;
    );
  }
  checkToken() {
    let token = this.$utils.getStorage(StorageName.token);
    if (!token) return;
    this.$axios
      .get(ServerApi.token, {
        params: { token },
      })
      .then((res) =&gt; {
        switch (res.result) {
          case 1:
            message.success(res.msg).then(() =&gt; {
              // this.props.history.push({
              //   pathname: "/admin/findshop",
              //   query: res,
              // });
            });
            break;
          default:
            // message.warning(res.msg);
            break;
        }
      })
      .catch((err) =&gt; {
        console.log(err);
      });
  }
  sendData = (data) =&gt; {
    this.$axios
      .get(ServerApi.user.userLogin, {
        params: { crypto: this.$crypto.setCrypto(data) },
      })
      .then((res) =&gt; {
        switch (res.result) {
          case 1:
            this.$utils.saveStorage(StorageName.token, res.token);
            message.success(res.msg);
            // this.props.history.push({
            //   pathname: "/admin/findshop",
            //   query: res,
            // });
            break;
          default:
            message.warning(res.msg);
            break;
        }
      })
      .catch((err) =&gt; {
        console.log(err);
      });
  };
}
</code></pre>
	</li>
	<li>效果如下：<br><img alt="" height="136" src="https://img-blog.csdnimg.cn/2020040916165793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="297"><img alt="" height="134" src="https://img-blog.csdnimg.cn/20200409161722624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="294"><img alt="" height="133" src="https://img-blog.csdnimg.cn/20200409161759269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="291"></li>
</ul><p><strong>用户token验证，登录功能前端+后端基本实现</strong></p>

<p><strong>总结</strong></p>

<p>前端与后端的项目搭建顺序可能有所不同，项目周期可能也不同，这时需要灵活使用前后端数据模拟和请求模拟工具，前端可以使用easymock和mockjs生成假数据，而后端最简单的直接放到浏览器url访问（仅限于get），或者使用postman，SoapUI等接口测试工具</p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（二）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/09/13514440.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 09 Apr 2020 07:13:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/09/13514440.html</guid><description><![CDATA[
                                            <p><strong>从零开始，搭建一个简单的购物平台（一）：<a href="https://blog.csdn.net/time_____/article/details/105191286">https://blog.csdn.net/time_____/article/details/105191286</a><br>
项目源码（持续更新）：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow"><strong>https://gitee.com/DieHunter/myCode/tree/master/shopping</strong></a><br><br>
上一篇文章将项目主体以及插件模块搭建完成，这篇文章目的主要搭建服务端token验证及登录功能</p>

<p><strong>服务端：</strong></p>

<p><strong>文件目录结构</strong></p>

<p><img alt="" height="256" src="https://img-blog.csdnimg.cn/20200409144112360.png" width="100"></p>

<p>入口文件为<strong>server.js</strong>,简单配置一下，先让他能运行起来</p>

<pre><code class="language-javascript">const express = require("express");
const app = express();

app.listen(1024, () =&gt; {
  console.log("Server Start~");
});</code></pre>

<p>使用终端cd到server.js目录，输入node server运行入口文件，显示Server Start~表示运行成功，之后引入一些模块</p>

<pre><code class="language-javascript">const express = require("express");
const app = express();
const routes = require("./routes/routes");
const cors = require("cors"); //引入cors模块（解决跨域问题）
const path = require("path");
app.use(cors());
app.all("*", function (req, res, next) {
  //设置允许跨域的域名，*代表允许任意域名跨域
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "content-type"); //允许的header类型
  res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS"); //跨域允许的请求方式
  next(); //是否继续向下执行
});
let bodyParser = require("body-parser"); //post传输数据类型
app.use(
  bodyParser.urlencoded({
    extended: false,
  })
);
new routes(app);//初始化路由
app.use(bodyParser.json());
app.use("/public", express.static(path.join(__dirname, "./public")));//静态目录

app.listen(1024, () =&gt; {
  console.log("Server Start~");
});
</code></pre>

<p><strong>全部设置完之后进行下一步，配置路由与token验证</strong></p>

<p>在utils.js文件中新建一个静态类，并且引入jwt（jsonwebtoken），在config.js文件中新建config静态类用于存放配置变量（接口名，公钥秘钥，常量），此外还需用到crypto进行数据加解密，Bcrypt密码盐加密</p>

<p><strong>utils.js</strong></p>

<pre><code class="language-javascript">const jwt = require("jsonwebtoken");
const config = require("../config/config");
const cryptoJS = require("crypto-js");//用来加密解密前端参数
let { UserKey, AdminKey,CryptoKey} = config;//token加密关键字,秘钥
let key = cryptoJS.enc.Utf8.parse(CryptoKey);//生成16进制秘钥
module.exports = class Utils {
   static parseUrl(req, res) {//获取前端传递的参数
    return req.method == "POST" ? req.body : this.urlSplit(req.url);
  }
   static urlSplit(url) {//get获取的参数解析
    let list = url.split("?")[1].split("&amp;");
    let leng = list.length;
    let obj = {};
    for (let i = 0; i &lt; leng; i++) {
      let key = list[i].split("=")[0];
      let val = list[i].split("=")[1];
      obj[key] = val;
    }
    return obj;
  }
/*
   * @param {string} type 'user'||'admin'      用户类型
   * @param {string} user                      用户名  
   * @param {bool} rempsd                      是否记住密码
   */
  static createToken = (type, user, rempsd) =&gt; {//生成token，用户登录时调用
    let payload = {
      user: user,
    };
    return jwt.sign(payload, type == "admin" ? AdminKey : UserKey, {
      expiresIn: rempsd ? "3d" : "6h",
    });
  };
 /*
   * @param {object} req       前端请求对象
   * @param {object} res       服务端接收对象
   * @param {fn} next          中间件响应方法
   */
  static checkToken = (req, res, next) =&gt; {
    let _data = this.parseUrl(req, res); //解析前端参数
    if (_data.crypto) {
      _data = this.getCrypto(_data.crypto); //对前端参数解密
    }
    let isUser = true; //用户
    let isAdmin = true; //管理员
    let _decoded = ""; //加密的用户名
    jwt.verify(_data.token, UserKey, function (err, decoded) {
      if (err) {
        isUser = false;
      } else {
        _decoded = decoded;
      }
    });
    jwt.verify(_data.token, AdminKey, function (err, decoded) {
      if (err) {
        isAdmin = false;
      } else {
        _decoded = decoded;
      }
    });
    if (isUser || isAdmin) {
      _data.id = _decoded;
      _data.userTokenType = isAdmin ? "admin" : "user";
      res._data = _data;
      next(); //中间件响应
    } else {
      res.send({
        result: -999,
        msg: "登录超时,请重新登录",
      });
    }
  };
/* Crypto加密方法
   * @param {object} _data       对用户请求后端的参数进行加密
   */
  static setCrypto(_data) {
    let encrypted = cryptoJS.AES.encrypt(JSON.stringify(_data), key, {
      mode: cryptoJS.mode.ECB,
      padding: cryptoJS.pad.Pkcs7,
    });
    return encrypted.toString();
  }
 /* Crypto解密方法
   * @param {string} _token       将秘文解密成对象形式
   */
  static getCrypto(_token) {
    _token = decodeURIComponent(_token); //前端传参有特殊字符（中文）时转义（替换百分号）
    let decrypt = cryptoJS.AES.decrypt(_token, key, {
      mode: cryptoJS.mode.ECB,
      padding: cryptoJS.pad.Pkcs7,
    });
    return JSON.parse(cryptoJS.enc.Utf8.stringify(decrypt).toString());
  }
  static createBcrypt(password) {//加密密码
    return bcrypt.hashSync(password, bcrypt.genSaltSync(10));
  }
  static checkBcrypt(_password, _hash) {//对比密码
    return bcrypt.compareSync(_password, _hash);
  }
}</code></pre>

<p><strong>配置完成utils后进行路由配置，在routes文件夹下新建routes.js文件，并使用token验证用户是否正确</strong></p>

<pre><code class="language-javascript">const Util = require("../utils/utils");
const Config = require("../config/config");
module.exports = class Route {
  constructor(app) {
    app.get(Config.ServerApi.checkToken, Util.checkToken, (req, res) =&gt; {
      res.send({
        result: 1,
        msg: "验证成功",
        data: res._data
      });
    });
  }
};</code></pre>

<p><strong>配置config.js</strong></p>

<pre><code class="language-javascript">module.exports = {
  Agreement: "http://",//协议
  DataBaseUrl: "127.0.0.1",//ip或域名
  DataBasePort: ":27017",//数据库端口
  DataBaseName: "shopping",//数据库文档名称
  ServerUrl: "",
  ServerPort: ":1024",//服务端请求端口
  Path: "/",//路由名
  UserKey: "user",//用户token加密标识
  AdminKey: "admin",//管理员token加密标识
  CryptoKey: "tokenkey",//Crypto加密关键字，用于生成16进制秘钥
  ServerApi: {//接口名称
    checkToken: "/checkToken",//token验证
    userLogin: "/userLogin",//用户登录
  }
}</code></pre>

<p><strong>随后，新建用户管理路由接口</strong>，但是在此之前，我们需要配置一下数据库</p>

<ol><li>下载<a href="https://robomongo.org/" rel="nofollow">Robo3t</a>,并安装</li>
	<li>新建数据库，这里我新建的数据库名称是Shopping</li>
	<li>新建数据库表，这里我新建的是users表</li>
</ol><p><img alt="" height="187" src="https://img-blog.csdnimg.cn/20200409143642663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="271"><img alt="" height="185" src="https://img-blog.csdnimg.cn/20200409143738691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="277"><img alt="" height="111" src="https://img-blog.csdnimg.cn/20200409143827911.png" width="295"></p>

<p><strong>连接数据库</strong></p>

<ol><li><strong>在model.js中新建数据库连接</strong>（原理观察者模式，类似与socket监听自定义事件）

	<pre><code class="language-javascript">const mongoose = require('mongoose');
const config = require('../../config/config')
module.exports = class Mongoose {
    constructor() {
        mongoose.connect(`mongodb://${config.DataBaseUrl+config.DataBasePort+config.Path+config.DataBaseName}`, {
            useNewUrlParser: true
        });
        this.db = mongoose.connection;
        this.db.on("error", function (error) {
            console.log("Err:" + error);
        });

        this.db.on("open", function () {
            console.log("Connet Success~");
        });

        this.db.on('disconnected', function () {
            console.log('Connet Stop~');
        });
        return mongoose
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>
	<p><strong>新建数据库Schema用于连接数据表</strong>，这里我们直接将配置项剥离到config.js文件</p>

	<pre><code class="language-javascript">const _mongoose = require('./model');
let mongoose = new _mongoose()
const _schema = mongoose.Schema;
module.exports = class Schema {
    constructor(config) {
        let schema = new _schema(config.data);
        let Model = mongoose.model(config.modelName, schema); //新建数据库
        return Model
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>
	<p><strong>config.js中新增用户表默认字段配置</strong></p>

	<pre><code class="language-javascript">Collections: {
    Users: {
      modelName: "users",
      data: {
        headPic: {//头像
          type: String,
          required: false,
          default: "public/assets/img/default.gif"
        },
        userType: {//用户类型（管理员/用户）
          type: String,
          required: true,
        },
        username: {//用户名
          type: String,
          required: true,
        },
        password: {//密码
          type: String,
          required: true
        },
        sex: {//性别
          type: String,
          required: true
        },
        mailaddress: {//邮箱地址
          type: String,
          required: true
        },
        mailurl: {//邮箱类型
          type: String,
          required: true
        },
        alladdress: {//省市县
          type: Array,
          required: false,
          default: []
        },
        address: {//具体地址
          type: String,
          required: false,
          default: ''
        },
        descript: {//个人说明
          type: String,
          required: false,
          default: ''
        },
        time: {//注册时间
          type: String,
          required: true
        },
        isactive: {//是否冻结用户
          type: Boolean,
          default: true
        }
      }
    }
  },</code></pre>

	<p>&nbsp;</p>
	</li>
</ol><p><strong>以上是配置，token验证及登录的后端代码&nbsp;</strong></p>

<p><strong>总结</strong></p>

<p>将项目搭建成类似于mvc的设计思想很有必要，数据模型和控制层的剥离，可以使代码思路清晰，复用性以及可维护性提升</p>
                                    ]]></description></item><item><title>从零开始，搭建一个简单的购物平台（一）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/09/13514441.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 09 Apr 2020 03:45:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/04/09/13514441.html</guid><description><![CDATA[
                                            <p>这个项目是我利用空余的时间写的，商城App界面主要模仿<a href="http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=5042" rel="nofollow">零食商贩</a>小程序写的，其余都是自己写的</p>

<p>项目源码（持续更新）：<a href="https://gitee.com/DieHunter/myCode/tree/master/shopping" rel="nofollow">https://gitee.com/DieHunter/myCode/tree/master/shopping</a></p>

<h3><strong>使用到的技术：</strong></h3>

<p><strong>后端</strong>：node+express+MongoDB</p>

<p><strong>管理界面</strong>：react+antd</p>

<p><strong>商城界面</strong>（移动端）：Vue+Mint UI</p>

<p><strong>开发工具：</strong>npm</p>

<p><strong>打包工具</strong>：webpack</p>

<p><strong>代码管理</strong>：git</p>

<p><strong>技术栈</strong>：</p>

<ul><li>后端（express，mongoose，cors，body-parser，multer，jsonwebtoken，crypto-js，bcryptjs，nodemailer）</li>
	<li>管理界面（react，antd，axios，crypto-js，less，less-loader，react-router-dom，events，redux）</li>
	<li>商城界面（vue，vue-router，vuex，axios，jquery，less，less-loader，mint-ui，swiper）</li>
</ul><h3>准备工作：</h3>

<p><strong>工具配置</strong></p>

<ol><li><strong>node安装：<a href="https://github.com/coreybutler/nvm-windows">下载</a>并</strong>安装nvm或直接下载<a href="http://nodejs.cn/download/" rel="nofollow">nodejs</a>安装，若使用nvm，则使用

	<pre><code class="language-bash">nvm install node@12.16.1
nvm use 12.16.1</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>
	<p>安装好node之后，查看环境变量（右键我的电脑=&gt;属性=&gt;高级系统设置=&gt;环境变量）若没有，则将node目录添加至环境变量</p>
	</li>
	<li>
	<p><strong>npm 配置：</strong></p>

	<pre><code class="language-javascript">npm config set registry https://registry.npm.taobao.org    //将默认下载地址设置为淘宝镜像
npm config set prefix "D:\soft\nodejs\module_global"     //设置全局模块安装默认路径（后面直接将路径放到环境变量，可以直接使用）
npm config set cache "D:\soft\nodejs\module_cache"//设置全局模块缓存路径</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>
	<p><strong>安装mongoDB：</strong>下载安装<a href="https://www.mongodb.com/download-center/community" rel="nofollow">MongoDB</a>，与node一样配置环境变量，在cmd中输入mongo，出现类似这样的，就说明安装配置成功<br><img alt="" height="200" src="https://img-blog.csdnimg.cn/20200409094151118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="185"></p>
	</li>
	<li>
	<p><strong>webpack：</strong>使用npm全局安装<strong>webpack-cli</strong>和<strong>webpack</strong></p>

	<p>npm i webpack webpack-cli -g&nbsp;</p>
	</li>
</ol><p><strong>后端搭建</strong></p>

<ol><li><strong>新建项目文件夹</strong>，我这里建立后端文件夹后直接建立server.js(入口文件)，这样在npm init时不需要输入项目名称</li>
	<li><strong>使用npm init -y初始化后端项目</strong>，并创建文件结构（如下图）<br><img alt="" height="195" src="https://img-blog.csdnimg.cn/20200409101330111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="173"></li>
	<li>&nbsp;安装express，mongoose，cors（处理前端跨域），body-parser（允许修改请求类型，简言之就是支持post请求），multer（使文件上传被支持），jsonwebtoken（后端生成单向token，传输至前端以供验证状态），crypto-js（请求数据传输加密），bcryptjs（密码加密），nodemailer（发送电子邮件，验证码）等模块</li>
</ol><p><strong>到此为止，一个基本的服务端已搭建好</strong></p>

<p><strong>服务端管理系统界面搭建</strong></p>

<ol><li>使用 npm install create-react-app -g 全局安装create-react-app脚手架工具，并新建项目目录</li>
	<li>在项目目录中运行脚手架工具 create-react-app myapp(项目名称)</li>
	<li><strong>配置webpack</strong>：这里需要用到less，react脚手架提供默认的预处理语言是sass，所以要将react项目的config暴露出来，<br>
	暴露之前我们项目下的package.json文件中有一项eject，运行&nbsp; npm run eject（<strong>注意:此操作不可逆，</strong>如非必要，最好不要暴露，webpack打包原理就是将项目所需依赖生成静态资源，也就是说，如果没用到的包，不会有任何影响）</li>
	<li>安装antd（ui），axios（数据请求），crypto-js（请求数据传输加密），react-router-dom（路由跳转），redux（全局状态）</li>
	<li>下载less和less-loader,<br>
	npm install less-loader less --save</li>
	<li><strong>配置less：</strong>运行完eject后package.json中的eject项会消失，此时项目中会多出一个config文件夹，其中就是webpack的配置文件，我们打开webpack.config.js文件，通过搜索找到默认配置的sass配置项，照葫芦画瓢，将less配置好，同理将less-loader配置好（如下图）<br><img alt="" height="176" src="https://img-blog.csdnimg.cn/20200409111154452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="183"><img alt="" height="121" src="https://img-blog.csdnimg.cn/20200409111255389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="324"><img alt="" height="128" src="https://img-blog.csdnimg.cn/20200409111401701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="225"></li>
	<li>然后在src文件夹中构建项目结构<br><img alt="" height="143" src="https://img-blog.csdnimg.cn/20200409111933737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="201"></li>
</ol><p><strong>至此，一个基本的服务端管理前端项目搭建完成</strong></p>

<p><strong>商城界面搭建</strong></p>

<ol><li>使用 npm install -g vue-cli 全局安装vue-cli 脚手架工具</li>
	<li>用vue init webpack + 项目的名字&nbsp; &nbsp;初始化项目</li>
	<li>构建项目目录<br><img alt="" height="118" src="https://img-blog.csdnimg.cn/20200409114241221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="177"></li>
	<li>安装vue-router（路由），vuex（全局状态），axios（前端请求），jquery，less，less-loader，mint-ui（移动端ui组件），swiper（轮播插件）</li>
</ol><p><strong>商城界面搭建完成</strong></p>

<p><strong>总结：</strong></p>

<p>面向对象编程的实质其实是考验自己对抽象思想的理解与认知，有的事物你虽无法描述，但是他是的的确确存在的，考虑有什么，而不是是什么</p>
                                    ]]></description></item><item><title>Echarts案例：整一个炫酷一点的仪表盘</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/23/12560805.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 23 Mar 2020 06:08:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/23/12560805.html</guid><description><![CDATA[
                                            <p><strong>故事发生在几天前</strong></p>

<p>公司要求做个仪表盘，大致UI是这样的<br><img alt="" height="228" src="https://img-blog.csdnimg.cn/20200321215215727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="265"><br>
这不是为难我胖虎嘛，于是找遍整个全网也没找到相似的，只能自己手写一个。</p>

<p>然而，最开始是准备用极坐标写的</p>

<p><img alt="" height="247" src="https://img-blog.csdnimg.cn/20200321215537496.png" width="268"></p>

<p>折腾了一上午发现极坐标做出的效果两头是360度的圆环，这使UI给的标注无法实现，于是我又开始研究仪表盘，官方给的实例倒是挺炫酷</p>

<p><img alt="" height="145" src="https://img-blog.csdnimg.cn/20200321215916833.png" width="159"><img alt="" height="141" src="https://img-blog.csdnimg.cn/20200321215930971.png" width="154"></p>

<p>当我感觉快找到希望时，却无法实现两端圆角</p>

<p><img alt="" height="171" src="https://img-blog.csdnimg.cn/20200321220419973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="187"></p>

<p>以及将刻度显示在数字外，在网上找资料发现也有同学遇到相同的问题，但是没找到解决方法</p>

<p><img alt="" height="141" src="https://img-blog.csdnimg.cn/20200321220632334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="238"></p>

<p>然而急中生智却被我想到了一个方法，将这二者合并一下</p>

<p>先简单画个仪表盘</p>

<p><img alt="" height="163" src="https://img-blog.csdnimg.cn/20200321222011866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="158"></p>

<p>设置一下他的属性，去掉指针，去掉表盘颜色，得到只有刻度和数字的表盘</p>

<p><img alt="" height="168" src="https://img-blog.csdnimg.cn/20200321222204510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="167"></p>

<p>之后将除了圆环以外的所有属性配置一下实现这样的效果</p>

<p><img alt="" height="189" src="https://img-blog.csdnimg.cn/2020032122250556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="188"></p>

<p>突然有内味了，这时我们加上极坐标环状图</p>

<p><img alt="" height="190" src="https://img-blog.csdnimg.cn/20200321222704919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="190"></p>

<p>然而二者最大角度不同，我们需要做一个换算，设计图中仪表盘的角度相当于极坐标的-30度到210度，二者偏移值是240度除360度</p>

<p>也就是极坐标得乘以2分之3（240分之360）才是真实仪表盘的值</p>

<p>经过换算后，实现以下效果</p>

<p><img alt="" height="164" src="https://img-blog.csdnimg.cn/20200321223133368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="164"><img alt="" height="163" src="https://img-blog.csdnimg.cn/20200321223442868.gif" width="168"></p>

<p><strong>源码：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/Echart/PolarGauge" rel="nofollow">https://gitee.com/DieHunter/myCode/tree/master/Echart/PolarGauge</a></p>

<p>同样需要引入Echarts<br><strong>HTML：</strong></p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
        }

        .PolarGauge {
            margin: 100px auto;
            background: #000;
            width: 400px;
            height: 400px;
        }
    &lt;/style&gt;
    &lt;script src="./echarts.js"&gt;&lt;/script&gt;
    &lt;script src="./chart.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="PolarGauge" class="PolarGauge"&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<p><strong>chart.js</strong></p>

<pre><code class="language-javascript">var chart, option, data, timeTickId, timer, max;
window.onload = function init() {
    chart = echarts.init(PolarGauge); //初始化chart容器
    data = { //显示的数据
        "name": '馆藏量',
        "num": 1000
    }
    timer = 1.5 //刷新频率
    max = 1000 //最大馆藏量
    createPolarGauge() //配置chart
}

function createPolarGauge() {
    option = {
        angleAxis: {
            show: false,
            max: max * 3 / 2, //这里将极坐标最大值转换成仪表盘的最大值，(360度除以240度)
            type: 'value',
            startAngle: 210, //极坐标初始角度，从第一象限算起，大约在7-8点钟角度之间
            splitLine: {
                show: false //隐藏坐标
            }
        },
        barMaxWidth: 18, //圆环宽度
        radiusAxis: { //隐藏坐标
            show: false,
            type: 'category',
        },
        polar: { //设置圆环位置和大小
            center: ['50%', '50%'],
            radius: '296'
        },
        series: [{
                type: 'bar',
                data: [{ //上层圆环，用于显示真实数据
                    value: data.num,
                    itemStyle: {
                        color: { //图形渐变颜色方法，四个数字分别代表，右，下，左，上，offset表示0%到100%
                            type: 'linear',
                            x: 0,
                            y: 0,
                            x2: 1, //从左到右 0-1
                            y2: 0,
                            colorStops: [{
                                offset: 0,
                                color: '#CD48AE' // 0% 处的颜色
                            }, {
                                offset: 1,
                                color: '#2CABFC' // 100% 处的颜色
                            }],
                            globalCoord: false // 缺省为 false
                        },
                        shadowColor: 'rgba(255, 255, 255, 0.2)', //加白色阴影产生高亮效果
                        shadowBlur: 10
                    }
                }],
                barGap: '-100%', //柱间距离,用来将上下两层圆环重合
                coordinateSystem: 'polar', //类型，极坐标
                roundCap: true, //顶端圆角
                z: 2 //圆环层级，和zindex相似
            }, { //下层圆环，用于显示最大值
                type: 'bar',
                data: [{
                    value: max,
                    itemStyle: {
                        color: '#265195',
                        shadowColor: 'rgba(0, 0, 0, 0.2)', //加白色阴影产生高亮效果
                        shadowBlur: 5,
                        shadowOffsetY: 2
                    }
                }],
                barGap: '-100%', //柱间距离,用来将上下两层圆环重合
                coordinateSystem: 'polar', //类型，极坐标
                roundCap: true, //顶端圆角
                z: 1 //圆环层级，和zindex相似
            },
            { //仪表盘
                type: 'gauge',
                radius: '95%',
                startAngle: 210, //起始角度，同极坐标
                endAngle: -30, //终止角度，同极坐标
                max: max,
                splitNumber: 5, //分割线个数（除原点外）
                axisLine: { // 坐标轴线
                    show: false
                },
                pointer: {
                    show: false
                },
                axisLabel: {
                    // 坐标轴数字
                    textStyle: {
                        fontSize: 8,
                        color: "#13B5FC"
                    },

                },
                axisTick: { // 坐标轴标记
                    length: 10,
                    lineStyle: {
                        color: "#13B5FC"
                    }
                },
                splitLine: { // 分隔线
                    length: 5,
                    lineStyle: {
                        width: 1,
                    }
                },
                title: { //标题，显示'馆藏量'
                    textStyle: {
                        color: '#fff',
                        shadowColor: '#fff',
                        fontSize: 30
                    },
                    offsetCenter: ["0", '-35%'] //位置偏移
                },
                detail: { //仪表盘数值
                    formatter: function (params) {
                        var name = data.num.toString()
                        var list = ''
                        for (var i = 0; i &lt; name.length; i++) {
                            list += '{value|' + name[i] + '}' //每个数字用border隔开
                            if (i !== name.length - 1) {
                                list += '{margin|}' //添加margin值
                            }
                        }
                        return [list]
                    },
                    offsetCenter: ["0", '5%'],
                    rich: { //编辑富文本样式
                        value: {
                            width: 34,
                            height: 42,
                            borderColor: '#02A0F0',
                            borderWidth: 2,
                            borderRadius: 5,
                            lineHeight: 1000,
                            fontSize: 36,
                            padding: [0, 0, 4, 0],
                            color: '#fff',
                            shadowColor: 'rgb(2,157,239)',
                            shadowBlur: 5
                        },
                        margin: {
                            width: 8,
                            height: 42,
                        }
                    }

                },
                data: [{
                    value: data.num,
                    name: data.name
                }]
            }
        ]
    }
    timeTick()
}

function setOption() { //更新数据
    data.num = parseInt(Math.random() * max)
    option.series[2].data[0].value = data.num
    option.series[0].data[0].value = data.num
    chart.setOption(option)
}


function timeTick() { //定时器,最好用延时加递归，如果用setInterval，容易造成堵塞
    if (timeTickId) {
        clearTimeout(timeTickId)
        timeTickId = 0
    }
    setOption()
    timeTickId = setTimeout(timeTick, 1000 * timer || 5000)
}</code></pre>

<p><strong>总结：</strong>编程即生活，有时候不能死磕到底，换个角度也许会更好</p>
                                    ]]></description></item><item><title>Echarts案例：使用象形柱状图（PictorialBar）实现电池效果柱状图</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/21/12560806.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 21 Mar 2020 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/21/12560806.html</guid><description><![CDATA[
                                            <p>&nbsp;分享一个公司项目案例</p>

<p>UI小姐姐给的图是这样的：</p>

<p><img alt="" height="239" src="https://img-blog.csdnimg.cn/20200320215546388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="407"></p>

<p>最终实现效果：</p>

<p><img alt="" height="235" src="https://img-blog.csdnimg.cn/20200320220049870.gif" width="451"></p>

<p>以下是所有代码</p>

<p><strong>源码：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/Echart/PictorialBar" rel="nofollow">https://gitee.com/DieHunter/myCode/tree/master/Echart/PictorialBar</a></p>

<p>首先引入Echarts，cdn或npm都行</p>

<p><strong>HTML：</strong></p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
        }

        .myChartBox {
            margin: 100px auto;
            width: 450px;
            height: 240px;
            background: #000;
        }
    &lt;/style&gt;
    &lt;script src="./data.js"&gt;&lt;/script&gt;
    &lt;script src="./echarts.js"&gt;&lt;/script&gt;
    &lt;script src="./myChart.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="myChartBox" class="myChartBox"&gt;&lt;/div&gt;
    &lt;script&gt;
        let _myChart, _option, timer = 1.5,
            timeTickId, colorList, chartConfig; //初始化变量，分别是初始化后的echart对象，echart配置信息，图表刷新频率，延时递归函数id，图表渐变颜色列表了，列表联动配置
        let {
            category,
            lineData
        } = filterData(bookList) //过滤后端数据，规范成x轴数组和y轴数组格式
        let init = () =&gt; {
            _myChart = echarts.init(myChartBox); //初始化chart
            colorList = {
                first: ["#F179C4", "#26AEFB", "#CDAD92", "#ED65BA", "#989FBB", "#E86A6A", "#6718CF"],
                second: ["#E33AA3", "#056FAB", "#FFAA62", "#E33AA3", "#28B1FF", "#FFAA62", "#F47384"]
            }
            chartConfig = { //配置信息为，chart中横坐标第一项索引，最后一项索引，规定列表长度
                first: 0,
                second: 7,
                max: 20
            }
            createChart()
        };
        (() =&gt; {
            init()
        })()
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>&nbsp;<strong>data.js（暂存数据）</strong></p>

<pre><code class="language-javascript">const bookList = [{
    "typeName": "综合图书",
    "bnum": 28264
}, {
    "typeName": "文学",
    "bnum": 14591
}, {
    "typeName": "儿童文学",
    "bnum": 10186
}, {
    "typeName": "文化教育",
    "bnum": 20477
}, {
    "typeName": "语言文字",
    "bnum": 17344
}, {
    "typeName": "哲学",
    "bnum": 16238
}, {
    "typeName": "历史地理",
    "bnum": 15457
}, {
    "typeName": "政治思想",
    "bnum": 5793
}, {
    "typeName": "生物科学",
    "bnum": 4966
}, {
    "typeName": "绘本",
    "bnum": 4521
}, {
    "typeName": "艺术",
    "bnum": 4157
}, {
    "typeName": "地球天文",
    "bnum": 2545
}, {
    "typeName": "军事",
    "bnum": 2368
}, {
    "typeName": "自然科学",
    "bnum": 2358
}, {
    "typeName": "工业技术",
    "bnum": 1830
}, {
    "typeName": "社会科学",
    "bnum": 1689
}, {
    "typeName": "数理化",
    "bnum": 1394
}, {
    "typeName": "政治法律",
    "bnum": 1303
}, {
    "typeName": "少年百科",
    "bnum": 1201
}, {
    "typeName": "经济",
    "bnum": 923
}, {
    "typeName": "童话故事",
    "bnum": 840
}, {
    "typeName": "环境安全",
    "bnum": 615
}, {
    "typeName": "医药卫生",
    "bnum": 518
}, {
    "typeName": "航空航天",
    "bnum": 457
}, {
    "typeName": "农业科学",
    "bnum": 347
}, {
    "typeName": "家庭教育",
    "bnum": 211
}, {
    "typeName": "交通运输",
    "bnum": 188
}]</code></pre>

<p><strong>myChart.js</strong></p>

<pre><code class="language-javascript">let createChart = () =&gt; {
    _option = {
        grid: [{ //设置边距
            left: 55,
            bottom: 53,
            top: 20,
            right: 10
        }],
        yAxis: { //Y轴配置
            show: true,
            axisLine: {
                show: false,
                lineStyle: { //隐藏Y轴
                    opacity: 0
                }
            },
            axisTick: { //隐藏刻度
                show: false,
            },
            splitLine: { //隐藏刻度
                show: false,
            },
            axisLabel: { //Y轴文字
                color: '#fff',
                fontSize: 12
            },
        },
        xAxis: { //X轴配置
            data: category, //X轴数据
            show: true,
            axisLabel: { //X轴文字样式
                color: '#a9aabc',
                fontSize: 12,
                interval: 0,
                padding: [10, 0, 0, 0]
            },
            axisLine: {
                show: false
            },
            axisTick: {
                show: false,
            }
        },
        series: [{
            name: '',
            type: 'pictorialBar', //设置类型为象形柱状图
            symbol: 'roundRect', //图形类型，带圆角的矩形
            barWidth: '11%', //柱图宽度
            barMaxWidth: '20%', //最大宽度
            symbolMargin: '3', //图形垂直间隔
            animationDelay: (dataIndex, params) =&gt; { //每个图形动画持续时间
                return params.index * 50;
            },
            itemStyle: {
                normal: {
                    color: params =&gt; { //图形渐变颜色方法，四个数字分别代表，右，下，左，上，offset表示0%到100%
                        return new echarts.graphic.LinearGradient(
                            1, 1, 0, 0, [{
                                    offset: 0,
                                    color: colorList.first[params.dataIndex]
                                },
                                {
                                    offset: 1,
                                    color: colorList.second[params.dataIndex]
                                }
                            ])
                    }
                }
            },
            z: 1,
            symbolRepeat: true, //图形是否重复
            symbolSize: [25, 6], //图形元素的尺寸
            data: lineData, //Y轴数据
            animationEasing: 'elasticOut' //动画效果
        }]
    }
    timeTick()
}
let disposeChart = () =&gt; { //销毁chart
    _myChart.dispose()
    _myChart = null
}
let setOption = () =&gt; { //重置数据
    _option.xAxis.data = category.slice(chartConfig.first, chartConfig.second)
    _option.series[0].data = lineData.slice(chartConfig.first, chartConfig.second)
    _myChart.setOption(_option, true)
}
let timeTick = () =&gt; { //定时器,最好用延时加递归，如果用setInterval，容易造成堵塞
    if (timeTickId) {
        clearTimeout(timeTickId)
        timeTickId = 0
    }
    autoChangeData()
    timeTickId = setTimeout(timeTick, 1000 * timer || 5000)
}
let autoChangeData = () =&gt; { //偏移数组，切换数据
    if (!chartConfig.max) {
        return
    }
    if (chartConfig.second &gt;= chartConfig.max) {
        chartConfig.second = chartConfig.second - chartConfig.first
        chartConfig.first = 0
    } else {
        chartConfig.first++
        chartConfig.second++
    }
    setOption()
}
let filterData = (data, category = [], lineData = []) =&gt; { //过滤后端数据，分别变成X轴数组和Y轴数组
    data.forEach(item =&gt; {
        item.typeName = item.typeName.length &gt; 2 ? item.typeName.substring(0, 2) : item.typeName
        category.push(item.typeName || '')
        lineData.push(item.bnum || 0)
    })
    return {
        category,
        lineData
    }
}</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>Echarts案例：使用极坐标加柱状图实现类似Apple Watch上的运动环形效果</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/21/12560807.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 21 Mar 2020 02:10:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/21/12560807.html</guid><description><![CDATA[
                                            <p>分享自己公司项目类似的一个案例，用Echarts中的Polar（极坐标或称为平面直角坐标系）和Bar（柱状图）实现的</p>

<p>大致效果是这样的</p>

<p><img alt="" height="236" src="https://img-blog.csdnimg.cn/20200320173636628.gif" width="317"></p>

<p>参照的是AntV中的<a href="https://antv-f2.gitee.io/zh/examples/gallery/fitness-ring" rel="nofollow">https://antv-f2.gitee.io/zh/examples/gallery/fitness-ring</a>的效果，只不过我是用Echarts实现的<br>
首先需要引入Echarts.js,推荐用npm下载：npm install echarts<br>
或直接用cdn托管：<a href="https://www.bootcdn.cn/echarts/" rel="nofollow">https://www.bootcdn.cn/echarts/</a><br><strong>源码：</strong><a href="https://gitee.com/DieHunter/myCode/tree/master/Echart/AppleWatch" rel="nofollow">https://gitee.com/DieHunter/myCode/tree/master/Echart/AppleWatch</a><br>
以下是全部代码：</p>

<p><strong>HTML：</strong></p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
        }

        .chart_box {
            width: 300px;
            height: 300px;
            margin: 100px auto 0;
            background: #000;
        }
    &lt;/style&gt;
    &lt;script src="./echarts.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="chart_box" class="chart_box"&gt;&lt;/div&gt;
    &lt;script type="module"&gt;
        import MyChart from './MyChart.js'
        MyChart.getInstance(echarts,chart_box).createChart()//初始化入口函数
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<p><strong>JS：</strong></p>

<pre><code class="language-javascript">export default class MyChart {
    constructor(_echart, _ele) {
        this.timeTickId = null //定时器id
        this.timer = 1.5 //更新数据频率
        this.option = null //当前echarts实例的属性
        this._echart = _echart //引入Echarts
        this._ele = _ele //案例的父元素
        this.myChart = null //当前echarts实例
        this.colorList = ['#14A5AB', '#88D903', '#E90B3A'] //上层环背景
        this.bgList = ['#183C3D', '#324214', '#40131D'] //下层环背景
        this.maxCount = 100 //圆环最大值,即转一圈的值
    }
    static getInstance() { //单例模式
        if (!MyChart._instance) {
            Object.defineProperty(MyChart, "_instance", {
                value: new MyChart(...arguments)
            })
        }
        return MyChart._instance;
    }
    createChart = () =&gt; {
        this.disposeChart() //创建前初始化chart实例，若有，则销毁
        this.myChart = this._echart.init(this._ele)
        this.option = {
            angleAxis: {
                show: false, //隐藏角度轴（圆心角）
                max: this.maxCount,
                startAngle: 90, //极坐标从第一象限开始，即平面直角坐标系,用时钟理解，0就是三点钟方向，这里我们从12点钟方向开始，也就是3点钟方向加90度
                splitLine: {
                    show: false //隐藏分隔线
                },
            },
            barMaxWidth: 50, //设置圆环最大宽度
            radiusAxis: {
                show: false, //隐藏径向轴（半径）
                type: 'category',
                data: ['A', 'B', 'C'] //传入每条圆环的径向值
            },
            polar: {
                radius: [30, 150] //总体的最小半径，最大半径
            },
            series: [{ //上层的圆环
                    type: 'bar',
                    data: [1, 2, 3], //初始值
                    coordinateSystem: 'polar', //设置类型为极坐标
                    roundCap: true, //柱状图末端呈现圆角
                    itemStyle: { //设置每一个圆环的颜色
                        color: (params) =&gt; {
                            return this.colorList[params.dataIndex]
                        }
                    },
                    animationEasing: 'bounceOut', //初始动画
                    barGap: '-100%', //柱间距离,用来将上下两种圆环重合
                    z: 200, //圆环层级，和zindex相似
                },
                { //下层的圆环
                    type: 'bar',
                    data: [this.maxCount, this.maxCount, this.maxCount],
                    coordinateSystem: 'polar',
                    roundCap: true,
                    itemStyle: { //设置每一个圆环的颜色
                        color: (params) =&gt; {
                            return this.bgList[params.dataIndex]
                        }
                    },
                    z: 100,
                    barGap: '-100%', //柱间距离,用来将上下两种圆环重合
                }
            ]
        };
        this.timeTick() //定时器入口
    }
    setOption = () =&gt; { //随机数刷新数据
        if (this.option) {
            this.option.series[0].data = this.option.series[0].data.map(item =&gt; {
                return Math.random() * this.maxCount
            })
        }
        this.myChart.setOption(this.option, true)
    }
    disposeChart = () =&gt; { //初始化chart实例
        if (this.myChart) {
            this.myChart.dispose()
            this.myChart = null
            this.option = null
        }
    }
    timeTick = () =&gt; { //定时器,最好用延时加递归，如果用setInterval，容易造成堵塞
        if (this.timeTickId) {
            clearTimeout(this.timeTickId)
            this.timeTickId = 0
        }
        this.setOption()
        this.timeTickId = setTimeout(this.timeTick, 1000 * this.timer || 5000)
    }
}</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>使用JS+socket.io+WebRTC+nodejs+express搭建一个简易版远程视频聊天</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/12/12482603.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 12 Mar 2020 04:37:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/12/12482603.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="WebRTC-toc" style="margin-left:40px;"><a href="#WebRTC" rel="nofollow">WebRTC</a></p>

<p id="%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B" rel="nofollow">代码原理及流程</a></p>

<p id="%E5%89%8D%E7%AB%AF-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E7%AB%AF" rel="nofollow">前端</a></p>

<p id="%E5%85%88%E9%99%84%E4%B8%8AHTML%E5%92%8CCSS-toc" style="margin-left:80px;"><a href="#%E5%85%88%E9%99%84%E4%B8%8AHTML%E5%92%8CCSS" rel="nofollow">先附上HTML和CSS</a></p>

<p id="%E5%AE%8C%E6%95%B4%E7%9A%84socket.js-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84socket.js" rel="nofollow">完整的socket.js</a></p>

<p id="%E5%AE%8C%E6%95%B4%E7%9A%84userList.js%EF%BC%88%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%9C%A8%E7%BA%BF%E5%88%97%E8%A1%A8%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%82%80%E8%AF%B7%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84userList.js%EF%BC%88%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%9C%A8%E7%BA%BF%E5%88%97%E8%A1%A8%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%82%80%E8%AF%B7%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%89" rel="nofollow">完整的userList.js（创建用户在线列表，添加邀请事件，初始化聊天室）</a></p>

<p id="%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">遇到的问题</a></p>

<p id="%E4%BC%98%E5%8C%96%E5%90%8E%E5%AE%8C%E6%95%B4%E7%9A%84video.js-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E5%8C%96%E5%90%8E%E5%AE%8C%E6%95%B4%E7%9A%84video.js" rel="nofollow">优化后完整的video.js</a></p>

<p id="%E6%9C%8D%E5%8A%A1%E7%AB%AF-toc" style="margin-left:40px;"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF" rel="nofollow">服务端</a></p>

<p id="%E5%AE%8C%E6%95%B4%E7%9A%84server.js-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84server.js" rel="nofollow">完整的server.js</a></p>

<p id="%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C" rel="nofollow">实现效果</a></p>

<p id="%E6%B3%A8%E6%84%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%B3%A8%E6%84%8F%EF%BC%9A" rel="nofollow">注意</a></p>

<hr id="hr-toc"><h2 id="WebRTC"><strong>WebRTC</strong></h2>

<p><strong>网页即时通信，</strong>是<strong>Web Real-Time Communication&nbsp;</strong>的缩写，它支持<strong>peer-to-peer（浏览器与浏览器之间）</strong>进行视频，音频传输，并保证传输质量，将其发送至本地<strong>audio</strong>标签，<strong>video</strong>标签或发送到另一个浏览器中，本文使用到<strong>navigator.mediaDevices</strong>，<strong>RTCPeerConnection</strong>对象配合<strong>socket+node</strong>构建远程实时视频聊天功能，文章有一个不足之处，后面会讲到。</p>

<p><strong>相关文档：</strong><br><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices" rel="nofollow">MediaDevices</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" rel="nofollow">WebRTC API</a></strong></p>

<p><strong>参考文章：</strong><br><a href="https://rtcdeveloper.com/t/topic/13777" rel="nofollow"><strong>https://rtcdeveloper.com/t/topic/13777</strong></a></p>

<h2 id="%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B">代码原理及流程</h2>

<p><img alt="" height="454" src="https://img-blog.csdnimg.cn/20200311214302905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="963"></p>

<h2 id="%E5%89%8D%E7%AB%AF"><strong>前端</strong></h2>

<p>要实现点对点就需要用到socket长链接从服务端进行寻呼<br>
这是我以前的一篇关于socket简单使用的小案例：<strong><a href="https://blog.csdn.net/time_____/article/details/86748679">https://blog.csdn.net/time_____/article/details/86748679</a></strong><br>
首先引入<strong><a href="https://cdn.bootcss.com/socket.io/2.3.0/socket.io.js" rel="nofollow">socket.io</a></strong>，这里我将前端js分成三部分，分别是socket.js（socket相关操作），userList.js（页面操作）,video.js（视频聊天）</p>

<p><img alt="" height="199" src="https://img-blog.csdnimg.cn/20200311200304249.png" width="221"></p>

<h3 id="%E5%85%88%E9%99%84%E4%B8%8AHTML%E5%92%8CCSS">先附上HTML和CSS</h3>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel="stylesheet" href="./style/main.css"&gt;
    &lt;script src="./js/socket.io.js"&gt;&lt;/script&gt;
    &lt;script src="./js/socket.js"&gt;&lt;/script&gt;
    &lt;script src="./js/userList.js"&gt;&lt;/script&gt;
    &lt;script src="./js/video.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="login" hidden class="loginBox"&gt;
        &lt;input id="userName" autocomplete="false" class="userName" type="text" placeholder="请输入英文用户名"&gt;
        &lt;button id="submit"&gt;提交&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id="chatBox" class="chatBox" hidden&gt;
        &lt;h1 id="myName" class="myName"&gt;&lt;/h1&gt;
        &lt;ul id="userList" class="userList"&gt;&lt;/ul&gt;
    &lt;/div&gt;
    &lt;div id="videoChat" hidden class="videoChat"&gt;
        &lt;button id="back" hidden&gt;结束&lt;/button&gt;
        &lt;video id="myVideo" src="" class="myVideo"&gt;&lt;/video&gt;
        &lt;video id="otherVideo" src="" class="otherVideo"&gt;&lt;/video&gt;
    &lt;/div&gt;
    &lt;script&gt;
        checkToken()

        function checkToken() { //判断用户是否已有用户名
            if (localStorage.token) {
                login.hidden = true
                chatBox.hidden = false
                initSocket(localStorage.token) //初始化socket连接
            } else {
                login.hidden = false
                chatBox.hidden = true
                submit.addEventListener('click', function (e) {
                    initSocket(userName.value) //初始化socket连接
                })
            }
        }
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<pre><code class="language-css">* {
    margin: 0;
    padding: 0;
}

.loginBox {
    width: 300px;
    height: 200px;
    margin: 50px auto 0;
}

.userName,
.loginBox button {
    width: 300px;
    height: 60px;
    border-radius: 10px;
    outline: none;
    font-size: 26px;
}

.userName {
    border: 1px solid lightcoral;
    text-align: center;
}

.loginBox button {
    margin-top: 30px;
    display: block;
}

input::placeholder {
    font-size: 26px;
    text-align: center;
}

.chatBox {
    width: 200px;
    margin: 50px auto 0;
    position: relative;
}

.myName {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50px;
    font-size: 40px;
    text-align: center;
    line-height: 50px;
    background: lightcoral;
}

.userList {
    height: 500px;
    width: 100%;
    padding-top: 50px;
    overflow-y: scroll;
    list-style: none;
}

.userList&gt;li {
    background: lightblue;
    height: 50px;
    font-size: 20px;
    line-height: 50px;
    text-align: center;
}

.videoChat {
    background: lightgreen;
    width: 500px;
    height: 400px;
    margin: 50px auto 0;
}

.videoChat button {
    width: 500px;
    height: 60px;
    border-radius: 10px;
    outline: none;
    float: left;
    font-size: 26px;
}

.myVideo,.otherVideo{
    width: 250px;
    height: 250px;
    float: left;
    overflow: hidden;
}</code></pre>

<p><strong>大致效果</strong></p>

<p><img alt="" height="122" src="https://img-blog.csdnimg.cn/20200311220142550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="193"><img alt="" height="129" src="https://img-blog.csdnimg.cn/20200311220245995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="161"><img alt="" height="128" src="https://img-blog.csdnimg.cn/20200311220259218.png" width="171"></p>

<p><strong>socket.js</strong><br>
首先建立socket连接，添加连接和断开的事件</p>

<pre><code class="language-javascript">let socket //供其他页面调用

function initSocket(token) {//获取到用户输入的id并传到服务端
    socket = io('http://127.0.0.1:1024?token=' + token, {
        autoConnect: false
    });
    socket.open();
    socket.on('open', socketOpen); //连接登录
    socket.on('disconnect', socketClose); //连接断开
}

function socketClose(reason) { //主动或被动关闭socket
    console.log(reason)
    localStorage.removeItem("token")
}

function socketOpen(data) { //socket开启
    if (!data.result) { //当服务端找到相同id时跳出连接
        console.log(data.msg)
        return;
    }
createChatList(data) //创建用户列表
    localStorage.setItem('token', data.token)
    login.hidden = true
    chatBox.hidden = false
    videoChat.hidden = true
    myName.textContent = localStorage.token
}</code></pre>

<p>之后在socket中添加几个事件监听</p>

<pre><code class="language-javascript">    socket.on('dataChange', createChatList); //新增人员
    socket.on('inviteVideoHandler', inviteVideoHandler); //被邀请视频
    socket.on('askVideoHandler', askVideoHandler); //视频邀请结果
    socket.on('ice', getIce); //从服务端接收ice
    socket.on('offer', getOffer); //从服务端接收offer
    socket.on('answer', getAnswer); //从服务端接收answer
    socket.on('break', stopVideoStream) //挂断视频通话</code></pre>

<p>若用户接到对方邀请时，弹出确认框，并将结果返回给对方</p>

<pre><code class="language-javascript">function inviteVideoHandler(data) { //当用户被邀请时执行
    let allow = 0
    if (isCalling) {
        allow = -1 //正在通话
    } else {
        let res = confirm(data.msg);
        if (res) {
            allow = 1
            startVideoChat(data.token) //用户点击同意后开始初始化视频聊天
            localStorage.setItem('roomNo', data.roomNo) //将房间号保存
        }
    }
    socket.emit('askVideo', {
        myId: localStorage.token,
        otherId: data.token,
        type: 'askVideo',
        allow
    });
}</code></pre>

<p>当收到返回邀请结果时，后端创建视频聊天房间后，开始初始化聊天室</p>

<pre><code class="language-javascript">function askVideoHandler(data) { //获取被邀请用户的回复
    console.log(data.msg)
    if (data.allow == -1) return //通话中
    if (data.allow) {
        localStorage.setItem('roomNo', data.roomNo) //将房间号保存
        startVideoChat(data.token)
    }
}</code></pre>

<p>当用户挂断时</p>

<pre><code class="language-javascript">function breakVideoConnect(e) {
    console.log(localStorage.getItem('roomNo'))
    socket.emit('_break', {
        roomNo: localStorage.getItem('roomNo')
    });
}</code></pre>

<p>&nbsp;</p>

<ul><li>
	<h3 id="%E5%AE%8C%E6%95%B4%E7%9A%84socket.js">完整的socket.js<br>
	&nbsp;</h3>

	<pre><code class="language-javascript">let socket //供其他页面调用

function initSocket(token) {//获取到用户输入的id并传到服务端
    socket = io('http://127.0.0.1:1024?token=' + token, {
        autoConnect: false
    });
    socket.open();
    socket.on('open', socketOpen); //连接登录
    socket.on('disconnect', socketClose); //连接断开
    socket.on('dataChange', createChatList); //新增人员
    socket.on('inviteVideoHandler', inviteVideoHandler); //被邀请视频
    socket.on('askVideoHandler', askVideoHandler); //视频邀请结果
    socket.on('ice', getIce); //从服务端接收ice
    socket.on('offer', getOffer); //从服务端接收offer
    socket.on('answer', getAnswer); //从服务端接收answer
    socket.on('break', stopVideoStream) //挂断视频通话
}

function socketClose(reason) { //主动或被动关闭socket
    console.log(reason)
    localStorage.removeItem("token")
}

function socketOpen(data) { //socket开启
    if (!data.result) { //当服务端找到相同id时跳出连接
        console.log(data.msg)
        return;
    }
    createChatList(data) //创建用户列表
    localStorage.setItem('token', data.token)
    login.hidden = true
    chatBox.hidden = false
    videoChat.hidden = true
    myName.textContent = localStorage.token
}

function inviteVideoHandler(data) { //当用户被邀请时执行
    let allow = 0
    if (isCalling) {
        allow = -1 //正在通话
    } else {
        let res = confirm(data.msg);
        if (res) {
            allow = 1
            startVideoChat(data.token) //用户点击同意后开始初始化视频聊天
            localStorage.setItem('roomNo', data.roomNo) //将房间号保存
        }
    }
    socket.emit('askVideo', {
        myId: localStorage.token,
        otherId: data.token,
        type: 'askVideo',
        allow
    });
}

function askVideoHandler(data) { //获取被邀请用户的回复
    console.log(data.msg)
    if (data.allow == -1) return //通话中
    if (data.allow) {
        localStorage.setItem('roomNo', data.roomNo) //将房间号保存
        startVideoChat(data.token)
    }
}

function breakVideoConnect(e) {
    console.log(localStorage.getItem('roomNo'))
    socket.emit('_break', {
        roomNo: localStorage.getItem('roomNo')
    });
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>
	<h3 id="%E5%AE%8C%E6%95%B4%E7%9A%84userList.js%EF%BC%88%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%9C%A8%E7%BA%BF%E5%88%97%E8%A1%A8%EF%BC%8C%E6%B7%BB%E5%8A%A0%E9%82%80%E8%AF%B7%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%89">完整的userList.js（创建用户在线列表，添加邀请事件，初始化聊天室）</h3>
	</li>
</ul><pre><code class="language-javascript">function createChatList(data) { //新建用户列表
    console.log(data.msg)
    let userData = data.userIds
    let userList = document.querySelector('#userList')
    if (userList) {
        userList.remove()
        userList = null
    }
    userList = createEle('ul', {}, {
        id: 'userList',
        className: 'userList'
    })
    chatBox.appendChild(userList)
    for (let key in userData) {
        if (userData[key] != localStorage.token) {
            var li = createEle('li', {}, {
                textContent: userData[key]
            })
            li.addEventListener('click', videoStart)
            userList.appendChild(li)
        }
    }
}

function createEle(ele, style, attribute) { //新增标签，设置属性及样式
    let element = document.createElement(ele)
    if (style) {
        for (let key in style) {
            element.style[key] = style[key];
        }
    }
    if (attribute) {
        for (let key in attribute) {
            element[key] = attribute[key];
        }
    }
    return element
}

function videoStart(e) { //用户点击列表某个用户时发送邀请至服务端
    socket.emit('inviteVideo', {
        myId: localStorage.token,
        otherId: this.textContent,
        type: 'inviteVideo'
    });
}

function startVideoChat(otherId) { //初始化视频聊天
    videoChat.hidden = false
    login.hidden = true
    chatBox.hidden = true
    localStorage.setItem('otherId', otherId) //将对方的id保存
    startVideoStream()
}</code></pre>

<p><strong>video.js</strong></p>

<p>初始化媒体对象，并将Stream存到全局，这里由于navigator.mediaDevices.getUserMedia是异步方法，需要同步执行，先获取stream，然后进行后续操作</p>

<pre><code class="language-javascript">async function createMedia() { //同步创建本地媒体流
    if (!stream) {
        stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: true
        })
    }
    console.log(stream)
    let video = document.querySelector('#myVideo');
    video.srcObject = stream; //将媒体流输出到本地video以显示自己
    video.onloadedmetadata = function (e) {
        video.play();
    };
    createPeerConnection()
}</code></pre>

<p>创建stream后，初始化RTCPeerConnection，用于建立视频连接，同样需要同步获取，并且在peer获取之后发送offer给对方</p>

<pre><code class="language-javascript">
async function createPeerConnection() { //同步初始化描述文件并添加事件
    if (!peer) {
        peer = new RTCPeerConnection()
    }
    await stream.getTracks().forEach(async track =&gt; {
        await peer.addTrack(track, stream); //将本地流附属至peer中
    });
    // await peer.addStream(stream); //旧方法（将本地流附属至peer中）
    peer.addEventListener('addstream', setVideo) //当peer收到其他流时显示另一个video以显示对方
    peer.addEventListener('icecandidate', sendIce) //获取到candidate时，将其发送至服务端，传至对方
    peer.addEventListener('negotiationneeded', sendOffer) //双方约定的协商被完成时才触发该方法
}</code></pre>

<p>当收到对方发送过来的stream时，即触发addstream事件时，通过setVideo将对方的视频流放到本地video中</p>

<pre><code class="language-javascript">function setVideo(data) { //播放对方的视频流
    console.log(data.stream)
    let back = document.getElementById('back')
    back.hidden = false //显示挂断按钮
    back.addEventListener('click', breakVideoConnect) //挂断事件
    isCalling = true //正在通话
    let video = document.querySelector('#otherVideo');
    video.srcObject = data.stream;
    video.onloadedmetadata = function (e) {
        video.play();
    };
}
</code></pre>

<p>&nbsp;创建offer，保存本地offer，并发送offer给对方</p>

<pre><code class="language-javascript">async function sendOffer() { //同步发送offer到服务端，发送给对方
    let offer = await peer.createOffer();
    await peer.setLocalDescription(offer); //peer本地附属offer
    socket.emit('_offer', {
        streamData: offer
    });
}</code></pre>

<p>收到对方的offer后，保存远程offer，但是这里有一个小问题，如果peer还没有创建好，也就是如果对方先创建，就会马上发offer过来，这时我们这边的peer可能还没有创建成功，如果直接调用setRemoteDescription的话会报错，所以可以用try&nbsp; catch来调用，或使用if(!peer) return的方式运行</p>

<pre><code class="language-javascript">async function getOffer(data) { //接收到offer后，返回answer给对方
    await peer.setRemoteDescription(data.streamData); //peer远程附属offer
    sendAnswer()
}


//优化后
async function getOffer(data) { //接收到offer后，返回answer给对方
    if (!peer) return //等待对方响应，也可以用try catch
    await peer.setRemoteDescription(data.streamData); //peer远程附属offer
    sendAnswer()
}</code></pre>

<p>创建answer，保存本地answer，发送answer给对方</p>

<pre><code class="language-javascript">async function sendAnswer() {
    let answer = await peer.createAnswer();
    await peer.setLocalDescription(answer); //peer附属本地answer
    socket.emit('_answer', {
        streamData: answer
    });
}</code></pre>

<p>&nbsp;接收到answer时，保存本地answer</p>

<pre><code class="language-javascript">async function getAnswer(data) { //接收到answer后，peer远程附属answer
    await peer.setRemoteDescription(data.streamData);
}</code></pre>

<p>peer触发icecandidate事件时，即本地触发过setLocalDescription时，也就是将本地offer和本地answer保存时，触发方法</p>

<pre><code class="language-javascript">function sendIce(e) { //setLocalDescription触发时，发送ICE给对方
    if (e.candidate) {
        socket.emit('_ice', {
            streamData: e.candidate
        });
    }
}</code></pre>

<p>&nbsp;接收对方的ICE，但是这里有一个和上面一样的小问题如果在ICE事件中，peer还没有创建好，也就是如果对方先创建，就会马上发offer过来，这时我们这边的peer可能还没有创建成功，如果直接调用addIceCandidate的话会报错，所以可以用try&nbsp; catch来调用，或使用if(!peer) return的方式运行</p>

<pre><code class="language-javascript">async function getIce(data) { //获取对方的ICE
    var candidate = new RTCIceCandidate(data.streamData)
    await peer.addIceCandidate(candidate)
}

//优化后

async function getIce(data) { //获取对方的ICE
    if (!peer) return //等待对方响应，也可以用try catch
    var candidate = new RTCIceCandidate(data.streamData)
    await peer.addIceCandidate(candidate)
}</code></pre>

<h3 id="%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">遇到的问题</h3>

<p>最后是挂断的方法，这里有个小问题，<strong>当挂断时，原来的stream无法删除，导致摄像头虽然没有调用，但是导航栏仍然会有摄像头图标（没有真正关闭），下一次打开时会传输前面的流（叠加），网上没有解决方式，如果有知道的同学，希望能补充优化，感谢</strong></p>

<pre><code class="language-javascript">function stopVideoStream(data) { //停止传输视频流
    console.log(data.msg)
    stream.getTracks().forEach(async function (track) { //这里得到视频或音频对象
        await track.stop();
        await stream.removeTrack(track)
        stream = null
    })
    peer.close();
    peer = null;
    isCalling = false
    videoChat.hidden = true
    login.hidden = true
    chatBox.hidden = false
}</code></pre>

<ul><li>
	<h3 id="%E4%BC%98%E5%8C%96%E5%90%8E%E5%AE%8C%E6%95%B4%E7%9A%84video.js">优化后完整的video.js<br>
	&nbsp;</h3>

	<pre><code class="language-javascript">var stream, peer, isCalling = false //初始化要发送的流,和描述文件,通话状态
function startVideoStream(e) { //开始传输视频流
    createMedia()
}

function stopVideoStream(data) { //停止传输视频流
    console.log(data.msg)
    stream.getTracks().forEach(async function (track) { //这里得到视频或音频对象
        await track.stop();
        await stream.removeTrack(track)
        stream = null
    })
    peer.close();
    peer = null;
    isCalling = false
    videoChat.hidden = true
    login.hidden = true
    chatBox.hidden = false
}

async function createMedia() { //同步创建本地媒体流
    if (!stream) {
        stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: true
        })
    }
    console.log(stream)
    let video = document.querySelector('#myVideo');
    video.srcObject = stream; //将媒体流输出到本地video以显示自己
    video.onloadedmetadata = function (e) {
        video.play();
    };
    createPeerConnection()
}

async function createPeerConnection() { //同步初始化描述文件并添加事件
    if (!peer) {
        peer = new RTCPeerConnection()
    }
    await stream.getTracks().forEach(async track =&gt; {
        await peer.addTrack(track, stream); //将本地流附属至peer中
    });
    // await peer.addStream(stream); //旧方法（将本地流附属至peer中）
    peer.addEventListener('addstream', setVideo) //当peer收到其他流时显示另一个video以显示对方
    peer.addEventListener('icecandidate', sendIce) //获取到candidate时，将其发送至服务端，传至对方
    peer.addEventListener('negotiationneeded', sendOffer) //双方约定的协商被完成时才触发该方法
}

function setVideo(data) { //播放对方的视频流
    console.log(data.stream)
    let back = document.getElementById('back')
    back.hidden = false //显示挂断按钮
    back.addEventListener('click', breakVideoConnect) //挂断事件
    isCalling = true //正在通话
    let video = document.querySelector('#otherVideo');
    video.srcObject = data.stream;
    video.onloadedmetadata = function (e) {
        video.play();
    };
}

async function sendOffer() { //同步发送offer到服务端，发送给对方
    let offer = await peer.createOffer();
    await peer.setLocalDescription(offer); //peer本地附属offer
    socket.emit('_offer', {
        streamData: offer
    });
}

async function getOffer(data) { //接收到offer后，返回answer给对方
    if (!peer) return //等待对方响应，也可以用try catch
    await peer.setRemoteDescription(data.streamData); //peer远程附属offer
    sendAnswer()
}

async function sendAnswer() {
    let answer = await peer.createAnswer();
    await peer.setLocalDescription(answer); //peer附属本地answer
    socket.emit('_answer', {
        streamData: answer
    });
}

async function getAnswer(data) { //接收到answer后，peer远程附属answer
    await peer.setRemoteDescription(data.streamData);
}

function sendIce(e) { //setLocalDescription触发时，发送ICE给对方
    if (!e || !e.candidate) return
    socket.emit('_ice', {
        streamData: e.candidate
    });
}

async function getIce(data) { //获取对方的ICE
    if (!peer) return //等待对方响应，也可以用try catch
    var candidate = new RTCIceCandidate(data.streamData)
    await peer.addIceCandidate(candidate)
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h2 id="%E6%9C%8D%E5%8A%A1%E7%AB%AF"><strong>服务端</strong></h2>

<p>后端部分同样使用socketio进行通信<br>
首先在npm初始化后下载express，socket.io<br>
&nbsp;</p>

<pre><code>npm i express --save-dev
npm i socket.io --save-dev</code></pre>

<p>之后引入至server.js中</p>

<pre><code class="language-javascript">const express = require('express')
const app = express();
const server = require('http').Server(app);
const io = require('socket.io')(server);</code></pre>

<p>并监听1024端口</p>

<pre><code class="language-javascript">server.listen(1024, function () {
    console.log('Socket Open')
});</code></pre>

<p><strong>配置socket</strong><br>
给socket添加一些事件</p>

<pre><code class="language-javascript">io.on('connect', socket =&gt; {
    let {
        token
    } = socket.handshake.query
    socket.on('disconnect', (exit) =&gt; { //socket断开
        delFormList(token) //清除用户
        broadCast(socket, token, 'leave') //广播给其他用户
    })
});</code></pre>

<p>这样，我们最简单的一个socket就搭好了</p>

<h3 id="%E5%AE%8C%E6%95%B4%E7%9A%84server.js">完整的server.js</h3>

<pre><code class="language-javascript">const express = require('express')
const app = express();
const server = require('http').Server(app);
const io = require('socket.io')(server);
let userList = {} //用户列表，所有连接的用户
let userIds = {} //用户id列表，显示到前端
let roomList = {} //房间列表，视频聊天
io.on('connect', socket =&gt; {
    let {
        token
    } = socket.handshake.query
    socket.on('disconnect', (exit) =&gt; { //socket断开
        delFormList(token) //清除用户
        broadCast(socket, token, 'leave') //广播给其他用户
    })
    socket.on('inviteVideo', inviteVideoHandler) //邀请用户
    socket.on('askVideo', inviteVideoHandler); //回应用户是否邀请成功
    if (userList[token]) { //找到相同用户名就跳出函数
        socket.emit('open', {
            result: 0,
            msg: token + '已存在'
        });
        socket.disconnect()
        return;
    }
    addToList(token, socket) //用户连接时，添加到userList
    broadCast(socket, token, 'enter') //广告其他用户，有人加入
});

function addToList(key, item) { //添加到userList
    item.emit('open', {
        result: 1,
        msg: '你已加入聊天',
        userIds,
        token: key
    });
    userList[key] = item
    userIds[key] = key
}

function delFormList(key) { //断开时，删除用户
    delete userList[key];
    delete userIds[key]
}

function broadCast(target, token, type) { //广播功能
    let msg = '加入聊天'
    if (type !== 'enter') {
        msg = '离开聊天'
    }
    target.broadcast.emit('dataChange', {
        result: 1,
        msg: token + msg,
        userIds
    });
}

function inviteVideoHandler(data) { //邀请方法
    let {
        myId,
        otherId,
        type,
        allow
    } = data, msg = '邀请你进入聊天室', event = 'inviteVideoHandler', roomNo = otherId //默认房间号为邀请方id
    if (type == 'askVideo') {
        event = 'askVideoHandler'
        if (allow == 1) {
            addRoom(myId, otherId)
            roomNo = myId //保存房间号
            msg = '接受了你的邀请'
        } else if (allow == -1) {
            msg = '正在通话'
        } else {
            msg = '拒绝了你的邀请'
        }
    }
    userList[otherId].emit(event, {
        msg: myId + msg,
        token: myId,
        allow,
        roomNo
    });
}

async function addRoom(myId, otherId) { //用户同意后添加到视频聊天室，只做1对1聊天功能
    roomList[myId] = [userList[myId], userList[otherId]]
    startVideoChat(roomList[myId])
}

function startVideoChat(roomItem) { //视频聊天初始化
    for (let i = 0; i &lt; roomItem.length; i++) {
        roomItem[i].room = roomItem
        roomItem[i].id = i
        roomItem[i].on('_ice', _iceHandler)
        roomItem[i].on('_offer', _offerHandler)
        roomItem[i].on('_answer', _answerHandler)
        roomItem[i].on('_break', _breakRoom)

    }
}

function _iceHandler(data) { //用户发送ice到服务端，服务端转发给另一个用户
    let id = this.id == 0 ? 1 : 0 //判断用户二者其一
    this.room[id].emit('ice', data);
}

function _offerHandler(data) { //用户发送offer到服务端，服务端转发给另一个用户
    let id = this.id == 0 ? 1 : 0
    this.room[id].emit('offer', data);
}

function _answerHandler(data) { //用户发送answer到服务端，服务端转发给另一个用户
    let id = this.id == 0 ? 1 : 0
    this.room[id].emit('answer', data);
}

function _breakRoom(data) { //挂断聊天
    for (let i = 0; i &lt; roomList[data.roomNo].length || 0; i++) {
        roomList[data.roomNo][i].emit('break', {
            msg: '聊天挂断'
        });
    }
}
server.listen(1024, function () {
    console.log('Socket Open')
});</code></pre>

<h3 id="%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C">实现效果</h3>

<p>分别在我方发送stream之前打印stream，收到对方stream后打印stream，我们会发现，双方的stream互换了位置，也就是说整个媒体对象进行了交换</p>

<p><img alt="" height="405" src="https://img-blog.csdnimg.cn/20200312095925878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="393"><img alt="" height="416" src="https://img-blog.csdnimg.cn/20200312095925915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="420"></p>

<p>和同事在两台电脑上测试效果&nbsp;</p>

<p>&nbsp;<img alt="" height="229" src="https://img-blog.csdnimg.cn/2020031210313496.gif" width="427"></p>

<h3 id="%E6%B3%A8%E6%84%8F%EF%BC%9A">注意：</h3>

<p>前端项目必须运行在本地或者https服务下，因为navigator.mediaDevices.getUserMedia需要运行在安全模式下，用户第一次使用需要授权摄像头或音频权限，所以双方电脑需要有相关功能</p>

<p>看到这里，希望留下你宝贵的建议</p>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>分享些自己收藏的书签，基础占多，大牛勿入</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/08/12482605.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 08 Mar 2020 09:50:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/08/12482605.html</guid><description><![CDATA[<p>入坑前端3年，收藏了一些用得到或者可能会用到的书签</p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B1%BB" rel="nofollow">基础知识类</a></p>
<p id="%E8%A7%86%E9%A2%91%E6%95%99%E5%AD%A6%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E8%A7%86%E9%A2%91%E6%95%99%E5%AD%A6%E7%B1%BB" rel="nofollow">视频教学类</a></p>
<p id="%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%B1%BB" rel="nofollow">框架文档类</a></p>
<p id="UI%E7%BB%84%E4%BB%B6%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#UI%E7%BB%84%E4%BB%B6%E7%B1%BB" rel="nofollow">UI组件类</a></p>
<p id="%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95%E7%B1%BB" rel="nofollow">求职面试类</a></p>
<p id="%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5%E7%B1%BB" rel="nofollow">案例实践类</a></p>
<p id="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%B1%BB" rel="nofollow">博客文章类</a></p>
<p id="%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6%E7%B1%BB-toc" style="margin-left: 80px;"><a href="#%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6%E7%B1%BB" rel="nofollow">工具插件类</a></p>
<hr id="hr-toc" />
<h3 id="%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B1%BB">基础知识类</h3>
<p><a href="http://www.runoob.com/" rel="nofollow">菜鸟教程 - 学的不仅是技术，更是梦想！</a>（教学齐全，陪伴三年之余，几乎啥都有）<br />
http://www.runoob.com/</p>
<p><a href="http://www.w3school.com.cn/index.html" rel="nofollow">w3school 在线教程</a>（前端官方文档，不解释）<br />
http://www.w3school.com.cn/index.html</p>
<p><a href="https://www.bookstack.cn/" rel="nofollow">书栈网 &middot; BookStack_程序员IT互联网开源编程书籍免费阅读与下载，取之于猿用之于猿！</a>（非常不错的书籍分享网站，集结了很多编程必备书籍）<br />
https://www.bookstack.cn/</p>
<p><a href="https://www.w3cschool.cn/" rel="nofollow">w3cschool - 学编程，从w3cschool开始</a>（w3c官方推荐的教学网站）<br />
https://www.w3cschool.cn/</p>
<h3 id="%E8%A7%86%E9%A2%91%E6%95%99%E5%AD%A6%E7%B1%BB">视频教学类</h3>
<p><a href="http://www.fenby.com/" rel="nofollow">Fenby | 专业面向初学者的在线互动编程学习的平台</a>（用过几次，也是网上在线书籍观看）</p>
<p>http://www.fenby.com/</p>
<p><a href="https://www.shiyanlou.com/" rel="nofollow">实验楼 - 在线做实验，高效学编程</a>（推荐！！可以在页面上写代码，运行）<br />
https://www.shiyanlou.com/</p>
<p><a href="https://mooc.guokr.com/" rel="nofollow">MOOC学院（慕课）| 发现全球在线好课</a>（在线视频教学）<br />
https://mooc.guokr.com/</p>
<p><a href="https://study.163.com/" rel="nofollow">网易云课堂 - 我的职业课堂</a>（同上）<br />
https://study.163.com/</p>
<p><a href="https://devopen.club/" rel="nofollow">DevOpen.Club | 高质量的软件开发视频教程</a>（听同事说挺好用的，也是在线教学）<br />
https://devopen.club/</p>
<p><a href="https://www.jikexueyuan.com/" rel="nofollow">极客学院IT在线教育平台-中国专业的IT职业在线教育平台</a><br />
https://www.jikexueyuan.com/</p>
<h3 id="%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%B1%BB">框架文档类</h3>
<p><a href="https://www.html.cn/nav/" rel="nofollow">前端文档工具收藏夹 - 前端开发资源导航，前端工程师专用的导航站</a>（几乎涵盖了下面大部分文档）<br />
https://www.html.cn/nav/</p>
<p><a href="http://huziketang.mangojuice.top/books/react/" rel="nofollow">React.js 小书</a>（react进阶教程）</p>
<p>http://huziketang.mangojuice.top/books/react/</p>
<p><a href="https://cn.vuejs.org/v2/api/#optionMergeStrategies" rel="nofollow">API &mdash; Vue.js</a>（vue官方文档）<br />
https://cn.vuejs.org/v2/api/#optionMergeStrategies</p>
<p><a href="http://jquery.cuishifeng.cn/index.html" rel="nofollow">jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm</a>（Jq官方文档）<br />
http://jquery.cuishifeng.cn/index.html</p>
<p><a href="http://nodejs.cn/api/" rel="nofollow">API 文档 | Node.js 中文网</a>（nodejs官方）<br />
http://nodejs.cn/api/</p>
<p><a href="https://www.redux.org.cn/" rel="nofollow">自述 &middot; Redux</a>（react脚手架，搭建react项目）<br />
https://www.redux.org.cn/</p>
<p><a href="https://vuex.vuejs.org/zh/guide/" rel="nofollow">开始 | Vuex</a>（vue脚手架）<br />
https://vuex.vuejs.org/zh/guide/</p>
<p><a href="https://router.vuejs.org/zh/" rel="nofollow">介绍 | Vue Router</a>（vue路由文档）<br />
https://router.vuejs.org/zh/</p>
<p><a href="http://www.bootcss.com/" rel="nofollow">Bootstrap中文网</a>（官方文档）<br />
http://www.bootcss.com/</p>
<p><a href="https://developer.android.com/reference/classes" rel="nofollow">Class Index &nbsp;|&nbsp; Android 开发者 &nbsp;|&nbsp; Android Developers</a>（安卓原生文档）<br />
https://developer.android.com/reference/classes</p>
<p><a href="https://eggjs.org/" rel="nofollow">egg - Born to build better enterprise frameworks and apps</a>（基于nodejs的一个框架）<br />
https://eggjs.org/</p>
<p><a href="https://koa.bootcss.com/#" rel="nofollow">Koa (koajs) -- 基于 Node.js 平台的下一代 web 开发框架 | Koajs 中文文档</a>（如标题）<br />
https://koa.bootcss.com/#</p>
<p><a href="https://nestjs.com/" rel="nofollow">NestJS - A progressive Node.js framework</a>（nodejs框架，有时候会有点卡）<br />
https://nestjs.com/</p>
<p><a href="https://electronjs.org/" rel="nofollow">Electron | 使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用。</a>（这个挺有意思的，用前端编写桌面级应用，国内可能会访问不了）<br />
https://electronjs.org/</p>
<p><a href="http://ask.dcloud.net.cn/docs/" rel="nofollow">文档 - DCloud问答</a>（dcloud官方文档，h5+，uni-app等等）<br />
http://ask.dcloud.net.cn/docs/</p>
<p><a href="http://docs.jiguang.cn/jpush/guideline/intro/" rel="nofollow">极光推送 - JPush 产品简介 - 极光文档</a>（使用此产品搭建内网穿透，外部访问本地服务器）<br />
http://docs.jiguang.cn/jpush/guideline/intro/</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/index.html?t=19010816" rel="nofollow">简易教程 &middot; 小程序</a>（小程序官方文档）<br />
https://developers.weixin.qq.com/miniprogram/dev/index.html?t=19010816</p>
<p><a href="https://react-bootstrap.github.io/" rel="nofollow">https://react-bootstrap.github.io</a>（一个基于react和bootstrap的插件，国内访问不了）<br />
https://react-bootstrap.github.io/</p>
<p><a href="http://www.expressjs.com.cn/" rel="nofollow">Express - 基于 Node.js 平台的 web 应用开发框架 | Express 中文文档</a>（nodejs框架）<br />
http://www.expressjs.com.cn/</p>
<p><a href="https://www.mongodb.com/download-center/community" rel="nofollow">MongoDB下载中心| MongoDB</a>（MongoDB数据库官方文档）<br />
https://www.mongodb.com/download-center/community</p>
<p><a href="https://mongoosejs.com/" rel="nofollow">Mongoose ODM v5.3.14</a>（mongoDB框架官方文档）<br />
https://mongoosejs.com/</p>
<p><a href="https://www.sass.hk/guide/" rel="nofollow">Sass基础教程 Sass快速入门 Sass中文手册 | Sass中文网</a>（预处理语言）<br />
https://www.sass.hk/guide/</p>
<p><a href="https://angularjs.org/" rel="nofollow">AngularJS &mdash; Superheroic JavaScript MVW Framework</a>（AngluarJS官网文档）<br />
https://angularjs.org/</p>
<p><a href="https://www.readwithu.com/" rel="nofollow">知识点补漏 &middot; 草根学Python</a>（Python）<br />
https://www.readwithu.com/</p>
<p><a href="https://www.bootcss.com/p/lesscss/" rel="nofollow">LESS &laquo; 一种动态样式语言</a>（预处理语言less）</p>
<h3 id="UI%E7%BB%84%E4%BB%B6%E7%B1%BB">UI组件类</h3>
<p><a href="http://element-cn.eleme.io/#/zh-CN/guide/design" rel="nofollow">指南 | Element</a></p>
<p>http://element-cn.eleme.io/#/zh-CN/guide/design</p>
<p><a href="http://mint-ui.github.io/#!/zh-cn" rel="nofollow">Mint UI</a>（国内可能会慢）<br />
http://mint-ui.github.io/#!/zh-cn</p>
<p><a href="https://www.layui.com/" rel="nofollow">layui - 经典模块化前端UI框架</a><br />
https://www.layui.com/</p>
<p><a href="https://fly.layui.com/extend/" rel="nofollow">layui 第三方组件平台</a><br />
https://fly.layui.com/extend/</p>
<p><a href="http://www.h-ui.net/index.shtml" rel="nofollow">H-ui前端框架官方网站 - 专注前端解决方案</a><br />
http://www.h-ui.net/index.shtml</p>
<p><a href="https://youzan.github.io/vant-weapp/#/icon" rel="nofollow">Vant Weapp - 轻量、可靠的小程序 UI 组件库</a>（小程序和vue效果不错）<br />
https://youzan.github.io/vant-weapp/#/icon</p>
<p><a href="http://dev.dcloud.net.cn/mui/" rel="nofollow">MUI-最接近原生APP体验的高性能前端框架</a>（h5+打包app，或混合开发）<br />
http://dev.dcloud.net.cn/mui/</p>
<p><a href="https://ant.design/index-cn" rel="nofollow">Ant Design - 一个 UI 设计语言</a>（蚂蚁金服的UI，适合react）<br />
https://ant.design/index-cn</p>
<p><a href="http://amazeui.org/react/" rel="nofollow">Amaze UI React - Amaze UI components build with React</a>（妹子UI，官网好像进不去了）<br />
http://amazeui.org/react/</p>
<p><a href="https://www.iviewui.com/overview/" rel="nofollow">概览 - iView</a><br />
https://www.iviewui.com/overview/</p>
<p><a href="https://vux.li/" rel="nofollow">VUX - Vue 移动端 UI 组件库</a><br />
https://vux.li/</p>
<p><a href="https://vuetifyjs.com/zh-Hans/" rel="nofollow">Vue.js Material Component Framework &mdash; Vuetify.js</a><br />
https://vuetifyjs.com/zh-Hans/</p>
<p><a href="http://cn.inspinia.cn/" rel="nofollow">bootstrap后端模板_bootstrap模板 inspinia中文 | 主页| inspinia admin中文_inspinia admin 下载_inspinia admin_inspinia admin 最新版_inspinia admin v2.7_inspinia admin 2.8_inspinia admin theme_inspinia bootstrap</a>（适合做管理界面）<br />
http://cn.inspinia.cn/</p>
<p><a href="https://youzan.github.io/zanui-weapp/#/zanui/base/icon" rel="nofollow">ZanUI 小程序</a><br />
https://youzan.github.io/zanui-weapp/#/zanui/base/icon</p>
<p><a href="https://flutterchina.club/" rel="nofollow">Flutter中文网</a><br />
https://flutterchina.club/</p>
<h3 id="%E6%B1%82%E8%81%8C%E9%9D%A2%E8%AF%95%E7%B1%BB">求职面试类</h3>
<p><a href="https://www.nowcoder.com/" rel="nofollow">牛客网- 互联网求职神器和备考学习平台</a>（刷题必备）</p>
<p>https://leetcode-cn.com/</p>
<p><a href="https://leetcode-cn.com/" rel="nofollow">力扣 (LeetCode) - 极客挚爱的在线技术平台</a>（刷题必备）<br />
https://www.nowcoder.com/</p>
<h3 id="%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5%E7%B1%BB">案例实践类</h3>
<p><a href="http://www.youzhan.org/" rel="nofollow">Bootstrap 优站精选</a></p>
<p>http://www.youzhan.org/</p>
<p><a href="http://www.fgm.cc/learn/" rel="nofollow">实例索引</a><br />
http://www.fgm.cc/learn/</p>
<p><a href="https://www.html5tricks.com/" rel="nofollow">HTML5资源教程 | 分享HTML5开发资源和开发教程</a><br />
https://www.html5tricks.com/</p>
<p><a href="http://www.dcloud.io/case/#group-1" rel="nofollow">案例</a>（h5app案例）<br />
http://www.dcloud.io/case/#group-1</p>
<p><a href="https://www.ui.cn/" rel="nofollow">UI中国用户体验设计平台</a>（各种UI效果）<br />
https://www.ui.cn/</p>
<p><a href="http://www.17sucai.com/pins/tag/3886.html" rel="nofollow">canvas特效代码_canvas效果代码_canvas网页代码</a>（用过一次，有些要积分）<br />
http://www.17sucai.com/pins/tag/3886.html</p>
<h3 id="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%B1%BB">博客文章类</h3>
<p><a href="https://www.v2ex.com/" rel="nofollow">V2EX</a>（不错的论坛）</p>
<p>https://www.v2ex.com/</p>
<p><a href="https://www.csdn.net/">CSDN-专业IT技术社区</a><br />
https://www.csdn.net/</p>
<p><a href="https://segmentfault.com/channel/frontend" rel="nofollow">前端 - SegmentFault 思否</a><br />
https://segmentfault.com/channel/frontend</p>
<p><a href="https://www.oschina.net/question/tag/github" rel="nofollow">GitHub - 开源中国社区</a><br />
https://www.oschina.net/question/tag/github</p>
<p><a href="https://www.zhihu.com/" rel="nofollow">首页 - 知乎</a><br />
https://www.zhihu.com/</p>
<p><a href="https://juejin.im/timeline" rel="nofollow">掘金</a><br />
https://juejin.im/timeline</p>
<p><a href="https://www.cnblogs.com/" rel="nofollow">博客园 - 代码改变世界</a><br />
https://www.cnblogs.com/</p>
<p><a href="https://www.jianshu.com/" rel="nofollow">简书 - 创作你的创作</a><br />
https://www.jianshu.com/</p>
<p><a href="https://gitee.com/" rel="nofollow">码云 Gitee &mdash; 开源中国 Git 代码托管平台</a>（项目开源必备，中国的GitHub）<br />
https://gitee.com/</p>
<p><a href="https://github.com/">GitHub</a><br />
https://github.com/</p>
<p><a href="http://www.see-source.com/" rel="nofollow">看源社区 - 移动开发社区</a><br />
http://www.see-source.com/</p>
<p><a href="http://react-china.org/" rel="nofollow">React 中文</a><br />
http://react-china.org/</p>
<h3 id="%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6%E7%B1%BB">工具插件类</h3>
<p><a href="https://www.echartsjs.com/zh/index.html" rel="nofollow">Apache ECharts (incubating)</a>（制作图表，效果图利器）</p>
<p>https://www.echartsjs.com/zh/index.html</p>
<p><a href="https://www.highcharts.com.cn/" rel="nofollow">兼容 IE6+、完美支持移动端、图表类型丰富的 HTML5 交互图表 | Highcharts</a>（同上）<br />
https://www.highcharts.com.cn/</p>
<p><a href="https://chartjs.bootcss.com/" rel="nofollow">Chart.js | 开源的 HTML5 图表工具</a><br />
https://chartjs.bootcss.com/</p>
<p><a href="https://www.yuque.com/antv" rel="nofollow">AntV &middot; 语雀</a>（Antv官方论坛）</p>
<p>https://www.yuque.com/antv</p>
<p><a href="https://antv-f2.gitee.io/zh" rel="nofollow">蚂蚁数据可视化 | F2</a>（挺好用的，画面相对前几者更简约）<br />
https://antv-f2.gitee.io/zh</p>
<p><a href="http://www.animate.net.cn/" rel="nofollow">Animate中文网 &ndash; Animate安装、Animate使用、Animate下载</a>（css动画插件）<br />
http://www.animate.net.cn/</p>
<p><a href="http://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.4&amp;type=1" rel="nofollow">Iconfont-阿里巴巴矢量图标库</a><br />
http://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.4&amp;type=1</p>
<p><a href="http://koala-app.com/index-zh.html" rel="nofollow">Koala - LESS/Sass/Compass/CoffeeScript编译工具</a><br />
http://koala-app.com/index-zh.html</p>
<p><a href="https://www.swiper.com.cn/" rel="nofollow">Swiper中文网</a>（轮播图）<br />
https://www.swiper.com.cn/</p>
<p><a href="http://www.jq22.com/" rel="nofollow">jQuery插件库-收集最全最新最好的jQuery插件</a>（强列推荐）<br />
http://www.jq22.com/</p>
<p><a href="http://www.gif5.net/" rel="nofollow">GIF5官网-gif在线制作_gif制作软件_搞笑gif动态图片制作</a>（将录屏转换为gif）<br />
http://www.gif5.net/</p>
<p><a href="https://npm.taobao.org/mirrors/git-for-windows/" rel="nofollow">git-for-windows Mirror</a>（国内版git下载，官网太慢了）<br />
https://npm.taobao.org/mirrors/git-for-windows/</p>
<p><a href="https://gitee.com/zha2/easy-window" rel="nofollow">easy-window: HTML5桌面应用程序开发通用工具</a><br />
https://gitee.com/zha2/easy-window</p>
<p><a href="http://www.jeasyui.net/plugins/180.html" rel="nofollow">Easyui Window 窗口_EasyUI 插件</a>（据说还不错）<br />
http://www.jeasyui.net/plugins/180.html</p>
<p><a href="http://www.jqueryfuns.com/resource/1749" rel="nofollow">Jalendar2 - jQuery日历日期插件包</a>（项目需要，所以收藏了）<br />
http://www.jqueryfuns.com/resource/1749</p>
<p><a href="http://www.bootstrapmb.com/tag/rili" rel="nofollow">js日历_jQuery日历插件</a>（同上）<br />
http://www.bootstrapmb.com/tag/rili</p>
<p><a href="http://weappsocket.matong.io/" rel="nofollow">weapp.socket.io</a>（微信小程序sock插件，不是官方的websocket）<br />
http://weappsocket.matong.io/</p>
<p><a href="http://www.jq22.com/jquery-info16236" rel="nofollow">前端人脸识别框架Tracking.js</a>（项目需要，所以收藏了）<br />
http://www.jq22.com/jquery-info16236</p>
<p><a href="https://xposed.appkg.com/" rel="nofollow">Xposed框架中文站 - 超多Xposed框架模块介绍与下载</a>（玩xp的应该知道）<br />
https://xposed.appkg.com/</p>
<p><a href="http://www.jq22.com/jquery-info7503" rel="nofollow">jquery人脸识别插件jquery.facedetection</a><br />
http://www.jq22.com/jquery-info7503</p>
<p><a href="http://www.fontawesome.com.cn/faicons/" rel="nofollow">图标库 &ndash; Font Awesome 中文网</a>（类似于阿里矢量图）<br />
http://www.fontawesome.com.cn/faicons/</p>
<p><a href="https://webkul.github.io/coolhue/" rel="nofollow">Gradient Colors Collection Palette - CoolHue 2.0</a>（生成好看的渐变色，国内可能打不开）<br />
https://webkul.github.io/coolhue/</p>
<p><a href="https://www.json.cn/" rel="nofollow">JSON在线解析及格式化验证 - JSON.cn</a><br />
https://www.json.cn/</p>
<p><a href="https://free.modao.cc/" rel="nofollow">墨刀 - 强大易用的原型设计与协同工具</a>（如题，确实强大帮助传统设计师省了很多事）<br />
https://free.modao.cc/</p>
<p><a href="https://cli.im/" rel="nofollow">草料二维码生成器</a><br />
https://cli.im/</p>
<p><a href="https://www.apicloud.com/" rel="nofollow">APICloud 手机APP开发、APP制作技术专家 - 中国领先移动云服务平台</a><br />
https://www.apicloud.com/</p>
<p><a href="https://natapp.cn/" rel="nofollow">NATAPP基于ngrok的国内高速内网穿透服务</a><br />
https://natapp.cn/</p>
<p><a href="https://www.easy-mock.com/login" rel="nofollow">简单的模拟</a>（挺好用的，以前经常用，可惜现在好像停了）<br />
https://www.easy-mock.com/login</p>
<p><a href="http://tool.oschina.net/regex/" rel="nofollow">在线正则表达式测试</a><br />
http://tool.oschina.net/regex/</p>
<p><a href="http://www.bejson.com/othertools/regex_create/" rel="nofollow">正则表达式代码生成工具-BeJSON.com</a><br />
http://www.bejson.com/othertools/regex_create/</p>
<p><a href="http://npm.taobao.org/" rel="nofollow">淘宝 NPM 镜像</a>（快速的npm）<br />
http://npm.taobao.org/</p>
<p><a href="https://tinypng.com/" rel="nofollow">TinyPNG &ndash; Compress PNG images while preserving transparency</a>（强烈推荐，图片压缩工具，节省资源，优化性能）<br />
https://tinypng.com/</p>
<p><a href="https://www.awesomes.cn/" rel="nofollow">Awesomes-Web前端开发资源库</a>（很多插件案例）<br />
https://www.awesomes.cn/</p>
<p><a href="https://www.tweenmax.com.cn/" rel="nofollow">TweenMax中文网</a>（元素运动框架/插件）<br />
https://www.tweenmax.com.cn/</p>
<p><a href="https://www.gruntjs.net/" rel="nofollow">Grunt: JavaScript 世界的构建工具 | Grunt 中文网</a>（构建前端项目）<br />
https://www.gruntjs.net/</p>
<p><a href="https://www.gulpjs.com.cn/" rel="nofollow">gulp.js - 基于流(stream)的自动化构建工具 | gulp.js 中文网</a>（如题）<br />
https://www.gulpjs.com.cn/</p>
<p><a href="https://www.babeljs.cn/" rel="nofollow">Babel 中文网 &middot; Babel - 下一代 JavaScript 语法的编译器</a>（es6转es5）<br />
https://www.babeljs.cn/</p>
<p><a href="https://yarnpkg.com/" rel="nofollow">Home | Yarn - Package Manager</a>（类似npm，下载工具）<br />
https://yarnpkg.com/</p>
<p><a href="http://mockjs.com/" rel="nofollow">Mock.js</a>（模拟服务端数据）<br />
http://mockjs.com/</p>
<p><a href="https://lodash.com/" rel="nofollow">Lodash</a>（<span style="color: #5f5f5f;">提供模块化，性能和附加功能</span>）<br />
https://lodash.com/</p>
<p><a href="https://www.bootcdn.cn/" rel="nofollow">BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务</a>（cdn托管，远程组件，库集群）<br />
https://www.bootcdn.cn/</p>
<p><a href="https://tower.im/users/sign_in" rel="nofollow">登录 - Tower</a>（开发协作工具）<br />
https://tower.im/users/sign_in</p>
<p><a href="https://www.postman.com/" rel="nofollow">Postman | The Collaboration Platform for API Development</a>（模拟请求数据，获取请求结果）<br />
https://www.postman.com/</p>
<p><a href="https://daneden.github.io/animate.css/" rel="nofollow">Animate.css</a>（css动画插件）<br />
https://daneden.github.io/animate.css/</p>
<p><a href="https://uigradients.com/#Cherryblossoms" rel="nofollow">uiGradients - Beautiful colored gradients</a>（好看的渐变色下载）<br />
https://uigradients.com/#Cherryblossoms</p>
<p>&nbsp;</p>]]></description></item><item><title>JS案例：用购物车理解前端MVC架构</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/05/12482604.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 05 Mar 2020 09:19:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/03/05/12482604.html</guid><description><![CDATA[
                                            <p id="main-toc"><strong>目录</strong></p>

<p id="%E4%BB%80%E4%B9%88%E6%98%AFMVC%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFMVC%EF%BC%9A" rel="nofollow">什么是MVC：</a></p>

<p id="MVC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#MVC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A" rel="nofollow">MVC的作用：</a></p>

<p id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MVC%E6%9E%B6%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MVC%E6%9E%B6%E6%9E%84%EF%BC%9A" rel="nofollow">如何使用MVC架构：</a></p>

<p id="%E6%95%88%E6%9E%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%95%88%E6%9E%9C%EF%BC%9A" rel="nofollow">效果：</a></p>

<p id="%E4%BB%A5%E4%B8%8B%E6%98%AF%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">以下是所有代码：</a></p>

<p id="%E5%90%8E%E7%AB%AF%EF%BC%88nodejs%EF%BC%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%90%8E%E7%AB%AF%EF%BC%88nodejs%EF%BC%89%EF%BC%9A" rel="nofollow">后端（nodejs）：</a></p>

<p id="server.js-toc" style="margin-left:40px;"><a href="#server.js" rel="nofollow">server.js</a></p>

<p id="data.js(%E5%AD%98%E6%94%BE%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8)-toc" style="margin-left:40px;"><a href="#data.js(%E5%AD%98%E6%94%BE%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8)" rel="nofollow">data.js(存放商品列表)</a></p>

<p id="%E5%89%8D%E7%AB%AF-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E7%AB%AF" rel="nofollow">前端</a></p>

<p id="shopCar.html%EF%BC%88%E5%85%A5%E5%8F%A3%E9%A1%B5%E9%9D%A2%EF%BC%89-toc" style="margin-left:80px;"><a href="#shopCar.html%EF%BC%88%E5%85%A5%E5%8F%A3%E9%A1%B5%E9%9D%A2%EF%BC%89" rel="nofollow">shopCar.html（入口页面）</a></p>

<p id="shop.css-toc" style="margin-left:80px;"><a href="#shop.css" rel="nofollow">shop.css</a></p>

<p id="JS%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#JS%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9A" rel="nofollow">JS文件夹：</a></p>

<p id="bussiness-toc" style="margin-left:80px;"><a href="#bussiness" rel="nofollow">bussiness</a></p>

<p id="command-toc" style="margin-left:80px;"><a href="#command" rel="nofollow">command</a></p>

<p id="components-toc" style="margin-left:80px;"><a href="#components" rel="nofollow">components</a></p>

<p id="config-toc" style="margin-left:80px;"><a href="#config" rel="nofollow">config</a></p>

<p id="controller-toc" style="margin-left:80px;"><a href="#controller" rel="nofollow">controller</a></p>

<p id="event-toc" style="margin-left:80px;"><a href="#event" rel="nofollow">event</a></p>

<p id="model-toc" style="margin-left:80px;"><a href="#model" rel="nofollow">model</a></p>

<p id="utils-toc" style="margin-left:80px;"><a href="#utils" rel="nofollow">utils</a></p>

<p id="view-toc" style="margin-left:80px;"><a href="#view" rel="nofollow">view</a></p>

<hr id="hr-toc"><h3 id="%E4%BB%80%E4%B9%88%E6%98%AFMVC%EF%BC%9A">什么是MVC：</h3>

<p>Model View Controller即：模型-视图-控制器<br>
通俗来讲，在编程语言中，Model就是数据，可以理解为数据库，View就是显示数据的外观，Controller是用来连接前两者的行为，常见的Vue采用的是M-V-VM架构，与MVC类似，但是基于MVC</p>

<h3 id="MVC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A">MVC的作用：</h3>

<p>说到作用，就不得不提面向对象与面向过程的区别了</p>

<p>面向过程就是，将解决问题的思路流程一步一步进行，紧扣在一起，最终达到结果</p>

<p>面向对象，是将某个问题的解决方式剥离开，其目的不是为了完成某个步骤，而是将某个事物（对象）的角色（属性）和行为（方法）作为核心</p>

<p>说了这些，到底MVC有什么好处呢？</p>

<p>举个栗子：A是某公司的一位前端程序员，平时用面向过程进行编程，这天，好不容易完成了手头上的活，准备回家，这时，产品经理走过来，让他改个小地方，这下就完了，面向过程的思维使他的代码环环相扣，代码耦合性强，内聚性高，密不可分，改一个地方就要几乎全改</p>

<p>A的哥哥也是一个前端程序员，平时用面向对象编程，产品经理让他改一个效果，由于用的面向对象，他的代码没有层次感，通用的方法全部提取出来，使得代码耦合性低，想改哪直接改相关的类或者方法就好了</p>

<p>当然，在小型项目中无法体现它的优点，甚至会小题大做，大材小用，而在大型项目中，其耦合性低，代码复用性高，搭建相对较快</p>

<h3 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MVC%E6%9E%B6%E6%9E%84%EF%BC%9A">如何使用MVC架构：</h3>

<p>又是这个购物车，业余时间用MVC做了一个简单的购物车：</p>

<p>目录结构大致是这样</p>

<p><img alt="" height="398" src="https://img-blog.csdnimg.cn/2020030516395041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="363"></p>

<p>购物车整体流程：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目录结构将model&nbsp;view&nbsp;controller剥离开</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modedl层：存储数据，显示数据</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View：根据Model数据渲染页面</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controller：传递数据</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Command:操作数据，获取数据</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event：事件总线，注册事件</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;商品列表：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化View层，建立Ajax获取数据，之后由controller触发事件至事件总线，然后再由注册的事件将ajax数据传至Model中完成商品列表初始化</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当model获取到商品列表数据时，通过代理set()&nbsp;&nbsp;触发新建商品列表事件，通过command操作view达到新建列表目的</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;购物车表格：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户对view进行操作时，触发注册的事件，通过command修改Model中的数据（购物车列表）从而再由command驱动view中的刷新表格进行渲染</p>

<h3 id="%E6%95%88%E6%9E%9C%EF%BC%9A">效果：</h3>

<p><img alt="" height="284" src="https://img-blog.csdnimg.cn/20200305170021983.gif" width="682"></p>

<h3 id="%E4%BB%A5%E4%B8%8B%E6%98%AF%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%9A">以下是所有代码：</h3>

<h1 id="%E5%90%8E%E7%AB%AF%EF%BC%88nodejs%EF%BC%89%EF%BC%9A">后端（nodejs）：</h1>

<h2 id="server.js">server.js</h2>

<pre><code class="language-javascript">/*
 *后端采用node+express搭建一个简单的接口，通过本地数据，将商品列表传至前端
 * 
 */
const express = require('express');
const path = require('path');
const app = express();
const shopData = require('./data/shopData.js')
let serverToken = 'hello'
app.all("*", function (req, res, next) { //跨域
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "content-type");
    res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS");
    next();
});
app.use('/getShopList', function (req, res) {
    let data = req.query
    if (!checkToken(data.token)) { //简单获取前端token，校验
        res.send({
            result: 0,
            msg: 'token fail'
        })
        return
    }
    res.send({
        result: 1,
        msg: 'success',
        type: 'getShopList',
        shopData
    })
})

function checkToken(teken) {
    return teken == serverToken
}
app.use('/img', express.static(path.join(__dirname, './img'))); //后端目录静态化，用url+img访问文件夹
app.use('/client', express.static(path.join(__dirname, '../client')));
app.listen(1024, "127.0.0.1", function () {
    console.log("服务开启，开始侦听");
});</code></pre>

<h2 id="data.js(%E5%AD%98%E6%94%BE%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8)">data.js(存放商品列表)</h2>

<pre><code class="language-javascript">module.exports = [{
        "select": false,
        "id": 1001,
        "icon": "img/1.png",
        "name": "餐饮0",
        "num": 0,
        "price": 10,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1002,
        "icon": "img/2.png",
        "name": "餐饮1",
        "num": 0,
        "price": 20,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1003,
        "icon": "img/3.png",
        "name": "餐饮2",
        "num": 0,
        "price": 30,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1004,
        "icon": "img/4.png",
        "name": "餐饮3",
        "num": 0,
        "price": 40,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1005,
        "icon": "img/5.png",
        "name": "餐饮4",
        "num": 0,
        "price": 50,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1006,
        "icon": "img/6.png",
        "name": "餐饮5",
        "num": 0,
        "price": 60,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1007,
        "icon": "img/7.png",
        "name": "餐饮6",
        "num": 0,
        "price": 70,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1008,
        "icon": "img/8.png",
        "name": "餐饮7",
        "num": 0,
        "price": 80,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1009,
        "icon": "img/9.png",
        "name": "餐饮8",
        "num": 0,
        "price": 90,
        "sum": 0,
        "delete": false
    },
    {
        "select": false,
        "id": 1010,
        "icon": "img/10.png",
        "name": "餐饮9",
        "num": 0,
        "price": 100,
        "sum": 0,
        "delete": false
    }
]</code></pre>

<h1 id="%E5%89%8D%E7%AB%AF">前端</h1>

<h3 id="shopCar.html%EF%BC%88%E5%85%A5%E5%8F%A3%E9%A1%B5%E9%9D%A2%EF%BC%89">shopCar.html（入口页面）</h3>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
	&lt;title&gt;shopCar&lt;/title&gt;
	&lt;link rel="stylesheet" href="./src/style/shop.css"&gt;
&lt;/head&gt;

&lt;body&gt;
	&lt;script type="module"&gt;
		/*
		购物车整体流程：
		目录结构将model view controller剥离开
		Modedl层：存储数据，显示数据
		View：根据Model数据渲染页面
		Controller：传递数据
		Command:操作数据，获取数据
		Event：事件总线，注册事件
		商品列表：
		 	初始化View层，建立Ajax获取数据，之后由controller触发事件至事件总线，然后再由注册的事件将ajax数据传至Model中完成商品列表初始化
		 	当model获取到商品列表数据时，通过代理set()  触发新建商品列表事件，通过command操作view达到新建列表目的
		购物车表格：
		 	当用户对view进行操作时，触发注册的事件，通过command修改Model中的数据（购物车列表）从而再由command驱动view中的刷新表格进行渲染
		*/
		import ShopView from './src/js/view/ShopView.js'
		// 实例化View层入口函数
		new ShopView()
	&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<h3 id="shop.css">shop.css</h3>

<pre><code class="language-css">* {
    margin: 0;
    padding: 0;
}

.shopBox {
    overflow: hidden;
    width: 1000px;
    margin: 50px auto 0;
}

.liItem {
    float: left;
    list-style: none;
    padding: 10px;
    width: 150px;
    height: 200px;
    text-align: center;
    border: 1px solid lightcoral;
}

.liItem img {
    width: 100px;
    height: 100px;
}

.leftBtn,
.rightBtn {
    width: 30px;
    height: 30px;
    background: white;
    border: 1px solid black;
    font-size: 25px;
    line-height: 30px;
}

.text {
    width: 50px;
    height: 26px;
    display: inline-block;
    vertical-align: bottom;
    text-align: center;
}

table {
    font-size: 30px;
    width: 1200px;
    border: 1px solid lightcoral;
    border-collapse: collapse;
    margin: 50px auto;
}

.checkbox {
    width: 30px;
    height: 30px;
}

td {
    border: 1px solid lightcoral;
    text-align: center;
    vertical-align: middle;
}

td button {
    width: 150px;
    height: 60px;
}

.numBox {
    width: 150px;
    height: 30px;
    margin: auto;
    position: relative;
}

.numBox&gt;button {
    width: 40px;
    height: 42px;
    background-color: white;
    border: 1px solid #000000;
}

.numBox&gt;input {
    width: 70px;
    height: 40px;
    border: 1px solid #000000;
    border-left: none;
    border-right: none;
    text-align: center;
}</code></pre>

<h2 id="JS%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9A">JS文件夹：</h2>

<h3 id="bussiness">bussiness</h3>

<ul><li>Ajax.js
	<pre><code class="language-javascript">import ShopEvent from '../event/ShopEvent.js'
import Utils from '../utils/Utils.js'
import Api from '../config/Api.js'
import ShopController from '../controller/ShopController.js'
export default class Ajax {//Ajax类，用于请求后端或本地数据
    // Ajax请求函数
    static AjaxTool(method = Api.GET, url, data) {
        let xhr;
        if (window.ActiveXObject) { //ie浏览器
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        } else if (window.XMLHttpRequest) { //其他浏览器
            xhr = new XMLHttpRequest();
        }
        url = Api.URL + Api.PORT + Api.PATH + url
        if (method !== Api.POST) {
            method = Api.GET
            url = Utils.urlJoin(url, data)
            data = null
        } else {
            method = Api.POST
        }
        xhr.open(method, url);
        xhr.send(data ? JSON.stringify(data) : '')
        xhr.addEventListener('load', Ajax.loadHandler) //Ajax类是静态类，无法使用this
    }
    static loadHandler(e) {
        //this指向xhr
        let xhr = e.currentTarget;
        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            Ajax.data = xhr.response
        } else {
            Ajax.data = 'error'
        }

    }
    static set data(value) { //使用set对象代理模式替代请求数据回调函数（只写set表示data只可写入，不可读取）
        let res = JSON.parse(value)
        switch (res.result) {
            case 1:
                console.log(res.msg)
                ShopController.dispatch(ShopEvent.GET_DATA, res)//获取到数据后不做其他操作，将数据通过事件抛出至Event总线中
                break;
            case 0:
                console.log('加载失败')
                console.log(res.msg)
                break;
            default:
                break;
        }
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="command">command</h3>

<ul><li>MainCommand（command汇总）
	<pre><code class="language-javascript">import GetDataCommand from '../command/GetDataCommand.js'
import CreateListCommand from '../command/CreateListCommand.js'
import CreateTableCommand from '../command/CreateTableCommand.js'
import AddItemCommand from '../command/AddItemCommand.js'
import DelItemCommand from '../command/DelItemCommand.js'
import ReduceItemCommand from '../command/ReduceItemCommand.js'
import ChangeItemCommand from '../command/ChangeItemCommand.js'
import SelectItemCommand from '../command/SelectItemCommand.js'
export default {
    GetDataCommand,
    CreateListCommand,
    CreateTableCommand,
    AddItemCommand,
    DelItemCommand,
    ReduceItemCommand,
    ChangeItemCommand,
    SelectItemCommand
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>GetDataCommand（获取商品列表）
	<pre><code class="language-javascript">import ShopModel from '../model/ShopModel.js'
export default class GetDataCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() {

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        ShopModel.getInstance().shopList = data.shopData//将ajax获取的数据发送到Model
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>CreateListCommand（创建商品列表）
	<pre><code class="language-javascript">import CreateList from '../view/CreateList.js'
export default class CreateListCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() {//创建商品列表

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        for (let i = 0; i &lt; data.length; i++) {
            let createList = new CreateList(document.body)
            createList.shopList = data[i]
        }
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>CreateTableCommand（创建购物车表格）
	<pre><code class="language-javascript">import CreateTable from '../view/CreateTable.js'
export default class ShopCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() {//刷新购物车表格

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        let createTable = new CreateTable(document.body)
        createTable.shoppingList = data
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>AddItemCommand（增加商品）
	<pre><code class="language-javascript">import ShopModel from '../model/ShopModel.js'
export default class AddItemCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() { //新增商品

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        AddItemCommand.addItem(ShopModel.getInstance().shoppingList, data)
    }
    static addItem(list, data) { //遍历查询某项商品增加或减少
        let arr = list.filter(function (item) {
            return item.id === data.id;
        }); //若有返回值则对某项商品操作（在1-99区间，若为0则直接删除）
        if (arr.length == 0) {
            data.num++;
            data.sum = data.num * data.price;
            list.push(data);
        } else if (arr[0].num &lt; 99) {
            arr[0].num++;
            arr[0].sum = arr[0].num * arr[0].price;
        }
        ShopModel.getInstance().shoppingList = list
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>ReduceItemCommand（减少商品）
	<pre><code class="language-javascript">import ShopModel from '../model/ShopModel.js'
export default class ReduceItemCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() { //减少商品

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        ReduceItemCommand.reduceItem(ShopModel.getInstance().shoppingList, data)
    }
    static reduceItem(list, data) { //遍历查询某项商品增加或减少
        let arr = list.filter(function (item) {
            return item.id === data.id;
        }); //若有返回值则对某项商品操作（在1-99区间，若为0则直接删除）
        if (arr[0].num &gt; 1) {
            arr[0].num--;
            arr[0].sum = arr[0].num * arr[0].price;
        } else {
            data.num = 0; //此处初始化model中的shopList，否则会假删除（删除栈中的数量）
            list = list.filter(function (item) {
                return item.id !== data.id;
            });
        }
        ShopModel.getInstance().shoppingList = list
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>ChangeItemCommand（修改商品数量）
	<pre><code class="language-javascript">import ShopModel from '../model/ShopModel.js'
export default class ChangeItemCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() { //修改商品数量

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        ChangeItemCommand.changeItem(ShopModel.getInstance().shoppingList, data)
    }
    static changeItem(list, data) {
        let arr = list.filter(function (item) {
            return item.id === data.id;
        });
        arr[0].sum = arr[0].num * arr[0].price;
        ShopModel.getInstance().shoppingList = list
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>DelItemCommand（删除商品）
	<pre><code class="language-javascript">import ShopModel from '../model/ShopModel.js'
export default class DelItemCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() { //删除商品

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        DelItemCommand.delItem(ShopModel.getInstance().shoppingList, data)
    }
    static delItem(list, data) { //遍历查询某项商品增加或减少
        data.num = 0; //此处初始化model中的shopList，否则会假删除（删除栈中的数量）
        data.select = false; //此处初始化model中的shopList，否则会假删除（删除栈中的数量）
        ShopModel.getInstance().shoppingList = list.filter(function (item) { //数组过滤函数，返回id属性不等于当前id的数组，即删除当前选中的对象，并重新赋值
            return item.id !== data.id;
        });
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>SelectItemCommand（选中商品）
	<pre><code class="language-javascript">import ShopModel from '../model/ShopModel.js'
export default class SelectItemCommand { //行为类，用于执行ctrl层通过事件的方式发来的指令
    constructor() {

    }
    eventHandler(e) { //使用动态方法，而不是static静态方法，因为该方法将被使用多次，使用new AddShopCommand实例化后调用
        let {
            data
        } = e
        SelectItemCommand.selItem(ShopModel.getInstance().shoppingList, data)
    }
    static selItem(list, data) { //遍历查询某项商品增加或减少
        if (!data) { //全选框
            list.checkedAll = !list.checkedAll
            list.map(function (item) {
                item.select = list.checkedAll; //其他选项框与全选框状态一致
            })
        } else { //单选框
            list.checkedAll = 1 //计数器，用来查询是否为全选状态
            list.map(function (item) { //单选，选中某一个（在表格初始化时执行checkAll判断是否全选）
                if (item.id === data.id) {
                    item.select = !item.select
                }
                list.checkedAll *= item.select
            })
        }
        ShopModel.getInstance().shoppingList = list
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="components">components</h3>

<ul><li>Counter（计数器组件）
	<pre><code class="language-javascript">import ShopEvent from '../event/ShopEvent.js'
import ShopController from '../controller/ShopController.js'
import Utils from '../utils/Utils.js'
export default class Counter { //计数器组件
    constructor(_data, _parentEle) {
        this.data = _data
        this.parentEle = _parentEle
        this.ele = this.createCounter()
    }
    createCounter() { //创建数量计数器
        let div = Utils.createEle('div', {}, {
            className: 'numBox'
        })
        this.parentEle.appendChild(div);
        let leftBtn = this.createMark(div, 'reduce') //减少商品按钮
        let input = Utils.createEle('input', {}, {
            type: 'text',
            value: this.data.num
        })
        div.appendChild(input);
        let rightBtn = this.createMark(div, 'add') //新增商品按钮
        leftBtn.addEventListener("click", this.reduceItemEvent);
        rightBtn.addEventListener("click", this.addItemEvent);
        input.addEventListener("input", Utils.throttle(this.changeItemEvent, 500)); // 节流
        return div;
    }
    createMark(parentEle, type) { //判断增加或减少键
        let markBtn = Utils.createEle('button', {}, {
            textContent: type == "add" ? '+' : '-'
        })
        parentEle.appendChild(markBtn);
        return markBtn
    }
    addItemEvent = e =&gt; { //新增商品时，抛发事件至command控制model修改数据，刷新表格
        ShopController.dispatch(ShopEvent.ADD_SHOPIING_ITEM, this.data)
    }
    reduceItemEvent = e =&gt; { //减少商品
        ShopController.dispatch(ShopEvent.REDUCE_SHOPIING_ITEM, this.data)
    }
    changeItemEvent = e =&gt; { //修改商品
        e.target.value = this.data.num = this.checkNumber(e.target.value)
        ShopController.dispatch(ShopEvent.CHANGE_SHOPIING_ITEM, this.data)
    }
    checkNumber(value) { //过滤数据
        value = value.replace(/[^0-9]/g, ""); //只允许输入数字
        if (value === "0") { // 如果=0，就设为1
            value = "1";
        }
        if (value.length &gt; 2) { // 如果输入的内容大于2位，让这个值为99（最大99个）
            value = "99";
        }
        if (value.length === 0) { //  如果什么都没有输入，也设为1
            value = "1";
        }
        return value
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="config">config</h3>

<ul><li>Api
	<pre><code class="language-javascript">export default class Api {//接口配置类
    static URL = "http://127.0.0.1";
    static PORT = ":1024";
    static PATH = '/'
    static GET = "get";
    static POST = "post";
    static IMGPATH = Api.URL + Api.PORT + Api.PATH;
    static ServerApi = {
        getShopList: 'getShopList' //获取商品列表
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="controller">controller</h3>

<ul><li>ShopController（控制层，做事件传导，数据传输）
	<pre><code class="language-javascript">export default class ShopController extends EventTarget { //控制层，处理用户交互，路由，输入，将model view controller剥离开，通过controller中的事件监听抛发进行路由传输数据
    constructor() { //继承事件对象，用于抛发自定义事件
        super();
    }
    static get instance() {  //单例写法与java中getinstance相似，new会生成一个新对象，分配内存，而这么写可以把一个已存在的引用给你使用，节省效能,若只使用get + 属性名而不用set产生只读属性，只允许调用，无法修改
        if (!ShopController._instance) {
            Object.defineProperty(ShopController, "_instance", {
                value: new ShopController()
            })
        }
        return ShopController._instance;
    }
    static dispatch(type, data) { //抛发自定义事件，传递数据
        let event = new Event(type)
        event.data = data
        ShopController.instance.dispatchEvent(event)
    }
    static runCommand(type, Command) { //观察者模式，当自定义事件触发时调用其他类中的方法，与dispatch对应,类似于addEventlistener，只不过将回调函数换成类中的动态方法
        var command = new Command()
        ShopController.instance.addEventListener(type, command.eventHandler)
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="event">event</h3>

<ul><li>ShopEvent
	<pre><code class="language-javascript">export default class ShopEvent {
    constructor() {

    }
    // 所有自定义事件名称
    static GET_DATA = 'get_data'
    static GET_SHOP_LIST = 'get_shop_list'
    static GET_SHOPIING_LIST = 'get_shopping_list'
    static ADD_SHOPIING_ITEM = 'add_shopping_item'
    static DEL_SHOPIING_ITEM = 'del_shopping_item'
    static REDUCE_SHOPIING_ITEM = 'reduce_shopping_item'
    static CHANGE_SHOPIING_ITEM = 'change_shopping_item'
    static SELECT_SHOPIING_ITEM = 'select_shopping_item'
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>EventGroup（事件总线）
	<pre><code class="language-javascript">import ShopEvent from './ShopEvent.js'
import ShopController from '../controller/ShopController.js'
import MainCommand from '../command/MainCommand.js'
let {
    GetDataCommand,
    CreateListCommand,
    CreateTableCommand,
    AddItemCommand,
    DelItemCommand,
    ReduceItemCommand,
    ChangeItemCommand,
    SelectItemCommand
} = MainCommand
export default class EventGroup { //事件总线，注册所有model层与其它层的业务逻辑,全程通过controller层中的事件机制进行通信
    constructor() {
        /*
        1.Ajax获取到数据后，触发GetDataCommand中的方法，用于传递数据至Model层中，然后通过Model层调用CreateListCommand创造商品列表
        2.当用户对商品做任何操作时，都会修改Model从而触发CreateTableCommand，以下操作会触发CreateTableCommand
        3.点击商品列表或点击商品加号按钮时触发AddItemCommand，通过AddItemCommand修改model中的数据，从而驱动CreateTableCommand
        4.点击商品减号按钮时触发ReduceItemCommand，修改model中的数据，从而驱动CreateTableCommand
        5.点击商品删除按钮时触发DelItemCommand，删除model中的数据，从而驱动CreateTableCommand
        6.修改商品数量时触发ChangeItemCommand，更新model中的数据，从而驱动CreateTableCommand
        7.选中商品时触发SelectItemCommand，更新model中的数据，从而驱动CreateTableCommand
         */
        ShopController.runCommand(ShopEvent.GET_DATA, GetDataCommand)//获取商品列表数据
        ShopController.runCommand(ShopEvent.GET_SHOP_LIST, CreateListCommand)//新建商品列表
        ShopController.runCommand(ShopEvent.GET_SHOPIING_LIST, CreateTableCommand)//刷新购物车表格
        ShopController.runCommand(ShopEvent.ADD_SHOPIING_ITEM, AddItemCommand)//商品新增或数量加一
        ShopController.runCommand(ShopEvent.DEL_SHOPIING_ITEM, DelItemCommand)//商品删除
        ShopController.runCommand(ShopEvent.REDUCE_SHOPIING_ITEM, ReduceItemCommand)//商品数量减一
        ShopController.runCommand(ShopEvent.CHANGE_SHOPIING_ITEM, ChangeItemCommand)//修改商品数量
        ShopController.runCommand(ShopEvent.SELECT_SHOPIING_ITEM, SelectItemCommand)//选择商品
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="model">model</h3>

<ul><li>ShopModel（模型层，用于数据存放及数据逻辑）
	<pre><code class="language-javascript">import ShopEvent from '../event/ShopEvent.js'
import ShopController from '../controller/ShopController.js'
export default class ShopModel { //模型层，用于数据存放及数据逻辑，通过事件处理机制（controller）传递数据，再由command进行对数据操作
    constructor() {
        this._shopList = null
        this._shoppingList = []
    }

    static getInstance() { //单例写法与java中getinstance相似，new会生成一个新对象，分配内存，而这么写可以把一个已存在的引用给你使用，节省效能,若只使用get + 属性名而不用set产生只读属性，只允许调用，无法修改
        if (!ShopModel._instance) {
            Object.defineProperty(ShopModel, "_instance", {
                value: new ShopModel()
            })
        }
        return ShopModel._instance;
    }
    set shopList(value) {//设置商品列表
        this._shopList = value;
        ShopController.dispatch(ShopEvent.GET_SHOP_LIST, value)
    }
    get shopList() {
        return this._shopList
    }
    set shoppingList(value) {//数据修改时，驱动view进行表格刷新
        this._shoppingList = value;
        ShopController.dispatch(ShopEvent.GET_SHOPIING_LIST, value)
    }
    get shoppingList() {
        return this._shoppingList
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="utils">utils</h3>

<ul><li>Utils（工具类）
	<pre><code class="language-javascript">export default class Utils { //工具类
	//将对象拼接到url中
	static urlJoin(url, obj) {
		var list = []
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				list.push(`${key}=${obj[key]}`)
			}
		}
		return `${url}?${list.join('&amp;')}`
	}
	static createEle(ele, style, attribute) { //新增标签，设置属性及样式
		let element = document.createElement(ele)
		if (style) {
			for (let key in style) {
				element.style[key] = style[key];
			}
		}
		if (attribute) {
			for (let key in attribute) {
				element[key] = attribute[key];
			}
		}
		return element
	}
	// 函数节流
	static throttle(fn, time) {
		let _timer = null
		return function () {
			if (_timer) {
				clearTimeout(_timer)
				_timer = null
			}
			_timer = setTimeout(fn.bind(this, ...arguments), time)
		}
	}
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul><h3 id="view">view</h3>

<ul><li>ShopView（视图层，用于元素渲染，显示数据）
	<pre><code class="language-javascript">import Api from '../config/Api.js'
import AJAX from '../bussiness/Ajax.js'
import EventGroup from '../event/EventGroup.js'
export default class ShopView { //视图层，用于元素渲染，显示数据，依据（model）模型数据创建
    constructor() {
        new EventGroup() //注册所有自定义事件，用于数据传输
        AJAX.AjaxTool(Api.GET, Api.ServerApi.getShopList, { //请求服务端购物车列表
            token: 'hello'//发送从后端获取的token用于验证，此处未做获取，直接用一个字符代替
        })
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>CreateList（列表视图）
	<pre><code class="language-javascript">import Api from '../config/Api.js'
import Utils from '../utils/Utils.js'
import ShopEvent from '../event/ShopEvent.js'
import ShopController from '../controller/ShopController.js'

export default class CreateList { //视图层，用于元素渲染，显示数据，依据（model）模型数据创建
    constructor(parentEle) {
        this.parentEle = parentEle
        this._shopList = null
    }
    set shopList(value) { //使用对象代理，每当数据发生更改时渲染商品列表
        if (this._shopList) {
            this.createListEle(this._shopList, this.parentEle)
            return;
        }
        this._shopList = value
        this.createListEle(value, this.parentEle)
    }
    get shopList() {
        return this._shopList
    }
    createListEle(data, parentEle) {
        let li = Utils.createEle('li', {}, {
            'className': 'liItem'
        })
        let img = Utils.createEle('img', {}, {
            'src': Api.IMGPATH + data.icon
        })
        let title = Utils.createEle('div', {}, {
            'textContent': data.name
        })
        let price = Utils.createEle('span', {}, {
            'textContent': data.price + "元"
        })
        li.appendChild(img);
        li.appendChild(title);
        li.appendChild(price);
        li.addEventListener('click', this.addItemEvent)
        parentEle.appendChild(li);
    }
    addItemEvent = e =&gt; { //当用户点击添加商品时，将数据通过controller层发送至事件总线，再驱动model层并修改数据,后续由Model提供数据刷新表格
        ShopController.dispatch(ShopEvent.ADD_SHOPIING_ITEM, this.shopList)
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
	<li>CreateTable（购物车表格视图）
	<pre><code class="language-javascript">import Api from '../config/Api.js'
import Utils from '../utils/Utils.js'
import Counter from '../components/Counter.js'
import ShopEvent from '../event/ShopEvent.js'
import ShopController from '../controller/ShopController.js'

export default class CreateTable { //视图层，用于元素渲染，显示数据，依据（model）模型数据创建
    constructor(parentEle) {
        this.parentEle = parentEle
        this._shoppingList = null
        this._table = null
    }
    set shoppingList(value) { //对象代理，若model数据改变时，刷新表格
        let table = document.getElementById('table')
        if (table) { //初始化表格，若有则删除
            table.remove()
            table = null;
        }
        this._shoppingList = value || []
        this.createTab(value, this.parentEle)
    }
    get shoppingList() {
        return this._shoppingList
    }
    createTab(data, parentEle) {
        this._table = Utils.createEle('table', {}, {
            id: "table"
        })
        let thr = Utils.createEle('tr')
        for (let prop in data[0]) { //创建表头，如果属性名是select，就创建全选按钮
            let th = Utils.createEle('th')
            if (prop === "select") {
                let input = Utils.createEle('input', {}, {
                    type: "checkbox",
                    className: "checkbox",
                    checked: this.checkedAll() //查询是否全选
                })
                input.addEventListener("change", this.seleteEvent);
                th.appendChild(input);
            } else {
                th.textContent = prop;
            }
            thr.appendChild(th)
        }
        this._table.appendChild(thr)
        for (let i = 0; i &lt; data.length; i++) {
            let tr = Utils.createEle('tr')
            this._table.appendChild(tr);
            for (let str in this.shoppingList[i]) {
                let td = document.createElement("td");
                this.selectTdType(td, this.shoppingList[i], str);
                tr.appendChild(td);
            }
        }
        parentEle.appendChild(this._table)
    }
    selectTdType(td, data, type) {
        switch (type) {
            case 'select':
                let input = Utils.createEle('input', {}, {
                    type: 'checkbox',
                    className: 'checkbox',
                    checked: data['select'],
                    data
                })
                input.addEventListener("change", this.seleteEvent);
                td.appendChild(input);
                break;
            case 'icon':
                let img = Utils.createEle('img', {}, {
                    'src': Api.IMGPATH + data.icon
                })
                td.appendChild(img);
                break;
            case 'num':
                new Counter(data, td) //实例化计数器组件
                break;
            case 'delete':
                let btn = Utils.createEle('button', {}, {
                    textContent: '删除',
                    data
                })
                td.appendChild(btn);
                btn.addEventListener("click", this.deleteItemEvent);
                break;
            default:
                td.textContent = data[type];
                break;
        }
    }
    deleteItemEvent = e =&gt; { //触发删除事件，通过command删除后通知model驱动view进行刷新
        ShopController.dispatch(ShopEvent.DEL_SHOPIING_ITEM, e.target.data)
    }
    seleteEvent = e =&gt; { //触发选择商品事件，通过command删除后通知model驱动view进行刷新
        ShopController.dispatch(ShopEvent.SELECT_SHOPIING_ITEM, e.target.data)
    }
    checkedAll() {
        let count = 1
        this.shoppingList.map((item) =&gt; {
            count *= item.select
        })
        return count
    }
}</code></pre>

	<p>&nbsp;</p>
	</li>
</ul>                                    ]]></description></item><item><title>JS案例：如何用300行原生js代码写出高大上的购物车</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/02/24/12438917.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 24 Feb 2020 01:08:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/02/24/12438917.html</guid><description><![CDATA[
                                            <p>购物车可谓是js中十分经典的案例，很多电商平台都会用到，是一个十分考验综合性的案例</p>

<p>今天分享一个自己编写的购物车，采用的是原生面向对象实现，数据的传导通过事件代理进行，以下是源码文件夹</p>

<p><img alt="" height="254" src="https://img-blog.csdnimg.cn/20200224083656701.png" width="206">&nbsp;<img alt="" height="255" src="https://img-blog.csdnimg.cn/20200224083902968.png" width="201"></p>

<h3>注释写的很详细</h3>

<h3>HTML:</h3>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="cn"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel="stylesheet" href="./style/shop.css"&gt;
    &lt;script src="./js/methods.js"&gt;&lt;/script&gt;
    &lt;script src="./js/shop.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;ul id="shopBox" class="shopBox"&gt;&lt;/ul&gt;
    &lt;script&gt;
        var shopCar
        Methods.AjaxTool('get', './json/shop.json', {}, function (res) {//Methods封装的AjaxTool是用于本地请求数据的ajax方法
            // var a = singleCar()
            // var b = singleCar()
            // console.log(a === b) //单例模式下，若执行两次，其两次结果为true
            singleCar().init(JSON.parse(res), shopBox); //入口函数
        })

        function singleCar() {//单例模式，只产生一个实例
            if (!shopCar) {
                shopCar = new ShopCar()
            }
            return shopCar
        }
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<h3>CSS：（不做过多注释）</h3>

<pre><code class="language-css">* {
    margin: 0;
    padding: 0;
}

.shopBox {
    overflow: hidden;
    width: 1000px;
    margin: 50px auto 0;
}

.liItem {
    float: left;
    list-style: none;
    padding: 10px;
    width: 150px;
    height: 200px;
    text-align: center;
    border: 1px solid lightcoral;
}

.liItem img {
    width: 100px;
    height: 100px;
}

.leftBtn,
.rightBtn {
    width: 30px;
    height: 30px;
    background: white;
    border: 1px solid black;
    font-size: 25px;
    line-height: 30px;
}

.text {
    width: 50px;
    height: 26px;
    display: inline-block;
    vertical-align: bottom;
    text-align: center;
}

table {
    font-size: 30px;
    width: 1200px;
    border: 1px solid lightcoral;
    border-collapse: collapse;
    margin: 50px auto;
}

.checkbox {
    width: 30px;
    height: 30px;
}

td {
    border: 1px solid lightcoral;
    text-align: center;
    vertical-align: middle;
}

td button {
    width: 150px;
    height: 60px;
}

.numBox {
    width: 150px;
    height: 30px;
    margin: auto;
    position: relative;
}

.numBox&gt;button {
    width: 40px;
    height: 42px;
    background-color: white;
    border: 1px solid #000000;
}

.numBox&gt;input {
    width: 70px;
    height: 40px;
    border: 1px solid #000000;
    border-left: none;
    border-right: none;
    text-align: center;
}</code></pre>

<h3>JSON（用于存放商品信息）：</h3>

<pre><code class="language-javascript">[{
        "id": 1001,
        "icon": "img/1.png",
        "name": "餐饮0",
        "num": 1,
        "price": 10
    },
    {
        "id": 1002,
        "icon": "img/2.png",
        "name": "餐饮1",
        "num": 1,
        "price": 20
    },
    {
        "id": 1003,
        "icon": "img/3.png",
        "name": "餐饮2",
        "num": 1,
        "price": 30
    },
    {
        "id": 1004,
        "icon": "img/4.png",
        "name": "餐饮3",
        "num": 1,
        "price": 40
    },
    {
        "id": 1005,
        "icon": "img/5.png",
        "name": "餐饮4",
        "num": 1,
        "price": 50
    },
    {
        "id": 1006,
        "icon": "img/6.png",
        "name": "餐饮5",
        "num": 1,
        "price": 60
    },
    {
        "id": 1007,
        "icon": "img/7.png",
        "name": "餐饮6",
        "num": 1,
        "price": 70
    },
    {
        "id": 1008,
        "icon": "img/8.png",
        "name": "餐饮7",
        "num": 1,
        "price": 80
    },
    {
        "id": 1009,
        "icon": "img/9.png",
        "name": "餐饮8",
        "num": 1,
        "price": 90
    },
    {
        "id": 1010,
        "icon": "img/10.png",
        "name": "餐饮9",
        "num": 1,
        "price": 100
    }
]</code></pre>

<h3>JS文件（第一个是自定义方法集合，第二个是购物车的全部逻辑）</h3>

<h3>methods.js:</h3>

<pre><code class="language-javascript">var Methods = (function () {//通过立即执行函数return对象的方式产生闭包，用于存放私有变量
    // 可添加私有变量
    return {
        // ajax请求方法
        AjaxTool(method, url, data, fn) {
            var xhr;
            if (window.ActiveXObject) { //ie浏览器
                xhr = new ActiveXObject("Microsoft.XMLHTTP");
            } else if (window.XMLHttpRequest) { //其他浏览器
                xhr = new XMLHttpRequest();
            }
            if (method == 'get') {
                url = this.urlJoin(url, data)
                data = null
            }
            xhr.open(method, url);
            xhr.send(data ? JSON.stringify(data) : '')
            xhr.addEventListener('load', function () {
                if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
                    fn(this.response)
                } else {
                    fn('err')
                }

            })
        },
        //将对象拼接到url中
        urlJoin(url, obj) {
            var list = []
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    list.push(`${key}=${obj[key]}`)
                }
            }
            return `${url}?${list.join('&amp;')}`
        }
    }
}())</code></pre>

<h3>shop.js</h3>

<pre><code class="language-javascript">function ShopCar() {

}
ShopCar.prototype = (function () {
    //闭包存放私有变量
    return {
        shopList: null, //商品详情列表
        shoppingList: null, //购物车中的商品
        table: null, //购物车列表容器
        ADD_ITEM_EVENT: "add_item_event", //添加单个商品自定义事件
        REDUCE_ITEM_EVENT: "reduce_item_event", //减少单个商品自定义事件
        DDELETE_ITEM_EVENT: "delete_item_event", //删除单个商品自定义事件
        INPUT_ITEM_EVENT: "input_item_event", //修改商品数量自定义事件
        CHECK_ITEM_EVENT: "check_item_event", //全选自定义事件
        /*
         *    初始化函数
         *    1、获取存储中的商品列表数据
         *    2、如果商品购物车列表在存储器中存在，那么就将这个数据获取赋值给购物车列表
         *      如果不存在，创建一个空数组
         *    3、侦听添加商品事件，侦听删除商品事件，侦听修改商品数量事件，侦听选中商品事件
         *    4、循环商品列表，创建所有的商品标签
         *    5、根据购物车列表创建表格
         * */
        init(shopList, parentEle) {
            if (localStorage.shoppingList) { //获取本地缓存中已加入购物车的数据
                this.shoppingList = JSON.parse(localStorage.shoppingList);
            } else {
                this.shoppingList = [];
            }
            if (!this.shopList) {
                this.shopList = shopList
                this.createShopList(parentEle)
            }
            // 以下均为操作时的事件监听，采取自定义事件接收document的事件抛发，分别是：加入购物车(增加某一个商品)，减少一个商品，删除某商品，输入商品数量，全选/取消全选
            document.addEventListener(this.ADD_ITEM_EVENT, this.addItemEventHandler)
            document.addEventListener(this.REDUCE_ITEM_EVENT, this.reduceItemEventHandler)
            document.addEventListener(this.DDELETE_ITEM_EVENT, this.deleteItemEventHandler)
            document.addEventListener(this.INPUT_ITEM_EVENT, this.inputItemEventHandler)
            document.addEventListener(this.CHECK_ITEM_EVENT, this.checkItemEventHandler)
        },
        createShopList(parentEle) { //创建商品详情列表
            var data = this.shopList
            for (var i = 0; i &lt; data.length; i++) {
                var li = document.createElement("li");
                li.className = "liItem";
                var img = new Image();
                img.src = data[i].icon;
                li.appendChild(img);
                var title = document.createElement("div");
                title.textContent = data[i].name;
                li.appendChild(title);
                var price = document.createElement("span");
                price.textContent = data[i].price + "元";
                li.appendChild(price);
                li.that = this //将全局this存至元素中，方便后续调用
                li.data = data[i]; //与上句同理，方便后续调用
                li.addEventListener("click", this.addItemEvent);
                parentEle.appendChild(li);
            }
            this.createTable()
        },
        createTable() { //当数据发生变化时重新渲染购物车列表初始化购物车
            if (this.table) { //初始化购物车
                this.table.remove()
                this.table = null;
            }
            if (this.shoppingList.length === 0) return;
            this.table = document.createElement("table");
            document.body.appendChild(this.table);
            var thr = document.createElement("tr");
            this.table.appendChild(thr);
            for (var prop in this.shoppingList[0]) { //创建表头，如果属性名是select，就创建全选按钮
                var th = document.createElement("th");
                if (prop === "select") {
                    var input = document.createElement("input");
                    input.type = "checkbox";
                    input.className = 'checkbox'
                    input.checked = this.checkAll(); //由于当数据修改时绑定了createTable方法，每次数据改变就会刷新全选状态
                    input.that = this //将全局this存至元素中，方便后续调用
                    input.addEventListener("change", this.checkEvent);
                    th.appendChild(input);
                } else {
                    th.textContent = prop;
                }
                thr.appendChild(th)
            }
            for (var i = 0; i &lt; this.shoppingList.length; i++) {
                var tr = document.createElement("tr");
                this.table.appendChild(tr);
                for (var str in this.shoppingList[i]) {
                    var td = document.createElement("td");
                    td.data = this.shoppingList[i]; //将每一行数据存至td元素中，方便后续调用
                    this.selectTdType(td, this.shoppingList[i], str);
                    tr.appendChild(td);
                }
            }
            localStorage.shoppingList = JSON.stringify(this.shoppingList) //当表格渲染完毕就将数据存至本地缓存，浏览器关闭或刷新不会清除数据
        },
        selectTdType(td, data, type) { //将表格中的元素通过属性分类
            switch (type) {
                case 'select':
                    var input = document.createElement("input");
                    input.type = "checkbox";
                    input.checked = data.select;
                    input.className = 'checkbox'
                    input.that = this
                    input.addEventListener("change", this.checkEvent);
                    td.appendChild(input);
                    break;
                case 'icon':
                    var img = new Image();
                    img.src = data.icon;
                    td.appendChild(img);
                    break;
                case 'num':
                    var countNum = this.createCountNum(td, data);
                    countNum.input.value = data.num;
                    break;
                case 'deleted':
                    var btn = document.createElement("button");
                    btn.textContent = "删除";
                    td.appendChild(btn);
                    btn.that = this
                    btn.data = data;
                    btn.addEventListener("click", this.deleteItemEvent);
                    break;
                default:
                    td.textContent = data[type];
                    break;
            }
        },
        createCountNum(ele, data) { //创建数量计数器
            var div = document.createElement("div"); //这个父元素用于储存单个商品信息
            ele.appendChild(div);
            div.className = "numBox";
            var leftBtn = this.createMark(div, 'reduce') //减少商品按钮
            var input = document.createElement("input");
            input.type = "text";
            input.value = "1"; //商品初始数量
            div.appendChild(input);
            var rightBtn = this.createMark(div, 'add') //新增商品按钮
            div.input = input;
            div.data = data;
            div.that = this
            rightBtn.that = this
            rightBtn.data = data;
            leftBtn.addEventListener("click", this.reduceItemEvent);
            rightBtn.addEventListener("click", this.addItemEvent);
            input.addEventListener("input", this.inputItemEvent);
            input.addEventListener("blur", this.inputItemEvent);
            return div;
        },
        createMark(parentEle, type) { //判断增加或减少键
            var markBtn = document.createElement("button");
            markBtn.textContent = type == "add" ? '+' : '-';
            parentEle.appendChild(markBtn);
            return markBtn
        },
        addItemEvent() { //第一个事件抛发（当用户点击列表商品或点击增加键时，抛发事件给document触发addItemEventHandler方法，用于参数传递，参数通过event对象进行传递）
            var _this = this.that
            var event = new Event(_this.ADD_ITEM_EVENT);
            event.data = this.data;
            event._this = _this;
            document.dispatchEvent(event);
        },
        addItemEventHandler(e) { //当用户点击列表商品或点击增加键时执行函数
            var _this = e._this
            var obj = { //这里遵循对象顺序，先定义的属性排在前面，所以将选择框放在最前定义，总价和删除键放在最后
                select: false
            };
            for (var str in e.data) {
                obj[str] = e.data[str];
            }
            obj.sum = obj.num * obj.price;
            obj.deleted = false;
            _this.searchItemById(obj.id, _this.shoppingList, obj, 'add')
            _this.createTable() //当数据发生变化时重新渲染购物车列表初始化购物车
        },
        reduceItemEvent() { //第二个事件抛发（当用户点击减少键时，抛发事件给document触发reduceItemEventHandler方法，用于参数传递，参数通过event对象进行传递）
            var _this = this.parentElement.that
            var event = new Event(_this.REDUCE_ITEM_EVENT);
            event.data = this.parentElement.data;
            event._this = _this;
            document.dispatchEvent(event);
        },
        reduceItemEventHandler(e) { //与增加同理
            var _this = e._this
            e.data.sum = e.data.num * e.data.price;
            _this.searchItemById(e.data.id, _this.shoppingList, e.data, 'reduce')
            _this.createTable() //当数据发生变化时重新渲染购物车列表初始化购物车
        },
        deleteItemEvent() { //第三个事件抛发（当用户点击删除键时，抛发事件给document触发deleteItemEventHandler方法，用于参数传递，参数通过event对象进行传递）
            var _this = this.that
            var event = new Event(_this.DDELETE_ITEM_EVENT);
            event.data = this.data;
            event._this = _this;
            document.dispatchEvent(event);
        },
        deleteItemEventHandler(e) {
            var _this = e._this
            _this.shoppingList = _this.shoppingList.filter(function (item) { //数组过滤函数，返回id属性不等于当前id的数组，即删除当前选中的对象，并重新赋值
                return item.id !== e.data.id;
            });
            _this.createTable() //当数据发生变化时重新渲染购物车列表初始化购物车
            localStorage.shoppingList = JSON.stringify(_this.shoppingList) //这里为了考虑，若删除到0条时，无法重新初始化表格（shoppingList.length==0,无法进入createTable函数）
        },
        inputItemEvent(e) { //第四个事件抛发（当用户输入数值或处于失焦时，过滤数据，并抛发事件给document触发inputItemEventHandler方法，用于参数传递，参数通过event对象进行传递）
            var _this = this.parentElement.that
            if (e.type === "input") {
                this.value = this.value.replace(/[^0-9]/g, ""); //只允许输入数字
                if (this.value === "0") { // 如果=0，就设为1
                    this.value = "1";
                }
                if (this.value.length &gt; 2) { // 如果输入的内容大于2位，让这个值为99（最大99个）
                    this.value = "99";
                }
            } else if (e.type === "blur") {
                if (this.value.length === 0) { //  失焦时，如果什么都没有输入，也设为1
                    this.value = "1";
                }
                // 当失焦时才将事件抛发到document
                var event = new Event(_this.INPUT_ITEM_EVENT);
                event.num = this.value
                event.data = this.parentElement.data;
                event._this = _this;
                document.dispatchEvent(event);
            }
        },
        inputItemEventHandler(e) {
            var _this = e._this
            _this.shoppingList.map(function (item) { //遍历查询被修改的对象
                if (item.id === e.data.id) {
                    item.num = e.num;
                    item.sum = item.price * item.num;
                }
            });
            _this.createTable() //当数据发生变化时重新渲染购物车列表初始化购物车
        },
        checkAll() { //初始化表格时执行，查找所有选项是否都选中（全选框随其他选项框状态修改而修改）
            return this.shoppingList.filter(function (item) {
                return !item.select;
            }).length === 0; //返回true或false
        },
        checkEvent() { //第五个事件抛发（当用户选中或取消任意选项框时，抛发事件给document触发checkItemEventHandler方法，用于参数传递，参数通过event对象进行传递）
            var _this = this.that
            var data = this.parentElement.data;
            var event = new Event(_this.CHECK_ITEM_EVENT);
            event.all = !data; //若没有data，说明是全选框
            event.select = this.checked; //赋值给select属性
            event._this = _this;
            event.data = data;
            document.dispatchEvent(event);
        },
        checkItemEventHandler(e) {
            var _this = e._this
            if (e.all) { //若e.all为true说明该选项框是全选框
                _this.shoppingList.map(function (item) {
                    item.select = e.select; //其他选项框与全选框状态一致
                })
            } else {
                _this.shoppingList.map(function (item) { //单选，选中某一个（在表格初始化时执行checkAll判断是否全选）
                    if (item.id === e.data.id) {
                        item.select = e.select;
                    }
                })
            }
            _this.createTable() //当数据发生变化时重新渲染购物车列表初始化购物车
        },
        searchItemById(id, list, data, type) { //遍历查询某项商品增加或减少
            var arr = list.filter(function (item) {
                return item.id === id;
            }); //若有返回值则对某项商品操作（在1-99区间，若为0则直接删除）
            switch (type) {
                case "add":
                    if (arr.length == 0) {
                        list.push(data);
                    } else if (arr[0].num &lt; 99) {
                        arr[0].num++;
                        arr[0].sum = arr[0].num * arr[0].price;
                    }
                    break;
                case "reduce":
                    if (arr[0].num &gt; 1) {
                        arr[0].num--;
                        arr[0].sum = arr[0].num * arr[0].price;
                    } else {
                        this.shoppingList = list.filter(function (item) {
                            return item.id !== id;
                        });
                        this.createTable() //当数据发生变化时重新渲染购物车列表初始化购物车
                        localStorage.shoppingList = JSON.stringify(this.shoppingList)
                    }
                    break;
            }
        }
    }
}())
ShopCar.prototype.constructor = ShopCar;</code></pre>

<p>附上运行效果：</p>

<p><img alt="" height="560" src="https://img-blog.csdnimg.cn/20200224090631854.gif" width="876"></p>
                                    ]]></description></item><item><title>JS案例：拖拽音量调节效果</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/02/22/12438918.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 22 Feb 2020 08:06:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/02/22/12438918.html</guid><description><![CDATA[
                                            <p>用原生js做了一个拖拽调节音量</p>

<p>效果是这样的：（拖动时音量随两个圆形交集面积增大而增大）</p>

<p><img alt="" height="165" src="https://img-blog.csdnimg.cn/20200222153956378.gif" width="452"></p>

<p>&nbsp;html部分：</p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel="stylesheet" href="index.css"&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;audio id="audio" autoplay&gt;
        &lt;source src="./1.mp3" type="audio/mpeg"&gt;
    &lt;/audio&gt;
    &lt;div class="vol left" id="leftBox"&gt;&lt;/div&gt;
    &lt;div class="vol right" id="rightBox"&gt;&lt;/div&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>css部分：</p>

<pre><code class="language-css">* {
    margin: 0;
    padding: 0;
}

body {
    background: rgb(28, 160, 210);
}

.vol {
    width: 200px;
    height: 200px;
    position: absolute;
    border-radius: 100px;
}

.left {
    left: 500px;
    top: 100px;
    background: rgb(250, 242, 107);
}

.right {
    left: 800px;
    top: 100px;
    background: rgba(250, 242, 107, 100);
    z-index: 1;
}</code></pre>

<p>js部分：</p>

<pre><code class="language-javascript">var audio;
init()//入口函数

function init() {
    audio = document.getElementById("audio");//初始化播放器控件
    audio.volume = 0;//将控件音量初始值设置0
    mouseMove(rightBox, document)
}

function mouseMove(ele, parent) {
    ele.addEventListener('mousedown', moveHandler);//鼠标右击时触发moveHandler方法
    ele.style.position = 'absolute';
    ele.parent = parent;//传递父元素（可省略）
}

function moveHandler(e) {//moveHandler是个回调函数，鼠标按下，移动，松开都会触发，根据event的type判断事件类型
    if (e.preventDefault) {//取消系统默认事件
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
    if (e.type === 'mousedown') {
        audio.play()//按下时开始播放音乐
        // 下面将被点击的元素及元素在X方向的偏移通过父元素传递（放入内存中）
        this.parent.ele = this;
        this.parent.point = {
            x: e.offsetX
        }
        // 为元素添加鼠标移动和松开事件
        this.parent.addEventListener('mousemove', moveHandler);
        this.addEventListener('mouseup', moveHandler);
    } else if (e.type === 'mousemove') {
        if (rightBox.offsetLeft - leftBox.offsetLeft &gt;= 200 || rightBox.offsetLeft - leftBox.offsetLeft &lt;= -200) {//当被移动元素与另一个元素无交集时，改变样式，使音量为0
            audio.volume = 0;
            document.body.style.background = 'rgb(28,160,210)'
            rightBox.style.background = 'rgba(250, 242, 107, 100)';
        } else {//当被移动元素与另一个元素有交集时，改变样式为渐变，使音量为相交面积的百分比（这里是两圆心之间的距离）
            var count = 1 - Math.abs(rightBox.offsetLeft - leftBox.offsetLeft) / 200;
            audio.volume = count
            document.body.style.background = `rgb(${28+50*count},${160-136*count},${210-133*count})`
            rightBox.style.background = `rgb(${28+50*count},${160-136*count},${210-133*count})`;
        }
        this.ele.style.left = e.x - this.point.x + "px";
    } else if (e.type === 'mouseup') {
        // 鼠标松开时释放内存及事件监听
        this.parent.removeEventListener("mousemove", moveHandler);
        this.parent.ele = null;
        this.parent.point = null;
    }
}</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>本地项目上线流程</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/02/22/12438919.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 22 Feb 2020 04:45:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2020/02/22/12438919.html</guid><description><![CDATA[
                                            <p>以下是自己一个项目的本地上传至线上的总结</p>

<h3>新建服务器实例</h3>

<p>首先，你需要在各大云服务器平台选购一台合适的服务器</p>

<p>这里我选用的是阿里云（window2008 server版）</p>

<p><img alt="" height="117" src="https://img-blog.csdnimg.cn/20200222102725702.png" width="1111"></p>

<p>为什么系统选2008而不是2012版？</p>

<p>因为2008相对于2012占用的资源较少，当然如果你服务器配置高的话，就不用担心了</p>

<p>关闭服务器实例后，在服务器选项更多中选择更换系统&nbsp;</p>

<p><img alt="" height="243" src="https://img-blog.csdnimg.cn/20200222104511667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="332"></p>

<p>&nbsp;配置服务器账号密码并等待安装系统</p>

<h3>启动服务器</h3>

<p>点击启动实例</p>

<p><img alt="" height="256" src="https://img-blog.csdnimg.cn/20200222105936270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="318"></p>

<p>服务器控制台提供了远程连接实例功能，但是是介于网页版，部分功能及操作还不够全面，所以我们移步到自己电脑自带的远程桌面连接，并记住公网ip地址，用户名及开机密码</p>

<p><img alt="" height="399" src="https://img-blog.csdnimg.cn/20200222104834645.png" width="237"><img alt="" height="446" src="https://img-blog.csdnimg.cn/20200222105744415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="421"></p>

<p>&nbsp;输入ip，用户名，密码点击连接</p>

<p><img alt="" height="768" src="https://img-blog.csdnimg.cn/20200222111128474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="1200"></p>

<h3>&nbsp;配置服务器</h3>

<p>开机后，就可以直接开始配置node，Java，Nginx之类的了</p>

<p>简述一下Nginx（node在<a href="https://blog.csdn.net/time_____/article/details/84565042">https://blog.csdn.net/time_____/article/details/84565042</a>有介绍）</p>

<p>下载安装Nginx最新版</p>

<p>在目录nginx-1.15.8\conf\下找到nginx.conf文件，用编辑器打开，为自己的项目添加代理（这里我用的是Vue，端口号2048，root是Nginx主目录下一级文件名，index是vue文件夹下的入口页面）</p>

<p><img alt="" height="354" src="https://img-blog.csdnimg.cn/20200222112735376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="579"></p>

<h3>本地项目打包上线</h3>

<p>其实这个过程就是把本地请求的url改成服务器私有ip地址</p>

<p><img alt="" height="94" src="https://img-blog.csdnimg.cn/20200222114007547.png" width="692">&nbsp;</p>

<p>&nbsp;这里有一个服务器需要配置安全组，目的是为了开放接口以供调用，否则刚才配置的2048端口号无法访问</p>

<p><img alt="" height="149" src="https://img-blog.csdnimg.cn/20200222114728961.png" width="110"><img alt="" height="68" src="https://img-blog.csdnimg.cn/20200222114647396.png" width="581"><img alt="" height="277" src="https://img-blog.csdnimg.cn/2020022211484235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="277"></p>

<p>之后将本地项目baseurl修改为服务器私有ip地址</p>

<p><img alt="" height="261" src="https://img-blog.csdnimg.cn/20200222115239866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="621"></p>

<p>之后使用npm run build将项目打包在build文件夹中生成了打包后文件</p>

<p><img alt="" height="87" src="https://img-blog.csdnimg.cn/2020022211592867.png" width="450"></p>

<p>复制文件夹到Nginx主目录下命名为vue</p>

<h3>后端上线</h3>

<p>与前端同理</p>

<p><img alt="" height="80" src="https://img-blog.csdnimg.cn/20200222123423361.png" width="397"></p>

<p>将项目上传至服务器后运行（这里我是nodejs，所以切换到项目目录下运行node server）</p>

<p><img alt="" height="315" src="https://img-blog.csdnimg.cn/20200222124131385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="496"></p>

<p>在Nginx主目录下打开cmd运行start nginx，即可打开Nginx服务器</p>

<p><img alt="" height="323" src="https://img-blog.csdnimg.cn/20200222123905731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="503"></p>

<h3>线上访问</h3>

<p>最后在我们浏览器中访问服务器的ip加地址</p>

<p><img alt="" height="682" src="https://img-blog.csdnimg.cn/20200222124319914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="614"></p>

<p>最后，我们的项目就上传完毕&nbsp;</p>
                                    ]]></description></item><item><title>JS案例：常用工具</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/03/30/12438920.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 30 Mar 2019 01:24:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/03/30/12438920.html</guid><description><![CDATA[
                                            <h3>对以前用过的方法做个整合&nbsp;</h3>

<pre class="has"><code class="language-javascript">let Methods = (function () {
    return {
        // 随机颜色
        randomColor: function () {
            var color = '#'
            for (let i = 0; i &lt; 6; i++) {
                var num = parseInt(Math.random().toFixed(2) * 16);
                color += num.toString(16);
            }
            return color
        },
        //产生区间随机数
        randomNum(min, max, bool) { //bool是表示是否可等于最大值
            return (Math.floor(Math.random() * (max - min + bool) + min));
        },
        //数组去重
        arrayUniq(arr) {
            var list = [];
            var leng = arr.length
            for (var i = 0; i &lt; leng; i++) {
                if (list.indexOf(arr[i]) === -1) {
                    list.push(arr[i]);
                }
            }
            return list
        },
        //数组乱序
        arrayRandom(arr) {
            arr.sort(function () {
                return Math.random() - 0.5
            })
            return arr
        },
        //拆分url变成对象
        urlSplit(url) {
            var list = url.split('?')[1].split('&amp;');
            var leng = list.length;
            let obj = {}
            for (let i = 0; i &lt; leng; i++) {
                var key = list[i].split('=')[0];
                var val = list[i].split('=')[1];
                obj[key] = val
            }
            return obj
        },
        //将对象拼接到url中
        urlJoin(url, obj) {
            var list = []
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    list.push(`${key}=${obj[key]}`)
                }
            }
            return `${url}?${list.join('&amp;')}`
        },
        // 设置元素CSS样式
        setStyle(elem, style) {
            for (var str in style) {
                elem.style[str] = style[str];
            }
        },
        // Ajax请求函数
        ajaxTool(method, url, data, fn) {
            var xhr;
            if (window.ActiveXObject) {
                xhr = new ActiveXObject("Microsoft.XMLHTTP");
            } else if (window.XMLHttpRequest) {
                xhr = new XMLHttpRequest();
            }
            xhr.open(method, url);
            xhr.send(data || '')
            xhr.addEventListener('load', function () {
                if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
                    fn(this.response)
                } else {
                    fn('err')
                }

            })
        },
        //拖拽事件
        mouseMove(ele, parent) {
            ele.addEventListener('mousedown', moveHandler);
            ele.style.position = 'absolute'

            function moveHandler(e) {
                if (e.type === 'mousedown') {
                    parent.ele = this;
                    parent.point = {
                        x: e.offsetX,
                        y: e.offsetY
                    }
                    parent.addEventListener('mousemove', moveHandler);
                    parent.addEventListener('mouseup', moveHandler);
                } else if (e.type === 'mousemove') {
                    this.ele.style.left = e.x - this.point.x + "px";
                    this.ele.style.top = e.y - this.point.y + "px";
                } else if (e.type === 'mouseup') {
                    parent.removeEventListener("mousemove", moveHandler);
                    parent.ele = null;
                    parent.point = null;
                }
            }
        },
        //继承
        inherit(father, son) {
            function F() {} //使用闭包产生私有函数
            (function (father, son) { ////新建一个立即执行函数,(类似雅虎网站的继承写法)
                F.prototype = father.prototype; //私有函数取出父类的原型
                son.prototype = new F(); //实例化私有函数，并将对象赋给子类的原型
                son.prototype.superClass = father; //自定义子类的超类等于父类
                son.prototype.constructor = son; //将子类的构造函数指向自己，否则是父类(因为原型链上的constructor是父类)
            }(father, son))
        },
        //深复制
        deepCopy(org, tag) {
            var tag = tag || {}; //初始化要复制的对象
            var name = Object.getOwnPropertyNames(org); //获取该对象的属性名，以字符串数组返回
            for (var i = 0; i &lt; name.length; i++) { //遍历对象
                var desc = Object.getOwnPropertyDescriptor(org, name[i]); //获取对象的属性描述对象，无引用关系，返回另一个对象，改变时原对象不发生变化(复制的关键)
                if (typeof desc.value === 'object' &amp;&amp; desc.value !== null) { //若遍历的每一项非空且为对象，则为引用值，则进行下一步
                    var obj = desc.value.toString() === '[object Object]' ? {} : []; //判断是数组还是对象
                    Object.defineProperty(tag, name[i], { //设置对象属性值，前三个的值是返回true或false
                        configurable: desc.configurable, //是否可删除可替换
                        enumerable: desc.enumerable, //是否可枚举可遍历
                        writable: desc.writable, //是否可写入
                        value: obj //对象的值
                    });
                    this.deepCopy(desc.value, obj); //再次执行函数
                } else {
                    Object.defineProperty(tag, name[i], desc); //否则直接将该对象的属性值进行复制(原始值)
                }
            }
            return tag;
        },
        //获取伪元素
        pseudoEle(ele, type) {
            return window.getComputedStyle(ele, type)
        },
        //获取数据类型
        getType(data) {
            var type = typeof data;
            var obj = {
                '[object Array]': 'array',
                '[object Object]': 'object'
            }
            if (data === null) {
                return 'null'
            } else if (type === 'object') {
                var key = Object.prototype.toString.call(data);
                return obj[key];
            } else {
                return type
            }
        },
        // 在某元素（after）之后插入元素（target）
        insertAfter(parent, after, target) {
            before = after.nextElementSibling;
            console.log(before);

            if (before == null) {
                parent.appendChild(target)
            } else {
                parent.insertBefore(target, before)
            }
        },
        //浏览器事件兼容函数
        addHandler(ele, type, handle) {
            if (ele.addEventListener) {
                ele.addEventListener(type, handle, false)
            } else if (ele.attachEvent) {
                ele.attachEvent('on' + type, function () {
                    handle.call(ele)
                })
            } else {
                ele['on' + type] = handle
            }
        },
        // 取消事件冒泡
        stopBubble(event) {
            event = event || window.event
            if (event.stopPropagation) {
                event.stopPropagation()
            } else {
                event.cancelBubble()
            }
        },
        //取消默认事件
        stopDefault(event) {
            event = event || window.event
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        // cookie操作(time是小时)
        cookieUse(type, data, name, time = 1) {
            switch (type) {
                case 'add':
                    var date = new Date()
                    date.setHours(date.getHours() + time)
                    document.cookie = name + '=' + JSON.stringify(data) + ";expires=" + date.toString();
                    break;
                case 'del':
                    document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT";
                    break;
                case 'find':
                    var arr = document.cookie.split(';')
                    var leng = arr.length;
                    for (let i = 0; i &lt; leng; i++) {
                        if (arr[i].split('=')[0] === name) {
                            return JSON.parse(arr[i].split('=')[1]);
                        }
                    }
                    break;
                default:
                    break;
            }
        },
        // 缓存storage使用
        storageUse(method, type, name, data) {
            var obj = {}
            if (method === 'session') {
                obj = sessionStorage
            } else if (method === 'local') {
                obj = localStorage
            } else {
                return;
            }
            switch (type) {
                case 'add':
                    obj.setItem(name, JSON.stringify(data))
                    break;
                case 'del':
                    obj.removeItem(name);
                    break;
                case 'delAll':
                    obj.clear();
                    break;
                case 'find':
                    return JSON.parse(obj[name])
                default:
                    break;
            }
        },
        // 复制文本(可复制元素内容,输入框的值,字符串)ele是触发事件对象，event是事件类型,target是被复制的对象
        copyText(ele, event, target) {
            // this.addHandler(ele, event, handle)
            this.addHandler(ele, event, function (e) {
                var input = document.createElement('input');
                if (typeof target == 'string') {
                    input.value = target
                } else if (target.value) {
                    input.value = target.value
                } else {
                    input.value = target.textContent
                }
                document.body.appendChild(input)
                input.select();
                document.execCommand('Copy');
                input.style.display = 'none'
            })

        },
        // 获取选中文本
        selectText(parent, event, fn) {
            this.addHandler(parent, event, function (e) {
                var str = ''
                if (window.getSelection) {
                    //Firefox、Chrome、Safari、Opera
                    str = window.getSelection().toString();
                } else if (document.selection &amp;&amp; document.selection.createRange) { //IE 
                    str = document.selection.createRange().text;
                }
                fn(str)
            })
        },
        // checkBox全选
        checkAll(selectAll, selectItem) {
            let len = selectItem.length;
            this.addHandler(selectAll, 'change', function (e) {
                for (let i = 0; i &lt; len; i++) {
                    selectItem[i].checked = e.target.checked
                }
            });
            for (let j = 0; j &lt; len; j++) {
                this.addHandler(selectItem[j], 'change', function (e) {
                    let result = 1;
                    for (let k = 0; k &lt; len; k++) {
                        result *= selectItem[k].checked;
                    }
                    selectAll.checked = result ? true : false
                })
            }
        },
        // 数组扁平化
        demoteArr(arr, list = []) {
            let len = arr.length;
            for (let i = 0; i &lt; len; i++) {
                if (this.getType(arr[i]) === 'array') {
                    this.demoteArr(arr[i], list)
                } else {
                    list.push(arr[i])
                }
            }
            return list
        },
        //数组升二维(num:每层的个数)
        updateArr(arr, num, list = []) {
            let count = Math.ceil(arr.length / num)
            let value = 0
            for (let i = 0; i &lt; count; i++) {
                let initList = []
                for (let j = 0; j &lt; num; j++) {
                    initList.push(arr[value])
                    value++
                }
                list.push(initList)
            }
            return list
        },
        // 三级联动
        moreSelect: function (url, elements) {
            function GetArea(url) {
                this.url = url
                this.init(elements)
            }
            GetArea.prototype = {
                num: 0,
                selections: null,
                list: [],
                createOptions(data, parent) {
                    if (!parent) return
                    if (parent.children) {
                        var leng = parent.children.length
                        for (var j = 0; j &lt; leng; j++) {
                            parent.lastElementChild.textContent = ''
                            parent.lastElementChild.remove()
                        }
                    }
                    for (var i = 0; i &lt; data.length; i++) {
                        var option = document.createElement('option');
                        option.textContent = data[i].name || data[i]
                        parent.appendChild(option)
                    }
                    parent.addEventListener('change', this.changeHandler);
                    parent.data = data
                    parent.self = this
                },
                init(elements) {
                    this.selections = elements
                    var xhr = new XMLHttpRequest();
                    xhr.addEventListener('load', this.loadHandler);
                    xhr.open('get', this.url)
                    xhr.send('')
                    xhr.self = this
                },
                loadHandler(e) {
                    this.self.list = JSON.parse(this.response)
                    this.self.createOptions(this.self.list, this.self.selections[this.self.num])
                },
                changeHandler(e) {
                    var list;
                    this.data.forEach((item) =&gt; {
                        if (item.name === this.value) {
                            list = item.city ? item.city : item
                        }
                    });
                    this.self.selections.forEach((item, val) =&gt; {
                        if (item.id === this.id) {
                            console.log(this.self.num)
                            this.self.num = item.id.split('select')[1] - 1
                        }
                    })
                    if (this.self.num &gt; this.self.selections.length - 1) {
                        return
                    }
                    this.self.num++
                    this.self.createOptions(list, this.self.selections[this.self.num])
                }
            }
            return getArea = new GetArea(url);
        },
        // 函数防抖
        unShake(fn, time) {
            var count = null;
            return function () {
                var _self = this;
                clearTimeout(count)
                var args = arguments;
                count = setTimeout(function () {
                    fn.call(_self, ...args)
                }, time)
            }
        },
        // 函数节流
        throttle(fn, time) {
            var _endTime = 0
            return function () {
                var _startTime = new Date().getTime();
                if (_startTime - _endTime &lt; time) return
                fn.call(this, ...arguments)
                _endTime = _startTime;
            }
        }
    }
}())</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>小程序入坑记：TodoList</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/03/07/12438921.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 07 Mar 2019 08:56:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/03/07/12438921.html</guid><description><![CDATA[
                                            <h2>小程序数据绑定渲染视图使数据与视图的关系显得很清晰</h2>

<p>wxml：</p>

<pre class="has"><code class="language-html">&lt;!--pages/todoList/toduList.wxml--&gt;
&lt;input class='addItem' placeholder-style='font-size:16px;' placeholder='输入事项' bindinput='changeStr' value='{{addStr}}'&gt;&lt;/input&gt;
&lt;button class='add' type='primary' bindtap='addTodo'&gt;提交&lt;/button&gt;
&lt;view class='listBox'&gt;
  &lt;view class='listItem' wx:for="{{addList}}" wx:key='item.id'&gt;
    &lt;text class='content'&gt;{{item.content}}&lt;/text&gt;
    &lt;text class='time'&gt;{{item.time}}&lt;/text&gt;
    &lt;button class='finish' disabled="{{item.finish}}" bindtap='tapHandler' data-id='{{item.id}}'&gt;{{item.finish?'已完成':'完成'}}&lt;/button&gt;
    &lt;button class='del' type='warn' bindtap='tapHandler' data-id='{{item.id}}'&gt;删除&lt;/button&gt;
  &lt;/view&gt;
&lt;/view&gt;</code></pre>

<p>wxss：</p>

<pre class="has"><code class="language-css">.addItem {
  position: fixed;
  top: 0;
  left: 0;
  width: 550rpx;
  height: 60rpx;
  background: #ccc;
  padding-left: 30rpx;
  border-radius: 10rpx;
  display: inline-block;
  z-index: 10;
}

.add {
  position: fixed;
  top: 0;
  right: 0;
  height: 60rpx;
  line-height: 60rpx;
  display: inline-block;
  width: 150rpx;
  font-size: 30rpx;
  z-index: 10;
}

.content {
  display: inline-block;
  /* background: lightcoral; */
  width: 250rpx;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  vertical-align: middle;
}

.time {
  /* background: lightblue; */
  vertical-align: middle;
}

.listBox {
  margin-top: 60rpx;
}

.listItem {
  font-size: 14px;
  padding-top: 20rpx;
}

.del, .finish {
  display: inline-block;
  font-size: 22rpx;
  width: 100rpx;
  height: 60rpx;
  line-height: 60rpx;
  vertical-align: middle;
}
</code></pre>

<p>js：</p>

<pre class="has"><code class="language-javascript">// pages/todoList/toduList.js
Page({
  data: {
    addStr: '', //输入的内容，将该值绑定到input的value中
    addList: [] //事项列表
  },
  changeStr(e) {
    this.setData({
      addStr: e.detail.value //当用户输入值时，修改当前事项内容
    })
  },
  addTodo(e) {
    var str = this.data.addStr.trim() //去除字符前后空格
    if (str.length === 0) {
      return;
    }
    var addList = this.data.addList;
    var date = new Date() //生成提交的时间
    var time = date.toLocaleString(); //转换为标准时间
    var obj = { //每个事项的内容
      id: addList.length, //将id设为数组的长度，方便后续操作
      content: str, //事项内容
      time: time, //提交时间
      finish: false //是否已完成
    }
    addList.push(obj) //将该事项添加到事项列表中
    this.setData({ //刷新列表，置空input内容
      addList,
      addStr: ''
    })
  },
  tapHandler(e) { //用户点击完成或删除时触发
    var addList = this.data.addList
    var id = e.target.dataset.id //获取时间传递的id值
    var type = e._relatedInfo.anchorTargetText //获取点击种类：删除或完成
    for (let i = 0; i &lt; addList.length; i++) { //遍历列表
      if (addList[i].id === id) {
        switch (type) {
          case '完成':
            addList[i].finish = true; //点击完成时执行
            break;
          case '删除':
            addList.splice(i, 1); //点击删除时执行
            break;
          default:
            break;
        }
        this.setData({ //刷新列表
          addList
        })
      }
    }
  }
})</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>小程序入坑记：懒加载</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/03/06/12438922.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Wed, 06 Mar 2019 03:04:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/03/06/12438922.html</guid><description><![CDATA[
                                            <p>小程序可以说是非常火热了，开发周期短，页面简洁，数据控制方便，可以说结合了三大框架的特点</p>

<h2>小程序的目录结构：</h2>

<p>页面以index为例</p>

<p>utils：工具类目录，供全局调用。在utils中封装一个tools工具类（axios获取请求）</p>

<pre class="has"><code class="language-javascript">class Tools {
  constructor() {

  }
  axios(method, url, data) {
    return new Promise((resolve, reject) =&gt; {//promise解决异步，其他操作和axios相似
      wx.request({
        method: method,
        url: url,
        data: JSON.stringify(data),
        header: {
          'content-type': 'application/json'
        },
        success(res) {
          if (res.statusCode === 200) {
            resolve(res.data);//过滤data
          } else {
            reject()
          }
        },
        fail(res) {
          reject(res)
        }
      })
    })
  }
}
export default Tools</code></pre>

<p>之后将页面分成逻辑层和业务层：</p>

<p>逻辑层：在index同目录下新建extend.js，目的是进行数据操作</p>

<pre class="has"><code class="language-javascript">import tools from '../../utils/tool.js'
class Tools extends tools {
  constructor() {
    super()
  }
  getData(fn, method = 'get', url, data = {}) {//新建一个请求方法，在逻辑层执行一些操作
    this.axios(method, url, data)
      .then((res) =&gt; {
        fn(res)
      }).catch((err) =&gt; {
        fn(err)
      })
  }
}
export default Tools</code></pre>

<p>业务层：调用逻辑层的方法进行数据渲染</p>

<pre class="has"><code class="language-javascript">//获取应用实例
const app = getApp()
import Tools from './extend.js'
var tools = new Tools()//实例化方法
Page({
  /**
   * 页面的初始数据
   */
  data: {
    list: []
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    this.loadData()
  },
  loadData() {
    var that = this
    tools.getData(function(res) {//调用逻辑层的方法获取数据
      var list = that.data.list.concat(res)//连接数据进行懒加载
      that.setData({
        list
      })
    }, 'get', 'https://www.easy-mock.com/mock/5c6e58aa511c1f12334d8269/object/getData', {})
  },
  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function() {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function() {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function() {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function() {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function() {

  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function() {
    this.loadData()//触底时加载数据
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function() {

  }
})</code></pre>

<p>index.wxml:</p>

<pre class="has"><code class="language-html">&lt;view class='box'&gt;
  &lt;view wx:for='{{list}}' wx:key='{{item.name}}'&gt;{{item.name}}&lt;/view&gt;
&lt;/view&gt;</code></pre>

<p>&nbsp;</p>
                                    ]]></description></item><item><title>JS案例：简单的多级菜单实现</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/02/28/12438923.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 28 Feb 2019 09:27:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/02/28/12438923.html</guid><description><![CDATA[
                                            <h2>代码附上：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;多级联动&lt;/title&gt;
    &lt;style type="text/css"&gt;
        select,
        option {
            width: 100px;
            height: 50px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;select id='select1' name=""&gt;
        &lt;option value=""&gt;--省份--&lt;/option&gt;
    &lt;/select&gt;
    &lt;select id='select2' name=""&gt;
        &lt;option value=""&gt;--城市--&lt;/option&gt;
    &lt;/select&gt;
    &lt;select id='select3' name=""&gt;
        &lt;option value=""&gt;--县/区--&lt;/option&gt;
    &lt;/select&gt;
    &lt;script&gt;
        function GetArea(url) {
            this.url = url
            this.init()//初始化，入口函数
        }
        GetArea.prototype = {
            num: 0,//当前所在的下拉菜单
            selections: null,//选项框元素
            list: [],//数据列表
            createOptions(data, parent) {
                if (!parent) return
                if (parent.children) {//清空select中的子元素，避免数据叠加
                    var leng = parent.children.length
                    for (var j = 0; j &lt; leng - 1; j++) {
                        parent.lastElementChild.textContent = ''
                        parent.lastElementChild.remove()
                    }
                }
                for (var i = 0; i &lt; data.length; i++) {//新建option
                    var option = document.createElement('option');
                    option.textContent = data[i].name || data[i]
                    parent.appendChild(option)
                }
                parent.addEventListener('change', this.changeHandler);//当select发生改变时执行changeHandler
                parent.data = data//事件传递数据
                parent.self = this
            },
            init() {
                this.selections = document.querySelectorAll('select')//获取所有的select
                var xhr = new XMLHttpRequest();//Ajax请求
                xhr.addEventListener('load', this.loadHandler);
                xhr.open('get', this.url)
                xhr.send('')
                xhr.self = this
            },
            loadHandler(e) {
                this.self.list = JSON.parse(this.response)
                this.self.createOptions(this.self.list, this.self.selections[this.self.num])//当数据加载完成后执行创造option函数
            },
            changeHandler(e) {
                var list;
                this.data.forEach((item, val) =&gt; {//遍历查找选中的下一级列表
                    if (item.name === this.value) {
                        list = item.city ? item.city : item
                    }
                });
                this.self.selections.forEach((item, val) =&gt; {//判断选中第几级菜单，并且将数值赋给全局中的当前所在的下拉菜单
                    if (item.id === this.id) {
                        this.self.num = item.id.split('select')[1] - 1
                    }
                })
                if (this.self.num &gt; this.self.num) {//当选到最大的索引值时不执行下一级的渲染
                    return
                }
                this.self.num++//否则继续渲染下一级菜单
                this.self.createOptions(list, this.self.selections[this.self.num])
            }
        }
        var getArea = new GetArea('http://127.0.0.1:5500/city.json');
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>全国省市县json文件：</h2>

<pre class="has"><code class="language-javascript">[
    {
      "name": "北京市",
      "city": [
        {
          "name": "北京市",
          "city": [
            "东城区",
            "西城区",
            "崇文区",
            "宣武区",
            "朝阳区",
            "丰台区",
            "石景山区",
            "海淀区",
            "门头沟区",
            "房山区",
            "通州区",
            "顺义区",
            "昌平区",
            "大兴区",
            "平谷区",
            "怀柔区",
            "密云县",
            "延庆县"
          ]
        }
      ]
    },
    {
      "name": "天津市",
      "city": [
        {
          "name": "天津市",
          "city": [
            "和平区",
            "河东区",
            "河西区",
            "南开区",
            "河北区",
            "红桥区",
            "塘沽区",
            "汉沽区",
            "大港区",
            "东丽区",
            "西青区",
            "津南区",
            "北辰区",
            "武清区",
            "宝坻区",
            "宁河县",
            "静海县",
            "蓟  县"
          ]
        }
      ]
    },
    {
      "name": "河北省",
      "city": [
        {
          "name": "石家庄市",
          "city": [
            "长安区",
            "桥东区",
            "桥西区",
            "新华区",
            "郊  区",
            "井陉矿区",
            "井陉县",
            "正定县",
            "栾城县",
            "行唐县",
            "灵寿县",
            "高邑县",
            "深泽县",
            "赞皇县",
            "无极县",
            "平山县",
            "元氏县",
            "赵  县",
            "辛集市",
            "藁",
            "晋州市",
            "新乐市",
            "鹿泉市"
          ]
        },
        {
          "name": "唐山市",
          "city": [
            "路南区",
            "路北区",
            "古冶区",
            "开平区",
            "新  区",
            "丰润县",
            "滦  县",
            "滦南县",
            "乐亭县",
            "迁西县",
            "玉田县",
            "唐海县",
            "遵化市",
            "丰南市",
            "迁安市"
          ]
        },
        {
          "name": "秦皇岛市",
          "city": [
            "海港区",
            "山海关区",
            "北戴河区",
            "青龙满族自治县",
            "昌黎县",
            "抚宁县",
            "卢龙县"
          ]
        },
        {
          "name": "邯郸市",
          "city": [
            "邯山区",
            "丛台区",
            "复兴区",
            "峰峰矿区",
            "邯郸县",
            "临漳县",
            "成安县",
            "大名县",
            "涉  县",
            "磁  县",
            "肥乡县",
            "永年县",
            "邱  县",
            "鸡泽县",
            "广平县",
            "馆陶县",
            "魏  县",
            "曲周县",
            "武安市"
          ]
        },
        {
          "name": "邢台市",
          "city": [
            "桥东区",
            "桥西区",
            "邢台县",
            "临城县",
            "内丘县",
            "柏乡县",
            "隆尧县",
            "任  县",
            "南和县",
            "宁晋县",
            "巨鹿县",
            "新河县",
            "广宗县",
            "平乡县",
            "威  县",
            "清河县",
            "临西县",
            "南宫市",
            "沙河市"
          ]
        },
        {
          "name": "保定市",
          "city": [
            "新市区",
            "北市区",
            "南市区",
            "满城县",
            "清苑县",
            "涞水县",
            "阜平县",
            "徐水县",
            "定兴县",
            "唐  县",
            "高阳县",
            "容城县",
            "涞源县",
            "望都县",
            "安新县",
            "易  县",
            "曲阳县",
            "蠡  县",
            "顺平县",
            "博野",
            "雄县",
            "涿州市",
            "定州市",
            "安国市",
            "高碑店市"
          ]
        },
        {
          "name": "张家口",
          "city": [
            "桥东区",
            "桥西区",
            "宣化区",
            "下花园区",
            "宣化县",
            "张北县",
            "康保县",
            "沽源县",
            "尚义县",
            "蔚  县",
            "阳原县",
            "怀安县",
            "万全县",
            "怀来县",
            "涿鹿县",
            "赤城县",
            "崇礼县"
          ]
        },
        {
          "name": "承德市",
          "city": [
            "双桥区",
            "双滦区",
            "鹰手营子矿区",
            "承德县",
            "兴隆县",
            "平泉县",
            "滦平县",
            "隆化县",
            "丰宁满族自治县",
            "宽城满族自治县",
            "围场满族蒙古族自治县"
          ]
        },
        {
          "name": "沧州市",
          "city": [
            "新华区",
            "运河区",
            "沧  县",
            "青  县",
            "东光县",
            "海兴县",
            "盐山县",
            "肃宁县",
            "南皮县",
            "吴桥县",
            "献  县",
            "孟村回族自治县",
            "泊头市",
            "任丘市",
            "黄骅市",
            "河间市"
          ]
        },
        {
          "name": "廊坊市",
          "city": [
            "安次区",
            "固安县",
            "永清县",
            "香河县",
            "大城县",
            "文安县",
            "大厂回族自治县",
            "霸州市",
            "三河市"
          ]
        },
        {
          "name": "衡水市",
          "city": [
            "桃城区",
            "枣强县",
            "武邑县",
            "武强县",
            "饶阳县",
            "安平县",
            "故城县",
            "景  县",
            "阜城县",
            "冀州市",
            "深州市"
          ]
        }
      ]
    },
    {
      "name": "山西省",
      "city": [
        {
          "name": "太原市",
          "city": [
            "小店区",
            "迎泽区",
            "杏花岭区",
            "尖草坪区",
            "万柏林区",
            "晋源区",
            "清徐县",
            "阳曲县",
            "娄烦县",
            "古交市"
          ]
        },
        {
          "name": "大同市",
          "city": [
            "城  区",
            "矿  区",
            "南郊区",
            "新荣区",
            "阳高县",
            "天镇县",
            "广灵县",
            "灵丘县",
            "浑源县",
            "左云县",
            "大同县"
          ]
        },
        {
          "name": "阳泉市",
          "city": [
            "城  区",
            "矿  区",
            "郊  区",
            "平定县",
            "盂  县"
          ]
        },
        {
          "name": "长治市",
          "city": [
            "城  区",
            "郊  区",
            "长治县",
            "襄垣县",
            "屯留县",
            "平顺县",
            "黎城县",
            "壶关县",
            "长子县",
            "武乡县",
            "沁  县",
            "沁源县",
            "潞城市"
          ]
        },
        {
          "name": "晋城市",
          "city": [
            "城  区",
            "沁水县",
            "阳城县",
            "陵川县",
            "泽州县",
            "高平市"
          ]
        },
        {
          "name": "朔州市",
          "city": [
            "朔城区",
            "平鲁区",
            "山阴县",
            "应  县",
            "右玉县",
            "怀仁县"
          ]
        },
        {
          "name": "忻州市",
          "city": [
            "忻府区",
            "原平市",
            "定襄县",
            "五台县",
            "代  县",
            "繁峙县",
            "宁武县",
            "静乐县",
            "神池县",
            "五寨县",
            "岢岚县",
            "河曲县",
            "保德县",
            "偏关县"
          ]
        },
        {
          "name": "吕梁市",
          "city": [
            "离石区",
            "孝义市",
            "汾阳市",
            "文水县",
            "交城县",
            "兴  县",
            "临  县",
            "柳林县",
            "石楼县",
            "岚  县",
            "方山县",
            "中阳县",
            "交口县"
          ]
        },
        {
          "name": "晋中市",
          "city": [
            "榆次市",
            "介休市",
            "榆社县",
            "左权县",
            "和顺县",
            "昔阳县",
            "寿阳县",
            "太谷县",
            "祁  县",
            "平遥县",
            "灵石县"
          ]
        },
        {
          "name": "临汾市",
          "city": [
            "临汾市",
            "侯马市",
            "霍州市",
            "曲沃县",
            "翼城县",
            "襄汾县",
            "洪洞县",
            "古  县",
            "安泽县",
            "浮山县",
            "吉  县",
            "乡宁县",
            "蒲  县",
            "大宁县",
            "永和县",
            "隰  县",
            "汾西县"
          ]
        },
        {
          "name": "运城市",
          "city": [
            "运城市",
            "永济市",
            "河津市",
            "芮城县",
            "临猗县",
            "万荣县",
            "新绛县",
            "稷山县",
            "闻喜县",
            "夏  县",
            "绛  县",
            "平陆县",
            "垣曲县"
          ]
        }
      ]
    },
    {
      "name": "内蒙古",
      "city": [
        {
          "name": "呼和浩特市",
          "city": [
            "新城区",
            "回民区",
            "玉泉区",
            "郊  区",
            "土默特左旗",
            "托克托县",
            "和林格尔县",
            "清水河县",
            "武川县"
          ]
        },
        {
          "name": "包头市",
          "city": [
            "东河区",
            "昆都伦区",
            "青山区",
            "石拐矿区",
            "白云矿区",
            "郊  区",
            "土默特右旗",
            "固阳县",
            "达尔罕茂明安联合旗"
          ]
        },
        {
          "name": "乌海市",
          "city": [
            "海勃湾区",
            "海南区",
            "乌达区"
          ]
        },
        {
          "name": "赤峰市",
          "city": [
            "红山区",
            "元宝山区",
            "松山区",
            "阿鲁科尔沁旗",
            "巴林左旗",
            "巴林右旗",
            "林西县",
            "克什克腾旗",
            "翁牛特旗",
            "喀喇沁旗",
            "宁城县",
            "敖汉旗"
          ]
        },
        {
          "name": "呼伦贝尔市",
          "city": [
            "海拉尔市",
            "满洲里市",
            "扎兰屯市",
            "牙克石市",
            "根河市",
            "额尔古纳市",
            "阿荣旗",
            "莫力达瓦达斡尔族自治旗",
            "鄂伦春自治旗",
            "鄂温克族自治旗",
            "新巴尔虎右旗",
            "新巴尔虎左旗",
            "陈巴尔虎旗"
          ]
        },
        {
          "name": "兴安盟",
          "city": [
            "乌兰浩特市",
            "阿尔山市",
            "科尔沁右翼前旗",
            "科尔沁右翼中旗",
            "扎赉特旗",
            "突泉县"
          ]
        },
        {
          "name": "通辽市",
          "city": [
            "科尔沁区",
            "霍林郭勒市",
            "科尔沁左翼中旗",
            "科尔沁左翼后旗",
            "开鲁县",
            "库伦旗",
            "奈曼旗",
            "扎鲁特旗"
          ]
        },
        {
          "name": "锡林郭勒盟",
          "city": [
            "二连浩特市",
            "锡林浩特市",
            "阿巴嘎旗",
            "苏尼特左旗",
            "苏尼特右旗",
            "东乌珠穆沁旗",
            "西乌珠穆沁旗",
            "太仆寺旗",
            "镶黄旗",
            "正镶白旗",
            "正蓝旗",
            "多伦县"
          ]
        },
        {
          "name": "乌兰察布盟",
          "city": [
            "集宁市",
            "丰镇市",
            "卓资县",
            "化德县",
            "商都县",
            "兴和县",
            "凉城县",
            "察哈尔右翼前旗",
            "察哈尔右翼中旗",
            "察哈尔右翼后旗",
            "四子王旗"
          ]
        },
        {
          "name": "伊克昭盟",
          "city": [
            "东胜市",
            "达拉特旗",
            "准格尔旗",
            "鄂托克前旗",
            "鄂托克旗",
            "杭锦旗",
            "乌审旗",
            "伊金霍洛旗"
          ]
        },
        {
          "name": "巴彦淖尔盟",
          "city": [
            "临河市",
            "五原县",
            "磴口县",
            "乌拉特前旗",
            "乌拉特中旗",
            "乌拉特后旗",
            "杭锦后旗"
          ]
        },
        {
          "name": "阿拉善盟",
          "city": [
            "阿拉善左旗",
            "阿拉善右旗",
            "额济纳旗"
          ]
        }
      ]
    },
    {
      "name": "辽宁省",
      "city": [
        {
          "name": "沈阳市",
          "city": [
            "沈河区",
            "皇姑区",
            "和平区",
            "大东区",
            "铁西区",
            "苏家屯区",
            "东陵区",
            "于洪区",
            "新民市",
            "法库县",
            "辽中县",
            "康平县",
            "新城子区"
          ]
        },
        {
          "name": "大连市",
          "city": [
            "西岗区",
            "中山区",
            "沙河口区",
            "甘井子区",
            "旅顺口区",
            "金州区",
            "瓦房店市",
            "普兰店市",
            "庄河市",
            "长海县"
          ]
        },
        {
          "name": "鞍山市",
          "city": [
            "铁东区",
            "铁西区",
            "立山区",
            "千山区",
            "海城市",
            "台安县",
            "岫岩满族自治县"
          ]
        },
        {
          "name": "抚顺市",
          "city": [
            "顺城区",
            "新抚区",
            "东洲区",
            "望花区",
            "抚顺县",
            "清原满族自治县",
            "新宾满族自治县"
          ]
        },
        {
          "name": "本溪市",
          "city": [
            "平山区",
            "明山区",
            "溪湖区",
            "南芬区",
            "本溪满族自治县",
            "桓仁满族自治县"
          ]
        },
        {
          "name": "丹东市",
          "city": [
            "振兴区",
            "元宝区",
            "振安区",
            "东港市",
            "凤城市",
            "宽甸满族自治县"
          ]
        },
        {
          "name": "锦州市",
          "city": [
            "太和区",
            "古塔区",
            "凌河区",
            "凌海市",
            "黑山县",
            "义县",
            "北宁市"
          ]
        },
        {
          "name": "营口市",
          "city": [
            "站前区",
            "西市区",
            "鲅鱼圈区",
            "老边区",
            "大石桥市",
            "盖州市"
          ]
        },
        {
          "name": "阜新市",
          "city": [
            "海州区",
            "新邱区",
            "太平区",
            "清河门区",
            "细河区",
            "彰武县",
            "阜新蒙古族自治县"
          ]
        },
        {
          "name": "辽阳市",
          "city": [
            "白塔区",
            "文圣区",
            "宏伟区",
            "太子河区",
            "弓长岭区",
            "灯塔市",
            "辽阳县"
          ]
        },
        {
          "name": "盘锦",
          "city": [
            "双台子区",
            "兴隆台区",
            "盘山县",
            "大洼县"
          ]
        },
        {
          "name": "铁岭市",
          "city": [
            "银州区",
            "清河区",
            "调兵山市",
            "开原市",
            "铁岭县",
            "昌图县",
            "西丰县"
          ]
        },
        {
          "name": "朝阳市",
          "city": [
            "双塔区",
            "龙城区",
            "凌源市",
            "北票市",
            "朝阳县",
            "建平县",
            "喀喇沁左翼蒙古族自治县"
          ]
        },
        {
          "name": "葫芦岛市",
          "city": [
            "龙港区",
            "南票区",
            "连山区",
            "兴城市",
            "绥中县",
            "建昌县"
          ]
        }
      ]
    },
    {
      "name": "吉林省",
      "city": [
        {
          "name": "长春市",
          "city": [
            "朝阳区",
            "宽城区",
            "二道区",
            "南关区",
            "绿园区",
            "双阳区",
            "九台市",
            "榆树市",
            "德惠市",
            "农安县"
          ]
        },
        {
          "name": "吉林市",
          "city": [
            "船营区",
            "昌邑区",
            "龙潭区",
            "丰满区",
            "舒兰市",
            "桦甸市",
            "蛟河市",
            "磐石市",
            "永吉县"
          ]
        },
        {
          "name": "四平",
          "city": [
            "铁西区",
            "铁东区",
            "公主岭市",
            "双辽市",
            "梨树县",
            "伊通满族自治县"
          ]
        },
        {
          "name": "辽源市",
          "city": [
            "龙山区",
            "西安区",
            "东辽县",
            "东丰县"
          ]
        },
        {
          "name": "通化市",
          "city": [
            "东昌区",
            "二道江区",
            "梅河口市",
            "集安市",
            "通化县",
            "辉南县",
            "柳河县"
          ]
        },
        {
          "name": "白山市",
          "city": [
            "八道江区",
            "江源区",
            "临江市",
            "靖宇县",
            "抚松县",
            "长白朝鲜族自治县"
          ]
        },
        {
          "name": "松原市",
          "city": [
            "宁江区",
            "乾安县",
            "长岭县",
            "扶余县",
            "前郭尔罗斯蒙古族自治县"
          ]
        },
        {
          "name": "白城市",
          "city": [
            "洮北区",
            "大安市",
            "洮南市",
            "镇赉县",
            "通榆县"
          ]
        },
        {
          "name": "延边朝鲜族自治州",
          "city": [
            "延吉市",
            "图们市",
            "敦化市",
            "龙井市",
            "珲春市",
            "和龙市",
            "安图县",
            "汪清县"
          ]
        }
      ]
    },
    {
      "name": "黑龙江省",
      "city": [
        {
          "name": "哈尔滨市",
          "city": [
            "松北区",
            "道里区",
            "南岗区",
            "平房区",
            "香坊区",
            "道外区",
            "呼兰区",
            "阿城区",
            "双城市",
            "尚志市",
            "五常市",
            "宾县",
            "方正县",
            "通河县",
            "巴彦县",
            "延寿县",
            "木兰县",
            "依兰县"
          ]
        },
        {
          "name": "齐齐哈尔市",
          "city": [
            "龙沙区",
            "昂昂溪区",
            "铁锋区",
            "建华区",
            "富拉尔基区",
            "碾子山区",
            "梅里斯达斡尔族区",
            "讷河市",
            "富裕县",
            "拜泉县",
            "甘南县",
            "依安县",
            "克山县",
            "泰来县",
            "克东县",
            "龙江县"
          ]
        },
        {
          "name": "鹤岗市",
          "city": [
            "兴山区",
            "工农区",
            "南山区",
            "兴安区",
            "向阳区",
            "东山区",
            "萝北县",
            "绥滨县"
          ]
        },
        {
          "name": "双鸭山",
          "city": [
            "尖山区",
            "岭东区",
            "四方台区",
            "宝山区",
            "集贤县",
            "宝清县",
            "友谊县",
            "饶河县"
          ]
        },
        {
          "name": "鸡西市",
          "city": [
            "鸡冠区",
            "恒山区",
            "城子河区",
            "滴道区",
            "梨树区",
            "麻山区",
            "密山市",
            "虎林市",
            "鸡东县"
          ]
        },
        {
          "name": "大庆市",
          "city": [
            "萨尔图区",
            "红岗区",
            "龙凤区",
            "让胡路区",
            "大同区",
            "林甸县",
            "肇州县",
            "肇源县",
            "杜尔伯特蒙古族自治县"
          ]
        },
        {
          "name": "伊春市",
          "city": [
            "伊春区",
            "带岭区",
            "南岔区",
            "金山屯区",
            "西林区",
            "美溪区",
            "乌马河区",
            "翠峦区",
            "友好区",
            "上甘岭区",
            "五营区",
            "红星区",
            "新青区",
            "汤旺河区",
            "乌伊岭区",
            "铁力市",
            "嘉荫县"
          ]
        },
        {
          "name": "牡丹江市",
          "city": [
            "爱民区",
            "东安区",
            "阳明区",
            "西安区",
            "绥芬河市",
            "宁安市",
            "海林市",
            "穆棱市",
            "林口县",
            "东宁县"
          ]
        },
        {
          "name": "佳木斯市",
          "city": [
            "向阳区",
            "前进区",
            "东风区",
            "郊区",
            "同江市",
            "富锦市",
            "桦川县",
            "抚远县",
            "桦南县",
            "汤原县"
          ]
        },
        {
          "name": "七台河市",
          "city": [
            "桃山区",
            "新兴区",
            "茄子河区",
            "勃利县"
          ]
        },
        {
          "name": "黑河市",
          "city": [
            "爱辉区",
            "北安市",
            "五大连池市",
            "逊克县",
            "嫩江县",
            "孙吴县"
          ]
        },
        {
          "name": "绥化市",
          "city": [
            "北林区",
            "安达市",
            "肇东市",
            "海伦市",
            "绥棱县",
            "兰西县",
            "明水县",
            "青冈县",
            "庆安县",
            "望奎县"
          ]
        },
        {
          "name": "大兴安岭地区",
          "city": [
            "呼玛县",
            "塔河县",
            "漠河县",
            "大兴安岭辖区"
          ]
        }
      ]
    },
    {
      "name": "上海市",
      "city": [
        {
          "name": "上海市",
          "city": [
            "黄浦区",
            "卢湾区",
            "徐汇区",
            "长宁区",
            "静安区",
            "普陀区",
            "闸北区",
            "虹口区",
            "杨浦区",
            "宝山区",
            "闵行区",
            "嘉定区",
            "松江区",
            "金山区",
            "青浦区",
            "南汇区",
            "奉贤区",
            "浦东新区",
            "崇明县"
          ]
        }
      ]
    },
    {
      "name": "江苏省",
      "city": [
        {
          "name": "南京市",
          "city": [
            "玄武区",
            "白下区",
            "秦淮区",
            "建邺区",
            "鼓楼区",
            "下关区",
            "栖霞区",
            "雨花台区",
            "浦口区",
            "江宁区",
            "六合区",
            "溧水县",
            "高淳县"
          ]
        },
        {
          "name": "苏州市",
          "city": [
            "金阊区",
            "平江区",
            "沧浪区",
            "虎丘区",
            "吴中区",
            "相城区",
            "常熟市",
            "张家港市",
            "昆山市",
            "吴江市",
            "太仓市"
          ]
        },
        {
          "name": "无锡市",
          "city": [
            "崇安区",
            "南长区",
            "北塘区",
            "滨湖区",
            "锡山区",
            "惠山区",
            "江阴市",
            "宜兴市"
          ]
        },
        {
          "name": "常州市",
          "city": [
            "钟楼区",
            "天宁区",
            "戚墅堰区",
            "新北区",
            "武进区",
            "金坛市",
            "溧阳市"
          ]
        },
        {
          "name": "镇江市",
          "city": [
            "京口区",
            "润州区",
            "丹徒区",
            "丹阳市",
            "扬中市",
            "句容市"
          ]
        },
        {
          "name": "南通市",
          "city": [
            "崇川区",
            "港闸区",
            "通州市",
            "如皋市",
            "海门市",
            "启东市",
            "海安县",
            "如东县"
          ]
        },
        {
          "name": "泰州市",
          "city": [
            "海陵区",
            "高港区",
            "姜堰市",
            "泰兴市",
            "靖江市",
            "兴化市"
          ]
        },
        {
          "name": "扬州市",
          "city": [
            "广陵区",
            "维扬区",
            "邗江区",
            "江都市",
            "仪征市",
            "高邮市",
            "宝应县"
          ]
        },
        {
          "name": "盐城市",
          "city": [
            "亭湖区",
            "盐都区",
            "大丰市",
            "东台市",
            "建湖县",
            "射阳县",
            "阜宁县",
            "滨海县",
            "响水县"
          ]
        },
        {
          "name": "连云港市",
          "city": [
            "新浦区",
            "海州区",
            "连云区",
            "东海县",
            "灌云县",
            "赣榆县",
            "灌南县"
          ]
        },
        {
          "name": "徐州市",
          "city": [
            "云龙区",
            "鼓楼区",
            "九里区",
            "泉山区",
            "贾汪区",
            "邳州市",
            "新沂市",
            "铜山县",
            "睢宁县",
            "沛县",
            "丰县"
          ]
        },
        {
          "name": "淮安市",
          "city": [
            "清河区",
            "清浦区",
            "楚州区",
            "淮阴区",
            "涟水县",
            "洪泽县",
            "金湖县",
            "盱眙县"
          ]
        },
        {
          "name": "宿迁市",
          "city": [
            "宿城区",
            "宿豫区",
            "沭阳县",
            "泗阳县",
            "泗洪县"
          ]
        }
      ]
    },
    {
      "name": "浙江省",
      "city": [
        {
          "name": "杭州市",
          "city": [
            "拱墅区",
            "西湖区",
            "上城区",
            "下城区",
            "江干区",
            "滨江区",
            "余杭区",
            "萧山区",
            "建德市",
            "富阳市",
            "临安市",
            "桐庐县",
            "淳安县"
          ]
        },
        {
          "name": "宁波市",
          "city": [
            "海曙区",
            "江东区",
            "江北区",
            "镇海区",
            "北仑区",
            "鄞州区",
            "余姚市",
            "慈溪市",
            "奉化市",
            "宁海县",
            "象山县"
          ]
        },
        {
          "name": "温州市",
          "city": [
            "鹿城区",
            "龙湾区",
            "瓯海区",
            "瑞安市",
            "乐清市",
            "永嘉县",
            "洞头县",
            "平阳县",
            "苍南县",
            "文成县",
            "泰顺县"
          ]
        },
        {
          "name": "嘉兴市",
          "city": [
            "秀城区",
            "秀洲区",
            "海宁市",
            "平湖市",
            "桐乡市",
            "嘉善县",
            "海盐县"
          ]
        },
        {
          "name": "湖州市",
          "city": [
            "吴兴区",
            "南浔区",
            "长兴县",
            "德清县",
            "安吉县"
          ]
        },
        {
          "name": "绍兴市",
          "city": [
            "越城区",
            "诸暨市",
            "上虞市",
            "嵊州市",
            "绍兴县",
            "新昌县"
          ]
        },
        {
          "name": "金华市",
          "city": [
            "婺城区",
            "金东区",
            "兰溪市",
            "义乌市",
            "东阳市",
            "永康市",
            "武义县",
            "浦江县",
            "磐安县"
          ]
        },
        {
          "name": "衢州市",
          "city": [
            "柯城区",
            "衢江区",
            "江山市",
            "龙游县",
            "常山县",
            "开化县"
          ]
        },
        {
          "name": "舟山市",
          "city": [
            "定海区",
            "普陀区",
            "岱山县",
            "嵊泗县"
          ]
        },
        {
          "name": "台州市",
          "city": [
            "椒江区",
            "黄岩区",
            "路桥区",
            "临海市",
            "温岭市",
            "玉环县",
            "天台县",
            "仙居县",
            "三门县"
          ]
        },
        {
          "name": "丽水市",
          "city": [
            "莲都区",
            "龙泉市",
            "缙云县",
            "青田县",
            "云和县",
            "遂昌县",
            "松阳县",
            "庆元县",
            "景宁畲族自治县"
          ]
        }
      ]
    },
    {
      "name": "安徽省",
      "city": [
        {
          "name": "合肥市",
          "city": [
            "庐阳区",
            "瑶海区",
            "蜀山区",
            "包河区",
            "长丰县",
            "肥东县",
            "肥西县"
          ]
        },
        {
          "name": "芜湖市",
          "city": [
            "镜湖区",
            "弋江区",
            "鸠江区",
            "三山区",
            "芜湖县",
            "南陵县",
            "繁昌县"
          ]
        },
        {
          "name": "蚌埠市",
          "city": [
            "蚌山区",
            "龙子湖区",
            "禹会区",
            "淮上区",
            "怀远县",
            "固镇县",
            "五河县"
          ]
        },
        {
          "name": "淮南市",
          "city": [
            "田家庵区",
            "大通区",
            "谢家集区",
            "八公山区",
            "潘集区",
            "凤台县"
          ]
        },
        {
          "name": "马鞍山市",
          "city": [
            "雨山区",
            "花山区",
            "金家庄区",
            "当涂县"
          ]
        },
        {
          "name": "淮北市",
          "city": [
            "相山区",
            "杜集区",
            "烈山区",
            "濉溪县"
          ]
        },
        {
          "name": "铜陵市",
          "city": [
            "铜官山区",
            "狮子山区",
            "郊区",
            "铜陵县"
          ]
        },
        {
          "name": "安庆市",
          "city": [
            "迎江区",
            "大观区",
            "宜秀区",
            "桐城市",
            "宿松县",
            "枞阳县",
            "太湖县",
            "怀宁县",
            "岳西县",
            "望江县",
            "潜山县"
          ]
        },
        {
          "name": "黄山市",
          "city": [
            "屯溪区",
            "黄山区",
            "徽州区",
            "休宁县",
            "歙县",
            "祁门县",
            "黟县"
          ]
        },
        {
          "name": "滁州市",
          "city": [
            "琅琊区",
            "南谯区",
            "天长市",
            "明光市",
            "全椒县",
            "来安县",
            "定远县",
            "凤阳县"
          ]
        },
        {
          "name": "阜阳市",
          "city": [
            "颍州区",
            "颍东区",
            "颍泉区",
            "界首市",
            "临泉县",
            "颍上县",
            "阜南县",
            "太和县"
          ]
        },
        {
          "name": "宿州市",
          "city": [
            "埇桥区",
            "萧县",
            "泗县",
            "砀山县",
            "灵璧县"
          ]
        },
        {
          "name": "巢湖市",
          "city": [
            "居巢区",
            "含山县",
            "无为县",
            "庐江县",
            "和县"
          ]
        },
        {
          "name": "六安市",
          "city": [
            "金安区",
            "裕安区",
            "寿县",
            "霍山县",
            "霍邱县",
            "舒城县",
            "金寨县"
          ]
        },
        {
          "name": "亳州市",
          "city": [
            "谯城区",
            "利辛县",
            "涡阳县",
            "蒙城县"
          ]
        },
        {
          "name": "池州市",
          "city": [
            "贵池区",
            "东至县",
            "石台县",
            "青阳县"
          ]
        },
        {
          "name": "宣城市",
          "city": [
            "宣州区",
            "宁国市",
            "广德县",
            "郎溪县",
            "泾县",
            "旌德县",
            "绩溪县"
          ]
        }
      ]
    },
    {
      "name": "福建省",
      "city": [
        {
          "name": "福州市",
          "city": [
            "鼓楼区",
            "台江区",
            "仓山区",
            "马尾区",
            "晋安区",
            "福清市",
            "长乐市",
            "闽侯县",
            "闽清县",
            "永泰县",
            "连江县",
            "罗源县",
            "平潭县"
          ]
        },
        {
          "name": "厦门市",
          "city": [
            "思明区",
            "海沧区",
            "湖里区",
            "集美区",
            "同安区",
            "翔安区"
          ]
        },
        {
          "name": "莆田市",
          "city": [
            "城厢区",
            "涵江区",
            "荔城区",
            "秀屿区",
            "仙游县"
          ]
        },
        {
          "name": "三明市",
          "city": [
            "梅列区",
            "三元区",
            "永安市",
            "明溪县",
            "将乐县",
            "大田县",
            "宁化县",
            "建宁县",
            "沙县",
            "尤溪县",
            "清流县",
            "泰宁县"
          ]
        },
        {
          "name": "泉州市",
          "city": [
            "鲤城区",
            "丰泽区",
            "洛江区",
            "泉港区",
            "石狮市",
            "晋江市",
            "南安市",
            "惠安县",
            "永春县",
            "安溪县",
            "德化县",
            "金门县"
          ]
        },
        {
          "name": "漳州市",
          "city": [
            "芗城区",
            "龙文区",
            "龙海市",
            "平和县",
            "南靖县",
            "诏安县",
            "漳浦县",
            "华安县",
            "东山县",
            "长泰县",
            "云霄县"
          ]
        },
        {
          "name": "南平市",
          "city": [
            "延平区",
            "建瓯市",
            "邵武市",
            "武夷山市",
            "建阳市",
            "松溪县",
            "光泽县",
            "顺昌县",
            "浦城县",
            "政和县"
          ]
        },
        {
          "name": "龙岩市",
          "city": [
            "新罗区",
            "漳平市",
            "长汀县",
            "武平县",
            "上杭县",
            "永定县",
            "连城县"
          ]
        },
        {
          "name": "宁德市",
          "city": [
            "蕉城区",
            "福安市",
            "福鼎市",
            "寿宁县",
            "霞浦县",
            "柘荣县",
            "屏南县",
            "古田县",
            "周宁县"
          ]
        }
      ]
    },
    {
      "name": "江西省",
      "city": [
        {
          "name": "南昌市",
          "city": [
            "东湖区",
            "西湖区",
            "青云谱区",
            "湾里区",
            "青山湖区",
            "新建县",
            "南昌县",
            "进贤县",
            "安义县"
          ]
        },
        {
          "name": "景德镇市",
          "city": [
            "珠山区",
            "昌江区",
            "乐平市",
            "浮梁县"
          ]
        },
        {
          "name": "萍乡市",
          "city": [
            "安源区",
            "湘东区",
            "莲花县",
            "上栗县",
            "芦溪县"
          ]
        },
        {
          "name": "九江市",
          "city": [
            "浔阳区",
            "庐山区",
            "瑞昌市",
            "九江县",
            "星子县",
            "武宁县",
            "彭泽县",
            "永修县",
            "修水县",
            "湖口县",
            "德安县",
            "都昌县"
          ]
        },
        {
          "name": "新余市",
          "city": [
            "渝水区",
            "分宜县"
          ]
        },
        {
          "name": "鹰潭市",
          "city": [
            "月湖区",
            "贵溪市",
            "余江县"
          ]
        },
        {
          "name": "赣州市",
          "city": [
            "章贡区",
            "瑞金市",
            "南康市",
            "石城县",
            "安远县",
            "赣县",
            "宁都县",
            "寻乌县",
            "兴国县",
            "定南县",
            "上犹县",
            "于都县",
            "龙南县",
            "崇义县",
            "信丰县",
            "全南县",
            "大余县",
            "会昌县"
          ]
        },
        {
          "name": "吉安市",
          "city": [
            "吉州区",
            "青原区",
            "井冈山市",
            "吉安县",
            "永丰县",
            "永新县",
            "新干县",
            "泰和县",
            "峡江县",
            "遂川县",
            "安福县",
            "吉水县",
            "万安县"
          ]
        },
        {
          "name": "宜春市",
          "city": [
            "袁州区",
            "丰城市",
            "樟树市",
            "高安市",
            "铜鼓县",
            "靖安县",
            "宜丰县",
            "奉新县",
            "万载县",
            "上高县"
          ]
        },
        {
          "name": "抚州市",
          "city": [
            "临川区",
            "南丰县",
            "乐安县",
            "金溪县",
            "南城县",
            "东乡县",
            "资溪县",
            "宜黄县",
            "广昌县",
            "黎川县",
            "崇仁县"
          ]
        },
        {
          "name": "上饶市",
          "city": [
            "信州区",
            "德兴市",
            "上饶县",
            "广丰县",
            "鄱阳县",
            "婺源县",
            "铅山县",
            "余干县",
            "横峰县",
            "弋阳县",
            "玉山县",
            "万年县"
          ]
        }
      ]
    },
    {
      "name": "山东省",
      "city": [
        {
          "name": "济南市",
          "city": [
            "市中区",
            "历下区",
            "天桥区",
            "槐荫区",
            "历城区",
            "长清区",
            "章丘市",
            "平阴县",
            "济阳县",
            "商河县"
          ]
        },
        {
          "name": "青岛市",
          "city": [
            "市南区",
            "市北区",
            "城阳区",
            "四方区",
            "李沧区",
            "黄岛区",
            "崂山区",
            "胶南市",
            "胶州市",
            "平度市",
            "莱西市",
            "即墨市"
          ]
        },
        {
          "name": "淄博市",
          "city": [
            "张店区",
            "临淄区",
            "淄川区",
            "博山区",
            "周村区",
            "桓台县",
            "高青县",
            "沂源县"
          ]
        },
        {
          "name": "枣庄市",
          "city": [
            "市中区",
            "山亭区",
            "峄城区",
            "台儿庄区",
            "薛城区",
            "滕州市"
          ]
        },
        {
          "name": "东营市",
          "city": [
            "东营区",
            "河口区",
            "垦利县",
            "广饶县",
            "利津县"
          ]
        },
        {
          "name": "烟台市",
          "city": [
            "芝罘区",
            "福山区",
            "牟平区",
            "莱山区",
            "龙口市",
            "莱阳市",
            "莱州市",
            "招远市",
            "蓬莱市",
            "栖霞市",
            "海阳市",
            "长岛县"
          ]
        },
        {
          "name": "潍坊市",
          "city": [
            "潍城区",
            "寒亭区",
            "坊子区",
            "奎文区",
            "青州市",
            "诸城市",
            "寿光市",
            "安丘市",
            "高密市",
            "昌邑市",
            "昌乐县",
            "临朐县"
          ]
        },
        {
          "name": "济宁市",
          "city": [
            "市中区",
            "任城区",
            "曲阜市",
            "兖州市",
            "邹城市",
            "鱼台县",
            "金乡县",
            "嘉祥县",
            "微山县",
            "汶上县",
            "泗水县",
            "梁山县"
          ]
        },
        {
          "name": "泰安市",
          "city": [
            "泰山区",
            "岱岳区",
            "新泰市",
            "肥城市",
            "宁阳县",
            "东平县"
          ]
        },
        {
          "name": "威海市",
          "city": [
            "环翠区",
            "乳山市",
            "文登市",
            "荣成市"
          ]
        },
        {
          "name": "日照市",
          "city": [
            "东港区",
            "岚山区",
            "五莲县",
            "莒县"
          ]
        },
        {
          "name": "莱芜市",
          "city": [
            "莱城区",
            "钢城区"
          ]
        },
        {
          "name": "临沂市",
          "city": [
            "兰山区",
            "罗庄区",
            "河东区",
            "沂南县",
            "郯城县",
            "沂水县",
            "苍山县",
            "费县",
            "平邑县",
            "莒南县",
            "蒙阴县",
            "临沭县"
          ]
        },
        {
          "name": "德州市",
          "city": [
            "德城区",
            "乐陵市",
            "禹城市",
            "陵县",
            "宁津县",
            "齐河县",
            "武城县",
            "庆云县",
            "平原县",
            "夏津县",
            "临邑县"
          ]
        },
        {
          "name": "聊城市",
          "city": [
            "东昌府区",
            "临清市",
            "高唐县",
            "阳谷县",
            "茌平县",
            "莘县",
            "东阿县",
            "冠县"
          ]
        },
        {
          "name": "滨州市",
          "city": [
            "滨城区",
            "邹平县",
            "沾化县",
            "惠民县",
            "博兴县",
            "阳信县",
            "无棣县"
          ]
        },
        {
          "name": "菏泽市",
          "city": [
            "牡丹区",
            "鄄城县",
            "单县",
            "郓城县",
            "曹县",
            "定陶县",
            "巨野县",
            "东明县",
            "成武县"
          ]
        }
      ]
    },
    {
      "name": "河南省",
      "city": [
        {
          "name": "郑州市",
          "city": [
            "中原区",
            "金水区",
            "二七区",
            "管城回族区",
            "上街区",
            "惠济区",
            "巩义市",
            "新郑市",
            "新密市",
            "登封市",
            "荥阳市",
            "中牟县"
          ]
        },
        {
          "name": "开封市",
          "city": [
            "鼓楼区",
            "龙亭区",
            "顺河回族区",
            "禹王台区",
            "金明区",
            "开封县",
            "尉氏县",
            "兰考县",
            "杞县",
            "通许县"
          ]
        },
        {
          "name": "洛阳市",
          "city": [
            "西工区",
            "老城区",
            "涧西区",
            "瀍河回族区",
            "洛龙区",
            "吉利区",
            "偃师市",
            "孟津县",
            "汝阳县",
            "伊川县",
            "洛宁县",
            "嵩县",
            "宜阳县",
            "新安县",
            "栾川县"
          ]
        },
        {
          "name": "平顶山市",
          "city": [
            "新华区",
            "卫东区",
            "湛河区",
            "石龙区",
            "汝州市",
            "舞钢市",
            "宝丰县",
            "叶县",
            "郏县",
            "鲁山县"
          ]
        },
        {
          "name": "安阳市",
          "city": [
            "北关区",
            "文峰区",
            "殷都区",
            "龙安区",
            "林州市",
            "安阳县",
            "滑县",
            "内黄县",
            "汤阴县"
          ]
        },
        {
          "name": "鹤壁市",
          "city": [
            "淇滨区",
            "山城区",
            "鹤山区",
            "浚县",
            "淇县"
          ]
        },
        {
          "name": "新乡市",
          "city": [
            "卫滨区",
            "红旗区",
            "凤泉区",
            "牧野区",
            "卫辉市",
            "辉县市",
            "新乡县",
            "获嘉县",
            "原阳县",
            "长垣县",
            "封丘县",
            "延津县"
          ]
        },
        {
          "name": "焦作市",
          "city": [
            "解放区",
            "中站区",
            "马村区",
            "山阳区",
            "沁阳市",
            "孟州市",
            "修武县",
            "温县",
            "武陟县",
            "博爱县"
          ]
        },
        {
          "name": "濮阳市",
          "city": [
            "华龙区",
            "濮阳县",
            "南乐县",
            "台前县",
            "清丰县",
            "范县"
          ]
        },
        {
          "name": "许昌市",
          "city": [
            "魏都区",
            "禹州市",
            "长葛市",
            "许昌县",
            "鄢陵县",
            "襄城县"
          ]
        },
        {
          "name": "漯河市",
          "city": [
            "源汇区",
            "郾城区",
            "召陵区",
            "临颍县",
            "舞阳县"
          ]
        },
        {
          "name": "三门峡市",
          "city": [
            "湖滨区",
            "义马市",
            "灵宝市",
            "渑池县",
            "卢氏县",
            "陕县"
          ]
        },
        {
          "name": "南阳市",
          "city": [
            "卧龙区",
            "宛城区",
            "邓州市",
            "桐柏县",
            "方城县",
            "淅川县",
            "镇平县",
            "唐河县",
            "南召县",
            "内乡县",
            "新野县",
            "社旗县",
            "西峡县"
          ]
        },
        {
          "name": "商丘市",
          "city": [
            "梁园区",
            "睢阳区",
            "永城市",
            "宁陵县",
            "虞城县",
            "民权县",
            "夏邑县",
            "柘城县",
            "睢县"
          ]
        },
        {
          "name": "信阳市",
          "city": [
            "浉河区",
            "平桥区",
            "潢川县",
            "淮滨县",
            "息县",
            "新县",
            "商城县",
            "固始县",
            "罗山县",
            "光山县"
          ]
        },
        {
          "name": "周口市",
          "city": [
            "川汇区",
            "项城市",
            "商水县",
            "淮阳县",
            "太康县",
            "鹿邑县",
            "西华县",
            "扶沟县",
            "沈丘县",
            "郸城县"
          ]
        },
        {
          "name": "驻马店市",
          "city": [
            "驿城区",
            "确山县",
            "新蔡县",
            "上蔡县",
            "西平县",
            "泌阳县",
            "平舆县",
            "汝南县",
            "遂平县",
            "正阳县"
          ]
        },
        {
          "name": "焦作市",
          "city": [
            "济源市"
          ]
        }
      ]
    },
    {
      "name": "湖北省",
      "city": [
        {
          "name": "武汉市",
          "city": [
            "江岸区",
            "武昌区",
            "江汉区",
            "硚口区",
            "汉阳区",
            "青山区",
            "洪山区",
            "东西湖区",
            "汉南区",
            "蔡甸区",
            "江夏区",
            "黄陂区",
            "新洲区"
          ]
        },
        {
          "name": "黄石市",
          "city": [
            "黄石港区",
            "西塞山区",
            "下陆区",
            "铁山区",
            "大冶市",
            "阳新县"
          ]
        },
        {
          "name": "十堰市",
          "city": [
            "张湾区",
            "茅箭区",
            "丹江口市",
            "郧县",
            "竹山县",
            "房县",
            "郧西县",
            "竹溪县"
          ]
        },
        {
          "name": "荆州市",
          "city": [
            "沙市区",
            "荆州区",
            "洪湖市",
            "石首市",
            "松滋市",
            "监利县",
            "公安县",
            "江陵县"
          ]
        },
        {
          "name": "宜昌市",
          "city": [
            "西陵区",
            "伍家岗区",
            "点军区",
            "猇亭区",
            "夷陵区",
            "宜都市",
            "当阳市",
            "枝江市",
            "秭归县",
            "远安县",
            "兴山县",
            "五峰土家族自治县",
            "长阳土家族自治县"
          ]
        },
        {
          "name": "襄樊市",
          "city": [
            "襄城区",
            "樊城区",
            "襄阳区",
            "老河口市",
            "枣阳市",
            "宜城市",
            "南漳县",
            "谷城县",
            "保康县"
          ]
        },
        {
          "name": "鄂州市",
          "city": [
            "鄂城区",
            "华容区",
            "梁子湖区"
          ]
        },
        {
          "name": "荆门市",
          "city": [
            "东宝区",
            "掇刀区",
            "钟祥市",
            "京山县",
            "沙洋县"
          ]
        },
        {
          "name": "孝感市",
          "city": [
            "孝南区",
            "应城市",
            "安陆市",
            "汉川市",
            "云梦县",
            "大悟县",
            "孝昌县"
          ]
        },
        {
          "name": "黄冈市",
          "city": [
            "黄州区",
            "麻城市",
            "武穴市",
            "红安县",
            "罗田县",
            "浠水县",
            "蕲春县",
            "黄梅县",
            "英山县",
            "团风县"
          ]
        },
        {
          "name": "咸宁市",
          "city": [
            "咸安区",
            "赤壁市",
            "嘉鱼县",
            "通山县",
            "崇阳县",
            "通城县"
          ]
        },
        {
          "name": "随州市",
          "city": [
            "曾都区",
            "广水市"
          ]
        },
        {
          "name": "恩施土家族苗族自治州",
          "city": [
            "恩施市",
            "利川市",
            "建始县",
            "来凤县",
            "巴东县",
            "鹤峰县",
            "宣恩县",
            "咸丰县"
          ]
        },
        {
          "name": "仙桃市",
          "city": [
            "仙桃"
          ]
        },
        {
          "name": "天门市",
          "city": [
            "天门"
          ]
        },
        {
          "name": "潜江市",
          "city": [
            "潜江"
          ]
        },
        {
          "name": "神农架林区",
          "city": [
            "神农架林区"
          ]
        }
      ]
    },
    {
      "name": "湖南省",
      "city": [
        {
          "name": "长沙市",
          "city": [
            "岳麓区",
            "芙蓉区",
            "天心区",
            "开福区",
            "雨花区",
            "浏阳市",
            "长沙县",
            "望城县",
            "宁乡县"
          ]
        },
        {
          "name": "株洲市",
          "city": [
            "天元区",
            "荷塘区",
            "芦淞区",
            "石峰区",
            "醴陵市",
            "株洲县",
            "炎陵县",
            "茶陵县",
            "攸县"
          ]
        },
        {
          "name": "湘潭市",
          "city": [
            "岳塘区",
            "雨湖区",
            "湘乡市",
            "韶山市",
            "湘潭县"
          ]
        },
        {
          "name": "衡阳市",
          "city": [
            "雁峰区",
            "珠晖区",
            "石鼓区",
            "蒸湘区",
            "南岳区",
            "耒阳市",
            "常宁市",
            "衡阳县",
            "衡东县",
            "衡山县",
            "衡南县",
            "祁东县"
          ]
        },
        {
          "name": "邵阳市",
          "city": [
            "双清区",
            "大祥区",
            "北塔区",
            "武冈市",
            "邵东县",
            "洞口县",
            "新邵县",
            "绥宁县",
            "新宁县",
            "邵阳县",
            "隆回县",
            "城步苗族自治县"
          ]
        },
        {
          "name": "岳阳市",
          "city": [
            "岳阳楼区",
            "云溪区",
            "君山区",
            "临湘市",
            "汨罗市",
            "岳阳县",
            "湘阴县",
            "平江县",
            "华容县"
          ]
        },
        {
          "name": "常德市",
          "city": [
            "武陵区",
            "鼎城区",
            "津市市",
            "澧县",
            "临澧县",
            "桃源县",
            "汉寿县",
            "安乡县",
            "石门县"
          ]
        },
        {
          "name": "张家界市",
          "city": [
            "永定区",
            "武陵源区",
            "慈利县",
            "桑植县"
          ]
        },
        {
          "name": "益阳市",
          "city": [
            "赫山区",
            "资阳区",
            "沅江市",
            "桃江县",
            "南县",
            "安化县"
          ]
        },
        {
          "name": "郴州市",
          "city": [
            "北湖区",
            "苏仙区",
            "资兴市",
            "宜章县",
            "汝城县",
            "安仁县",
            "嘉禾县",
            "临武县",
            "桂东县",
            "永兴县",
            "桂阳县"
          ]
        },
        {
          "name": "永州市",
          "city": [
            "冷水滩区",
            "零陵区",
            "祁阳县",
            "蓝山县",
            "宁远县",
            "新田县",
            "东安县",
            "江永县",
            "道县",
            "双牌县",
            "江华瑶族自治县"
          ]
        },
        {
          "name": "怀化市",
          "city": [
            "鹤城区",
            "洪江市",
            "会同县",
            "沅陵县",
            "辰溪县",
            "溆浦县",
            "中方县",
            "新晃侗族自治县",
            "芷江侗族自治县",
            "通道侗族自治县",
            "靖州苗族侗族自治县",
            "麻阳苗族自治县"
          ]
        },
        {
          "name": "娄底市",
          "city": [
            "娄星区",
            "冷水江市",
            "涟源市",
            "新化县",
            "双峰县"
          ]
        },
        {
          "name": "湘西土家族苗族自治州",
          "city": [
            "吉首市",
            "古丈县",
            "龙山县",
            "永顺县",
            "凤凰县",
            "泸溪县",
            "保靖县",
            "花垣县"
          ]
        }
      ]
    },
    {
      "name": "广东省",
      "city": [
        {
          "name": "广州市",
          "city": [
            "越秀区",
            "荔湾区",
            "海珠区",
            "天河区",
            "白云区",
            "黄埔区",
            "番禺区",
            "花都区",
            "南沙区",
            "萝岗区",
            "增城市",
            "从化市"
          ]
        },
        {
          "name": "深圳市",
          "city": [
            "福田区",
            "罗湖区",
            "南山区",
            "宝安区",
            "龙岗区",
            "盐田区"
          ]
        },
        {
          "name": "东莞市",
          "city": [
            "莞城",
            "常平",
            "塘厦",
            "塘厦",
            "塘厦"
          ]
        },
        {
          "name": "中山市",
          "city": [
            "中山"
          ]
        },
        {
          "name": "潮州市",
          "city": [
            "湘桥区",
            "潮安县",
            "饶平县"
          ]
        },
        {
          "name": "揭阳市",
          "city": [
            "榕城区",
            "揭东县",
            "揭西县",
            "惠来县",
            "普宁市"
          ]
        },
        {
          "name": "云浮市",
          "city": [
            "云城区",
            "新兴县",
            "郁南县",
            "云安县",
            "罗定市"
          ]
        },
        {
          "name": "珠海市",
          "city": [
            "香洲区",
            "斗门区",
            "金湾区"
          ]
        },
        {
          "name": "汕头市",
          "city": [
            "金平区",
            "濠江区",
            "龙湖区",
            "潮阳区",
            "潮南区",
            "澄海区",
            "南澳县"
          ]
        },
        {
          "name": "韶关市",
          "city": [
            "浈江区",
            "武江区",
            "曲江区",
            "乐昌市",
            "南雄市",
            "始兴县",
            "仁化县",
            "翁源县",
            "新丰县",
            "乳源瑶族自治县"
          ]
        },
        {
          "name": "佛山市",
          "city": [
            "禅城区",
            "南海区",
            "顺德区",
            "三水区",
            "高明区"
          ]
        },
        {
          "name": "江门市",
          "city": [
            "蓬江区",
            "江海区",
            "新会区",
            "恩平市",
            "台山市",
            "开平市",
            "鹤山市"
          ]
        },
        {
          "name": "湛江市",
          "city": [
            "赤坎区",
            "霞山区",
            "坡头区",
            "麻章区",
            "吴川市",
            "廉江市",
            "雷州市",
            "遂溪县",
            "徐闻县"
          ]
        },
        {
          "name": "茂名市",
          "city": [
            "茂南区",
            "茂港区",
            "化州市",
            "信宜市",
            "高州市",
            "电白县"
          ]
        },
        {
          "name": "肇庆市",
          "city": [
            "端州区",
            "鼎湖区",
            "高要市",
            "四会市",
            "广宁县",
            "怀集县",
            "封开县",
            "德庆县"
          ]
        },
        {
          "name": "惠州市",
          "city": [
            "惠城区",
            "惠阳区",
            "博罗县",
            "惠东县",
            "龙门县"
          ]
        },
        {
          "name": "梅州市",
          "city": [
            "梅江区",
            "兴宁市",
            "梅县",
            "大埔县",
            "丰顺县",
            "五华县",
            "平远县",
            "蕉岭县"
          ]
        },
        {
          "name": "汕尾市",
          "city": [
            "城区",
            "陆丰市",
            "海丰县",
            "陆河县"
          ]
        },
        {
          "name": "河源市",
          "city": [
            "源城区",
            "紫金县",
            "龙川县",
            "连平县",
            "和平县",
            "东源县"
          ]
        },
        {
          "name": "阳江市",
          "city": [
            "江城区",
            "阳春市",
            "阳西县",
            "阳东县"
          ]
        },
        {
          "name": "清远市",
          "city": [
            "清城区",
            "英德市",
            "连州市",
            "佛冈县",
            "阳山县",
            "清新县",
            "连山壮族瑶族自治县",
            "连南瑶族自治县"
          ]
        }
      ]
    },
    {
      "name": "广西",
      "city": [
        {
          "name": "南宁市",
          "city": [
            "青秀区",
            "兴宁区",
            "西乡塘区",
            "良庆区",
            "江南区",
            "邕宁区",
            "武鸣县",
            "隆安县",
            "马山县",
            "上林县",
            "宾阳县",
            "横县"
          ]
        },
        {
          "name": "柳州市",
          "city": [
            "城中区",
            "鱼峰区",
            "柳北区",
            "柳南区",
            "柳江县",
            "柳城县",
            "鹿寨县",
            "融安县",
            "融水苗族自治县",
            "三江侗族自治县"
          ]
        },
        {
          "name": "桂林市",
          "city": [
            "象山区",
            "秀峰区",
            "叠彩区",
            "七星区",
            "雁山区",
            "阳朔县",
            "临桂县",
            "灵川县",
            "全州县",
            "平乐县",
            "兴安县",
            "灌阳县",
            "荔浦县",
            "资源县",
            "永福县",
            "龙胜各族自治县",
            "恭城瑶族自治县"
          ]
        },
        {
          "name": "梧州市",
          "city": [
            "万秀区",
            "蝶山区",
            "长洲区",
            "岑溪市",
            "苍梧县",
            "藤县",
            "蒙山县"
          ]
        },
        {
          "name": "北海市",
          "city": [
            "海城区",
            "银海区",
            "铁山港区",
            "合浦县"
          ]
        },
        {
          "name": "防城港市",
          "city": [
            "港口区",
            "防城区",
            "东兴市",
            "上思县"
          ]
        },
        {
          "name": "钦州市",
          "city": [
            "钦南区",
            "钦北区",
            "灵山县",
            "浦北县"
          ]
        },
        {
          "name": "贵港市",
          "city": [
            "港北区",
            "港南区",
            "覃塘区",
            "桂平市",
            "平南县"
          ]
        },
        {
          "name": "玉林市",
          "city": [
            "玉州区",
            "北流市",
            "容县",
            "陆川县",
            "博白县",
            "兴业县"
          ]
        },
        {
          "name": "百色市",
          "city": [
            "右江区",
            "凌云县",
            "平果县",
            "西林县",
            "乐业县",
            "德保县",
            "田林县",
            "田阳县",
            "靖西县",
            "田东县",
            "那坡县",
            "隆林各族自治县"
          ]
        },
        {
          "name": "贺州市",
          "city": [
            "八步区",
            "钟山县",
            "昭平县",
            "富川瑶族自治县"
          ]
        },
        {
          "name": "河池市",
          "city": [
            "金城江区",
            "宜州市",
            "天峨县",
            "凤山县",
            "南丹县",
            "东兰县",
            "都安瑶族自治县",
            "罗城仫佬族自治县",
            "巴马瑶族自治县",
            "环江毛南族自治县",
            "大化瑶族自治县"
          ]
        },
        {
          "name": "来宾市",
          "city": [
            "兴宾区",
            "合山市",
            "象州县",
            "武宣县",
            "忻城县",
            "金秀瑶族自治县"
          ]
        },
        {
          "name": "崇左市",
          "city": [
            "江州区",
            "凭祥市",
            "宁明县",
            "扶绥县",
            "龙州县",
            "大新县",
            "天等县"
          ]
        }
      ]
    },
    {
      "name": "海南省",
      "city": [
        {
          "name": "海口市",
          "city": [
            "龙华区",
            "秀英区",
            "琼山区",
            "美兰区"
          ]
        },
        {
          "name": "三亚市",
          "city": [
            "三亚市"
          ]
        },
        {
          "name": "五指山市",
          "city": [
            "五指山"
          ]
        },
        {
          "name": "琼海市",
          "city": [
            "琼海"
          ]
        },
        {
          "name": "儋州市",
          "city": [
            "儋州"
          ]
        },
        {
          "name": "文昌市",
          "city": [
            "文昌"
          ]
        },
        {
          "name": "万宁市",
          "city": [
            "万宁"
          ]
        },
        {
          "name": "东方市",
          "city": [
            "东方"
          ]
        },
        {
          "name": "澄迈县",
          "city": [
            "澄迈县"
          ]
        },
        {
          "name": "定安县",
          "city": [
            "定安县"
          ]
        },
        {
          "name": "屯昌县",
          "city": [
            "屯昌县"
          ]
        },
        {
          "name": "临高县",
          "city": [
            "临高县"
          ]
        },
        {
          "name": "白沙黎族自治县",
          "city": [
            "白沙黎族自治县"
          ]
        },
        {
          "name": "昌江黎族自治县",
          "city": [
            "昌江黎族自治县"
          ]
        },
        {
          "name": "乐东黎族自治县",
          "city": [
            "乐东黎族自治县"
          ]
        },
        {
          "name": "陵水黎族自治县",
          "city": [
            "陵水黎族自治县"
          ]
        },
        {
          "name": "保亭黎族苗族自治县",
          "city": [
            "保亭黎族苗族自治县"
          ]
        },
        {
          "name": "琼中黎族苗族自治县",
          "city": [
            "琼中黎族苗族自治县"
          ]
        }
      ]
    },
    {
      "name": "重庆市",
      "city": [
        {
          "name": "重庆市",
          "city": [
            "渝中区",
            "大渡口区",
            "江北区",
            "南岸区",
            "北碚区",
            "渝北区",
            "巴南区",
            "长寿区",
            "双桥区",
            "沙坪坝区",
            "万盛区",
            "万州区",
            "涪陵区",
            "黔江区",
            "永川区",
            "合川区",
            "江津区",
            "九龙坡区",
            "南川区",
            "綦江县",
            "潼南县",
            "荣昌县",
            "璧山县",
            "大足县",
            "铜梁县",
            "梁平县",
            "开县",
            "忠县",
            "城口县",
            "垫江县",
            "武隆县",
            "丰都县",
            "奉节县",
            "云阳县",
            "巫溪县",
            "巫山县",
            "石柱土家族自治县",
            "秀山土家族苗族自治县",
            "酉阳土家族苗族自治县",
            "彭水苗族土家族自治县"
          ]
        }
      ]
    },
    {
      "name": "四川省",
      "city": [
        {
          "name": "成都市",
          "city": [
            "青羊区",
            "锦江区",
            "金牛区",
            "武侯区",
            "成华区",
            "龙泉驿区",
            "青白江区",
            "新都区",
            "温江区",
            "都江堰市",
            "彭州市",
            "邛崃市",
            "崇州市",
            "金堂县",
            "郫县",
            "新津县",
            "双流县",
            "蒲江县",
            "大邑县"
          ]
        },
        {
          "name": "自贡市",
          "city": [
            "大安区",
            "自流井区",
            "贡井区",
            "沿滩区",
            "荣县",
            "富顺县"
          ]
        },
        {
          "name": "攀枝花市",
          "city": [
            "仁和区",
            "米易县",
            "盐边县",
            "东区",
            "西区"
          ]
        },
        {
          "name": "泸州市",
          "city": [
            "江阳区",
            "纳溪区",
            "龙马潭区",
            "泸县",
            "合江县",
            "叙永县",
            "古蔺县"
          ]
        },
        {
          "name": "德阳市",
          "city": [
            "旌阳区",
            "广汉市",
            "什邡市",
            "绵竹市",
            "罗江县",
            "中江县"
          ]
        },
        {
          "name": "绵阳市",
          "city": [
            "涪城区",
            "游仙区",
            "江油市",
            "盐亭县",
            "三台县",
            "平武县",
            "安县",
            "梓潼县",
            "北川羌族自治县"
          ]
        },
        {
          "name": "广元市",
          "city": [
            "元坝区",
            "朝天区",
            "青川县",
            "旺苍县",
            "剑阁县",
            "苍溪县",
            "市中区"
          ]
        },
        {
          "name": "遂宁市",
          "city": [
            "船山区",
            "安居区",
            "射洪县",
            "蓬溪县",
            "大英县"
          ]
        },
        {
          "name": "内江市",
          "city": [
            "市中区",
            "东兴区",
            "资中县",
            "隆昌县",
            "威远县"
          ]
        },
        {
          "name": "乐山市",
          "city": [
            "市中区",
            "五通桥区",
            "沙湾区",
            "金口河区",
            "峨眉山市",
            "夹江县",
            "井研县",
            "犍为县",
            "沐川县",
            "马边彝族自治县",
            "峨边彝族自治县"
          ]
        },
        {
          "name": "南充",
          "city": [
            "顺庆区",
            "高坪区",
            "嘉陵区",
            "阆中市",
            "营山县",
            "蓬安县",
            "仪陇县",
            "南部县",
            "西充县"
          ]
        },
        {
          "name": "眉山市",
          "city": [
            "东坡区",
            "仁寿县",
            "彭山县",
            "洪雅县",
            "丹棱县",
            "青神县"
          ]
        },
        {
          "name": "宜宾市",
          "city": [
            "翠屏区",
            "宜宾县",
            "兴文县",
            "南溪县",
            "珙县",
            "长宁县",
            "高县",
            "江安县",
            "筠连县",
            "屏山县"
          ]
        },
        {
          "name": "广安市",
          "city": [
            "广安区",
            "华蓥市",
            "岳池县",
            "邻水县",
            "武胜县"
          ]
        },
        {
          "name": "达州市",
          "city": [
            "通川区",
            "万源市",
            "达县",
            "渠县",
            "宣汉县",
            "开江县",
            "大竹县"
          ]
        },
        {
          "name": "雅安市",
          "city": [
            "雨城区",
            "芦山县",
            "石棉县",
            "名山县",
            "天全县",
            "荥经县",
            "宝兴县",
            "汉源县"
          ]
        },
        {
          "name": "巴中市",
          "city": [
            "巴州区",
            "南江县",
            "平昌县",
            "通江县"
          ]
        },
        {
          "name": "资阳市",
          "city": [
            "雁江区",
            "简阳市",
            "安岳县",
            "乐至县"
          ]
        },
        {
          "name": "阿坝藏族羌族自治州",
          "city": [
            "马尔康县",
            "九寨沟县",
            "红原县",
            "汶川县",
            "阿坝县",
            "理县",
            "若尔盖县",
            "小金县",
            "黑水县",
            "金川县",
            "松潘县",
            "壤塘县",
            "茂县"
          ]
        },
        {
          "name": "甘孜藏族自治州",
          "city": [
            "康定县",
            "丹巴县",
            "炉霍县",
            "九龙县",
            "甘孜县",
            "雅江县",
            "新龙县",
            "道孚县",
            "白玉县",
            "理塘县",
            "德格县",
            "乡城县",
            "石渠县",
            "稻城县",
            "色达县",
            "巴塘县",
            "泸定县",
            "得荣县"
          ]
        },
        {
          "name": "凉山彝族自治州",
          "city": [
            "西昌市",
            "美姑县",
            "昭觉县",
            "金阳县",
            "甘洛县",
            "布拖县",
            "雷波县",
            "普格县",
            "宁南县",
            "喜德县",
            "会东县",
            "越西县",
            "会理县",
            "盐源县",
            "德昌县",
            "冕宁县",
            "木里藏族自治县"
          ]
        }
      ]
    },
    {
      "name": "贵州省",
      "city": [
        {
          "name": "贵阳市",
          "city": [
            "南明区",
            "云岩区",
            "花溪区",
            "乌当区",
            "白云区",
            "小河区",
            "清镇市",
            "开阳县",
            "修文县",
            "息烽县"
          ]
        },
        {
          "name": "六盘水市",
          "city": [
            "钟山区",
            "水城县",
            "盘县",
            "六枝特区"
          ]
        },
        {
          "name": "遵义市",
          "city": [
            "红花岗区",
            "汇川区",
            "赤水市",
            "仁怀市",
            "遵义县",
            "绥阳县",
            "桐梓县",
            "习水县",
            "凤冈县",
            "正安县",
            "余庆县",
            "湄潭县",
            "道真仡佬族苗族自治县",
            "务川仡佬族苗族自治县"
          ]
        },
        {
          "name": "安顺市",
          "city": [
            "西秀区",
            "普定县",
            "平坝县",
            "镇宁布依族苗族自治县",
            "紫云苗族布依族自治县",
            "关岭布依族苗族自治县"
          ]
        },
        {
          "name": "铜仁地区",
          "city": [
            "铜仁市",
            "德江县",
            "江口县",
            "思南县",
            "石阡县",
            "玉屏侗族自治县",
            "松桃苗族自治县",
            "印江土家族苗族自治县",
            "沿河土家族自治县",
            "万山特区"
          ]
        },
        {
          "name": "毕节地区",
          "city": [
            "毕节市",
            "黔西县",
            "大方县",
            "织金县",
            "金沙县",
            "赫章县",
            "纳雍县",
            "威宁彝族回族苗族自治县"
          ]
        },
        {
          "name": "黔西南布依族苗族自治州",
          "city": [
            "兴义市",
            "望谟县",
            "兴仁县",
            "普安县",
            "册亨县",
            "晴隆县",
            "贞丰县",
            "安龙县"
          ]
        },
        {
          "name": "黔东南苗族侗族自治州",
          "city": [
            "凯里市",
            "施秉县",
            "从江县",
            "锦屏县",
            "镇远县",
            "麻江县",
            "台江县",
            "天柱县",
            "黄平县",
            "榕江县",
            "剑河县",
            "三穗县",
            "雷山县",
            "黎平县",
            "岑巩县",
            "丹寨县"
          ]
        },
        {
          "name": "黔南布依族苗族自治州",
          "city": [
            "都匀市",
            "福泉市",
            "贵定县",
            "惠水县",
            "罗甸县",
            "瓮安县",
            "荔波县",
            "龙里县",
            "平塘县",
            "长顺县",
            "独山县",
            "三都水族自治县"
          ]
        }
      ]
    },
    {
      "name": "云南省",
      "city": [
        {
          "name": "昆明市",
          "city": [
            "盘龙区",
            "五华区",
            "官渡区",
            "西山区",
            "东川区",
            "安宁市",
            "呈贡县",
            "晋宁县",
            "富民县",
            "宜良县",
            "嵩明县",
            "石林彝族自治县",
            "禄劝彝族苗族自治县",
            "寻甸回族彝族自治县"
          ]
        },
        {
          "name": "曲靖市",
          "city": [
            "麒麟区",
            "宣威市",
            "马龙县",
            "沾益县",
            "富源县",
            "罗平县",
            "师宗县",
            "陆良县",
            "会泽县"
          ]
        },
        {
          "name": "玉溪市",
          "city": [
            "红塔区",
            "江川县",
            "澄江县",
            "通海县",
            "华宁县",
            "易门县",
            "峨山彝族自治县",
            "新平彝族傣族自治县",
            "元江哈尼族彝族傣族自治县"
          ]
        },
        {
          "name": "保山市",
          "city": [
            "隆阳区",
            "施甸县",
            "腾冲县",
            "龙陵县",
            "昌宁县"
          ]
        },
        {
          "name": "昭通市",
          "city": [
            "昭阳区",
            "鲁甸县",
            "巧家县",
            "盐津县",
            "大关县",
            "永善县",
            "绥江县",
            "镇雄县",
            "彝良县",
            "威信县",
            "水富县"
          ]
        },
        {
          "name": "丽江市",
          "city": [
            "古城区",
            "永胜县",
            "华坪县",
            "玉龙纳西族自治县",
            "宁蒗彝族自治县"
          ]
        },
        {
          "name": "普洱市",
          "city": [
            "思茅区",
            "普洱哈尼族彝族自治县",
            "墨江哈尼族自治县",
            "景东彝族自治县",
            "景谷傣族彝族自治县",
            "镇沅彝族哈尼族拉祜族自治县",
            "江城哈尼族彝族自治县",
            "孟连傣族拉祜族佤族自治县",
            "澜沧拉祜族自治县",
            "西盟佤族自治县"
          ]
        },
        {
          "name": "临沧市",
          "city": [
            "临翔区",
            "凤庆县",
            "云县",
            "永德县",
            "镇康县",
            "双江拉祜族佤族布朗族傣族自治县",
            "耿马傣族佤族自治县",
            "沧源佤族自治县"
          ]
        },
        {
          "name": "德宏傣族景颇族自治州",
          "city": [
            "潞西市",
            "瑞丽市",
            "梁河县",
            "盈江县",
            "陇川县"
          ]
        },
        {
          "name": "怒江傈僳族自治州",
          "city": [
            "泸水县",
            "福贡县",
            "贡山独龙族怒族自治县",
            "兰坪白族普米族自治县"
          ]
        },
        {
          "name": "迪庆藏族自治州",
          "city": [
            "香格里拉县",
            "德钦县",
            "维西傈僳族自治县"
          ]
        },
        {
          "name": "大理白族自治州",
          "city": [
            "大理市",
            "祥云县",
            "宾川县",
            "弥渡县",
            "永平县",
            "云龙县",
            "洱源县",
            "剑川县",
            "鹤庆县",
            "漾濞彝族自治县",
            "南涧彝族自治县",
            "巍山彝族回族自治县"
          ]
        },
        {
          "name": "楚雄彝族自治州",
          "city": [
            "楚雄市",
            "双柏县",
            "牟定县",
            "南华县",
            "姚安县",
            "大姚县",
            "永仁县",
            "元谋县",
            "武定县",
            "禄丰县"
          ]
        },
        {
          "name": "红河哈尼族彝族自治州",
          "city": [
            "蒙自县",
            "个旧市",
            "开远市",
            "绿春县",
            "建水县",
            "石屏县",
            "弥勒县",
            "泸西县",
            "元阳县",
            "红河县",
            "金平苗族瑶族傣族自治县",
            "河口瑶族自治县",
            "屏边苗族自治县"
          ]
        },
        {
          "name": "文山壮族苗族自治州",
          "city": [
            "文山县",
            "砚山县",
            "西畴县",
            "麻栗坡县",
            "马关县",
            "丘北县",
            "广南县",
            "富宁县"
          ]
        },
        {
          "name": "西双版纳傣族自治州",
          "city": [
            "景洪市",
            "勐海县",
            "勐腊县"
          ]
        }
      ]
    },
    {
      "name": "西藏",
      "city": [
        {
          "name": "拉萨市",
          "city": [
            "城关区",
            "林周县",
            "当雄县",
            "尼木县",
            "曲水县",
            "堆龙德庆县",
            "达孜县",
            "墨竹工卡县"
          ]
        },
        {
          "name": "那曲地区",
          "city": [
            "那曲县",
            "嘉黎县",
            "比如县",
            "聂荣县",
            "安多县",
            "申扎县",
            "索县",
            "班戈县",
            "巴青县",
            "尼玛县"
          ]
        },
        {
          "name": "昌都地区",
          "city": [
            "昌都县",
            "江达县",
            "贡觉县",
            "类乌齐县",
            "丁青县",
            "察雅县",
            "八宿县",
            "左贡县",
            "芒康县",
            "洛隆县",
            "边坝县"
          ]
        },
        {
          "name": "林芝地区",
          "city": [
            "林芝县",
            "工布江达县",
            "米林县",
            "墨脱县",
            "波密县",
            "察隅县",
            "朗县"
          ]
        },
        {
          "name": "山南地区",
          "city": [
            "乃东县",
            "扎囊县",
            "贡嘎县",
            "桑日县",
            "琼结县",
            "曲松县",
            "措美县",
            "洛扎县",
            "加查县",
            "隆子县",
            "错那县",
            "浪卡子县"
          ]
        },
        {
          "name": "日喀则地区",
          "city": [
            "日喀则市",
            "南木林县",
            "江孜县",
            "定日县",
            "萨迦县",
            "拉孜县",
            "昂仁县",
            "谢通门县",
            "白朗县",
            "仁布县",
            "康马县",
            "定结县",
            "仲巴县",
            "亚东县",
            "吉隆县",
            "聂拉木县",
            "萨嘎县",
            "岗巴县"
          ]
        },
        {
          "name": "阿里地区",
          "city": [
            "噶尔县",
            "普兰县",
            "札达县",
            "日土县",
            "革吉县",
            "改则县",
            "措勤县"
          ]
        }
      ]
    },
    {
      "name": "陕西省",
      "city": [
        {
          "name": "西安市",
          "city": [
            "莲湖区",
            "新城区",
            "碑林区",
            "雁塔区",
            "灞桥区",
            "未央区",
            "阎良区",
            "临潼区",
            "长安区",
            "高陵县",
            "蓝田县",
            "户县",
            "周至县"
          ]
        },
        {
          "name": "铜川市",
          "city": [
            "耀州区",
            "王益区",
            "印台区",
            "宜君县"
          ]
        },
        {
          "name": "宝鸡市",
          "city": [
            "渭滨区",
            "金台区",
            "陈仓区",
            "岐山县",
            "凤翔县",
            "陇县",
            "太白县",
            "麟游县",
            "扶风县",
            "千阳县",
            "眉县",
            "凤县"
          ]
        },
        {
          "name": "咸阳市",
          "city": [
            "秦都区",
            "渭城区",
            "杨陵区",
            "兴平市",
            "礼泉县",
            "泾阳县",
            "永寿县",
            "三原县",
            "彬县",
            "旬邑县",
            "长武县",
            "乾县",
            "武功县",
            "淳化县"
          ]
        },
        {
          "name": "渭南市",
          "city": [
            "临渭区",
            "韩城市",
            "华阴市",
            "蒲城县",
            "潼关县",
            "白水县",
            "澄城县",
            "华县",
            "合阳县",
            "富平县",
            "大荔县"
          ]
        },
        {
          "name": "延安市",
          "city": [
            "宝塔区",
            "安塞县",
            "洛川县",
            "子长县",
            "黄陵县",
            "延川县",
            "富县",
            "延长县",
            "甘泉县",
            "宜川县",
            "志丹县",
            "黄龙县",
            "吴起县"
          ]
        },
        {
          "name": "汉中市",
          "city": [
            "汉台区",
            "留坝县",
            "镇巴县",
            "城固县",
            "南郑县",
            "洋县",
            "宁强县",
            "佛坪县",
            "勉县",
            "西乡县",
            "略阳县"
          ]
        },
        {
          "name": "榆林市",
          "city": [
            "榆阳区",
            "清涧县",
            "绥德县",
            "神木县",
            "佳县",
            "府谷县",
            "子洲县",
            "靖边县",
            "横山县",
            "米脂县",
            "吴堡县",
            "定边县"
          ]
        },
        {
          "name": "安康市",
          "city": [
            "汉滨区",
            "紫阳县",
            "岚皋县",
            "旬阳县",
            "镇坪县",
            "平利县",
            "石泉县",
            "宁陕县",
            "白河县",
            "汉阴县"
          ]
        },
        {
          "name": "商洛市",
          "city": [
            "商州区",
            "镇安县",
            "山阳县",
            "洛南县",
            "商南县",
            "丹凤县",
            "柞水县"
          ]
        }
      ]
    },
    {
      "name": "甘肃省",
      "city": [
        {
          "name": "兰州市",
          "city": [
            "城关区",
            "七里河区",
            "西固区",
            "安宁区",
            "红古区",
            "永登县",
            "皋兰县",
            "榆中县"
          ]
        },
        {
          "name": "嘉峪关市",
          "city": [
            "嘉峪关市"
          ]
        },
        {
          "name": "金昌市",
          "city": [
            "金川区",
            "永昌县"
          ]
        },
        {
          "name": "白银市",
          "city": [
            "白银区",
            "平川区",
            "靖远县",
            "会宁县",
            "景泰县"
          ]
        },
        {
          "name": "天水市",
          "city": [
            "清水县",
            "秦安县",
            "甘谷县",
            "武山县",
            "张家川回族自治县",
            "北道区",
            "秦城区"
          ]
        },
        {
          "name": "武威市",
          "city": [
            "凉州区",
            "民勤县",
            "古浪县",
            "天祝藏族自治县"
          ]
        },
        {
          "name": "酒泉市",
          "city": [
            "肃州区",
            "玉门市",
            "敦煌市",
            "金塔县",
            "肃北蒙古族自治县",
            "阿克塞哈萨克族自治县",
            "安西县"
          ]
        },
        {
          "name": "张掖市",
          "city": [
            "甘州区",
            "民乐县",
            "临泽县",
            "高台县",
            "山丹县",
            "肃南裕固族自治县"
          ]
        },
        {
          "name": "庆阳市",
          "city": [
            "西峰区",
            "庆城县",
            "环县",
            "华池县",
            "合水县",
            "正宁县",
            "宁县",
            "镇原县"
          ]
        },
        {
          "name": "平凉市",
          "city": [
            "崆峒区",
            "泾川县",
            "灵台县",
            "崇信县",
            "华亭县",
            "庄浪县",
            "静宁县"
          ]
        },
        {
          "name": "定西市",
          "city": [
            "安定区",
            "通渭县",
            "临洮县",
            "漳县",
            "岷县",
            "渭源县",
            "陇西县"
          ]
        },
        {
          "name": "陇南市",
          "city": [
            "武都区",
            "成县",
            "宕昌县",
            "康县",
            "文县",
            "西和县",
            "礼县",
            "两当县",
            "徽县"
          ]
        },
        {
          "name": "临夏回族自治州",
          "city": [
            "临夏市",
            "临夏县",
            "康乐县",
            "永靖县",
            "广河县",
            "和政县",
            "东乡族自治县",
            "积石山保安族东乡族撒拉族自治县"
          ]
        },
        {
          "name": "甘南藏族自治州",
          "city": [
            "合作市",
            "临潭县",
            "卓尼县",
            "舟曲县",
            "迭部县",
            "玛曲县",
            "碌曲县",
            "夏河县"
          ]
        }
      ]
    },
    {
      "name": "青海省",
      "city": [
        {
          "name": "西宁市",
          "city": [
            "城中区",
            "城东区",
            "城西区",
            "城北区",
            "湟源县",
            "湟中县",
            "大通回族土族自治县"
          ]
        },
        {
          "name": "海东地区",
          "city": [
            "平安县",
            "乐都县",
            "民和回族土族自治县",
            "互助土族自治县",
            "化隆回族自治县",
            "循化撒拉族自治县"
          ]
        },
        {
          "name": "海北藏族自治州",
          "city": [
            "海晏县",
            "祁连县",
            "刚察县",
            "门源回族自治县"
          ]
        },
        {
          "name": "海南藏族自治州",
          "city": [
            "共和县",
            "同德县",
            "贵德县",
            "兴海县",
            "贵南县"
          ]
        },
        {
          "name": "黄南藏族自治州",
          "city": [
            "同仁县",
            "尖扎县",
            "泽库县",
            "河南蒙古族自治县"
          ]
        },
        {
          "name": "果洛藏族自治州",
          "city": [
            "玛沁县",
            "班玛县",
            "甘德县",
            "达日县",
            "久治县",
            "玛多县"
          ]
        },
        {
          "name": "玉树藏族自治州",
          "city": [
            "玉树县",
            "杂多县",
            "称多县",
            "治多县",
            "囊谦县",
            "曲麻莱县"
          ]
        },
        {
          "name": "海西蒙古族藏族自治州",
          "city": [
            "德令哈市",
            "格尔木市",
            "乌兰县",
            "都兰县",
            "天峻县"
          ]
        }
      ]
    },
    {
      "name": "宁夏",
      "city": [
        {
          "name": "银川市",
          "city": [
            "兴庆区",
            "西夏区",
            "金凤区",
            "灵武市",
            "永宁县",
            "贺兰县"
          ]
        },
        {
          "name": "石嘴山市",
          "city": [
            "大武口区",
            "惠农区",
            "平罗县"
          ]
        },
        {
          "name": "吴忠市",
          "city": [
            "利通区",
            "青铜峡市",
            "盐池县",
            "同心县"
          ]
        },
        {
          "name": "固原市",
          "city": [
            "原州区",
            "西吉县",
            "隆德县",
            "泾源县",
            "彭阳县"
          ]
        },
        {
          "name": "中卫市",
          "city": [
            "沙坡头区",
            "中宁县",
            "海原县"
          ]
        }
      ]
    },
    {
      "name": "新疆",
      "city": [
        {
          "name": "乌鲁木齐市",
          "city": [
            "天山区",
            "沙依巴克区",
            "新市区",
            "水磨沟区",
            "头屯河区",
            "达坂城区",
            "东山区",
            "乌鲁木齐县"
          ]
        },
        {
          "name": "克拉玛依市",
          "city": [
            "克拉玛依区",
            "独山子区",
            "白碱滩区",
            "乌尔禾区"
          ]
        },
        {
          "name": "吐鲁番地区",
          "city": [
            "吐鲁番市",
            "托克逊县",
            "鄯善县"
          ]
        },
        {
          "name": "哈密地区",
          "city": [
            "哈密市",
            "伊吾县",
            "巴里坤哈萨克自治县"
          ]
        },
        {
          "name": "和田地区",
          "city": [
            "和田市",
            "和田县",
            "洛浦县",
            "民丰县",
            "皮山县",
            "策勒县",
            "于田县",
            "墨玉县"
          ]
        },
        {
          "name": "阿克苏地区",
          "city": [
            "阿克苏市",
            "温宿县",
            "沙雅县",
            "拜城县",
            "阿瓦提县",
            "库车县",
            "柯坪县",
            "新和县",
            "乌什县"
          ]
        },
        {
          "name": "喀什地区",
          "city": [
            "喀什市",
            "巴楚县",
            "泽普县",
            "伽师县",
            "叶城县",
            "岳普湖县",
            "疏勒县",
            "麦盖提县",
            "英吉沙县",
            "莎车县",
            "疏附县",
            "塔什库尔干塔吉克自治县"
          ]
        },
        {
          "name": "克孜勒苏柯尔克孜自治州",
          "city": [
            "阿图什市",
            "阿合奇县",
            "乌恰县",
            "阿克陶县"
          ]
        },
        {
          "name": "巴音郭楞蒙古自治州",
          "city": [
            "库尔勒市",
            "和静县",
            "尉犁县",
            "和硕县",
            "且末县",
            "博湖县",
            "轮台县",
            "若羌县",
            "焉耆回族自治县"
          ]
        },
        {
          "name": "昌吉回族自治州",
          "city": [
            "昌吉市",
            "阜康市",
            "奇台县",
            "玛纳斯县",
            "吉木萨尔县",
            "呼图壁县",
            "木垒哈萨克自治县",
            "米泉市"
          ]
        },
        {
          "name": "博尔塔拉蒙古自治州",
          "city": [
            "博乐市",
            "精河县",
            "温泉县"
          ]
        },
        {
          "name": "石河子",
          "city": [
            "石河子"
          ]
        },
        {
          "name": "阿拉尔",
          "city": [
            "阿拉尔"
          ]
        },
        {
          "name": "图木舒克",
          "city": [
            "图木舒克"
          ]
        },
        {
          "name": "五家渠",
          "city": [
            "五家渠"
          ]
        },
        {
          "name": "伊犁哈萨克自治州",
          "city": [
            "伊宁市",
            "奎屯市",
            "伊宁县",
            "特克斯县",
            "尼勒克县",
            "昭苏县",
            "新源县",
            "霍城县",
            "巩留县",
            "察布查尔锡伯自治县",
            "塔城地区",
            "阿勒泰地区"
          ]
        }
      ]
    },
    {
      "name": "台湾省",
      "city": [
        {
          "name": "台北市",
          "city": [
            "内湖区",
            "南港区",
            "中正区",
            "万华区",
            "大同区",
            "中山区",
            "松山区",
            "大安区",
            "信义区",
            "文山区",
            "士林区",
            "北投区"
          ]
        },
        {
          "name": "新北市",
          "city": [
            "板桥区",
            "汐止区",
            "新店区"
          ]
        },
        {
          "name": "桃园市",
          "city": [
            "其他"
          ]
        },
        {
          "name": "台中市",
          "city": [
            "其他"
          ]
        },
        {
          "name": "台南市",
          "city": [
            "其他"
          ]
        },
        {
          "name": "高雄市",
          "city": [
            "其他"
          ]
        }
      ]
    },
    {
      "name": "澳门",
      "city": [
        {
          "name": "澳门",
          "city": [
            "花地玛堂区",
            "圣安多尼堂区",
            "大堂区",
            "望德堂区",
            "风顺堂区",
            "嘉模堂区",
            "圣方济各堂区",
            "路凼"
          ]
        }
      ]
    },
    {
      "name": "香港",
      "city": [
        {
          "name": "香港",
          "city": [
            "深水埗区",
            "油尖旺区",
            "九龙城区",
            "黄大仙区",
            "观塘区",
            "北区",
            "大埔区",
            "沙田区",
            "西贡区",
            "元朗区",
            "屯门区",
            "荃湾区",
            "葵青区",
            "离岛区",
            "中西区",
            "湾仔区",
            "东区",
            "南区"
          ]
        }
      ]
    }
  ]</code></pre>

<p>&nbsp;</p>                                    ]]></description></item><item><title>JS案例：Socket聊天室（两种方式）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/02/02/12438924.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 02 Feb 2019 06:56:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2019/02/02/12438924.html</guid><description><![CDATA[
                                            <h2>一.socket轮询（每隔一段时间向后端请求一次，增加服务器压力）:</h2>

<p>由于socket连接时采用ws/wss协议，页面必须放在服务器端，所以首先用node产生一个静态文件夹，方便通过IP直接访问</p>

<h3>static.js:</h3>

<pre class="has"><code class="language-javascript">const express = require('express');//这里要引入express
const app = express();
const path = require('path');
app.use('/main', express.static(path.join(__dirname, './html')));//设置静态文件夹
app.listen(2048, () =&gt; {//端口号不能与socket监听的端口号一样
    console.log('static 2048 Server Start~');
})</code></pre>

<p>在html界面做一些简单的布局以及socket数据请求：</p>

<h3>index.html：</h3>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    #text {
        width: 350px;
        height: 30px;
      }
      #netName {
        width: 150px;
        height: 30px;
      }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;textarea name="" id="msg" cols="80" rows="30" readonly&gt;&lt;/textarea&gt;&lt;br /&gt;
  &lt;input id="netName" type="text" placeholder="名称" /&gt;
  &lt;input id="text" type="text" placeholder="消息" /&gt;
  &lt;button οnclick="clickHandler()"&gt;发送&lt;/button&gt;
  &lt;script&gt;
    setInterval(sendMsg, 1000); //这里做轮询请求
    function sendMsg(data) { //封装WebSocket请求函数
      if (!data) {
        data = {
          err: 1
        }; //根据参数判断是否符合数据规范
      }
      var ws = new WebSocket("ws://192.168.1.4:1024"); //使用ws协议对1024端口进行请求
      ws.onopen = function () {
        ws.send(JSON.stringify(data));
      };
      ws.onmessage = getData;
    }

    function getData(evt) { //将请求成功后返回的数据接收
      var received_msg = evt.data;
      var val = JSON.parse(evt.data).join("\n");
      msg.value = val;
    }
    document.addEventListener("keyup", e =&gt; { //回车键发送
      if (e.keyCode !== 13) return;
      clickHandler(e);
    });

    function clickHandler() { //点击Button时将数据发送到服务端
      if (netName.value.trim().length == 0 || text.value.trim().length == 0)
        return;
      var obj = {
        err: 0,
        netName: netName.value,
        msg: text.value
      };
      sendMsg(obj);
      text.value = ""; //每次发送后将内容制空
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>Client.js（客户端）</h2>

<pre class="has"><code class="language-javascript">const WebSocket = require('ws');//这里引入一个模块ws

const ws = new WebSocket('ws://192.168.1.4:1024');//对1024端口进行监听
 
ws.on('open', function() {
  console.log('Client is listening on port 1024');
});
ws.on('message', function(msg) {
    ws.send(msg);//获取到前端传来的数据后，直接向服务端传递
});
ws.on('close',function(){ 
    console.log('Client close')
}); </code></pre>

<h2>Server.js</h2>

<pre class="has"><code class="language-javascript">const static = require('./static')//引入刚刚创建的static静态目录
const client = require('./client')//引入客户端
const WebSocket = require('ws');
let list = [];
const wss = new WebSocket.Server({//对1024端口进行监听
    port: 1024
}, () =&gt; {
    console.log('Server is listening on port 1024');
});

wss.on('connection', function (ws) {
    ws.on('message', function (msg) {//对数据过滤和处理
        if(!JSON.parse(msg).err){
            list.push(JSON.parse(msg).netName + ' 说: ' + JSON.parse(msg).msg)
        }
        ws.send(JSON.stringify(list));//将数据传到前端
    });
});
</code></pre>

<h2>二.socketio长链接（与轮询不同，使前后端通过事件处理机制时刻保持连接状态）</h2>

<p>同样产生一个静态文件夹：</p>

<h3>static.js:</h3>

<pre class="has"><code class="language-javascript">const express = require('express');
const app = express();
const path = require('path');
app.use('/main', express.static(path.join(__dirname, './static')));
app.listen(2048, () =&gt; {
    console.log('static 2048 Server Start~');
})</code></pre>

<h3>index.html</h3>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    #text {
        width: 350px;
        height: 30px;
      }
      #netName {
        width: 150px;
        height: 30px;
      }
    &lt;/style&gt;
  &lt;script src="./socket.io.js"&gt;&lt;/script&gt;
  &lt;!-- 首先用npm下载socketio并且使用socket.io-client中的socket.io.js --&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;textarea name="" id="msg" cols="80" rows="30" readonly&gt;&lt;/textarea&gt;&lt;br /&gt;
  &lt;input id="netName" type="text" placeholder="名称" /&gt;
  &lt;input id="text" type="text" placeholder="消息" /&gt;
  &lt;button οnclick="clickHandler()"&gt;发送&lt;/button&gt;
  &lt;script&gt;
    var socket = io.connect('http://192.168.1.4:1024'); //建立http连接
    var list = [] //本地聊天记录缓存

    function clickHandler() {
      if (netName.value.trim().length == 0 || text.value.trim().length == 0)
        return; //过滤输入框
      var obj = {
        netName: netName.value,
        msg: text.value
      };
      list.push(obj.netName + ' 说: ' + obj.msg)
      socket.emit('send', obj)//触发send事件
      getData(list);
      text.value = "";
    }
    socket.on('msg', function (msg) {//添加msg监听事件
      list = msg;
      getData(list)
    })

    function getData(arr) {//将聊天记录放至area标签
      msg.value = arr.join('\n');
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

<h3>Server.js:</h3>

<pre class="has"><code class="language-javascript">const static = require("./static");//引入刚刚创建的static静态目录
let list = [];//聊天记录缓存
var express = require("express");
var app = express();
var server = require("http").Server(app);
const io = require("socket.io")(server);
io.on("connection", function(client) {
  client.on("send", data =&gt; {//添加send监听事件
    list.push(data.netName + " 说: " + data.msg);//将前端事件传过来的参数进行处理
    sendList(list, client);//将数据通过事件发送到前端
  });
});
function sendList(list, target) {
  target.broadcast.emit("msg", list);//触发msg事件
}
server.listen(1024, "192.168.1.4", () =&gt; {
  console.log("Connect Success At 1024");
});
</code></pre>

<p>&nbsp;</p>                                    ]]></description></item><item><title>JS案例：继承和深复制</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/30/10205449.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 30 Dec 2018 08:54:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/30/10205449.html</guid><description><![CDATA[
                <h2>继承：</h2>

<pre class="has"><code class="language-javascript">// 寄生式继承(圣杯)
			Father.prototype.name = 'Hello' //在Father类中添加一个name属性

			function Father() {} //构造Father类

			function Son() {} //构造Son类
			var inherit = (function () { //新建一个立即执行函数,(类似雅虎网站的继承写法)
				function F() {} //使用闭包产生私有函数
				return function (father, son) { //返回继承函数
					F.prototype = father.prototype; //私有函数取出父类的原型
					son.prototype = new F(); //实例化私有函数，并将对象赋给子类的原型
					son.prototype.superClass = father; //自定义子类的超类等于父类
					son.prototype.constructor = son; //将子类的构造函数指向自己，否则是父类(因为原型链上的constructor是父类)
				}
			}())
			inherit(Father, Son) //调用函数
			Son.prototype.age = 'World' //改变子类的原型(目的：测试父类原型与子类原型是否绑定)
			var son = new Son(); //实例化子类对象
			var father = new Father(); //实例化父类对象
			console.log(son, father)
			console.log(son.name, father.name); //此时父子类都有该属性。打印(Hello Hello)
			console.log(son.age, father.age) //子类独有属性，父类无此属性。打印(World undefined)</code></pre>

<h2>深复制：</h2>

<h3>简易版：</h3>

<pre class="has"><code class="language-javascript">var obj = {
				a: 1,
				b: 'hello',
				c: function () {
					console.log(this.a, this.b);
				},
				d: [1, 2, 3, 4, 'a', 'b', false],
				e: {
					a: 11,
					b: '11',
					c: {
						arr: [5, 4, 1, 2, 3],
						obj: {
							z: 'hello',
							y: 'world'
						}
					}
				}
			}
			var obj1 = {}
			obj1 = JSON.parse(JSON.stringify(obj))
			console.log(obj1);</code></pre>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181230173146272.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70">&nbsp;</p>

<h3>进阶版：（缺点：遇到不可枚举项时无法遍历，对象中有set和get时只会将结果输出）</h3>

<pre class="has"><code class="language-javascript">var obj = {
				a: 1,
				b: 'hello',
				c: function () {
					console.log(this.a, this.b);
				},
				d: [1, 2, 3, 4, 'a', 'b', false],
				e: {
					a: 11,
					b: '11',
					c: {
						arr: [5, 4, 1, 2, 3],
						obj: {
							z: 'hello',
							y: 'world'
						}
					}
				},
				f: null,
				g: undefined,
				set count(val) {
					this.f = val;
				},
				get count() {
					return this.f
				}
			}
			var obj1 = {}

			function copyObj(org, tag) { //org是原对象(obj)，tag是复制后的对象(obj1)
				var tag = tag || {}; //初始化要复制的对象
				for (var key in org) { //遍历对象
					if (typeof org[key] === 'object' &amp;&amp; org[key] !== null) { //若遍历的每一项非空且为对象，则为引用值，则继续下一步
						if (org[key].toString() === '[object Object]') {//若引用值.toString等于[object Object]，说明该值数据类型为对象
							tag[key] = {};
						} else {//否则为数组
							tag[key] = [];
						}
						copyObj(org[key], tag[key])//再次执行函数
					} else { //若每一项除了typeof为obj以外的值都是原始值，直接赋值即可
						tag[key] = org[key];
					}
				}
				return tag; //递归结束后返回对象
			}
			copyObj(obj, obj1)
			obj.e.c.obj.z = 'world';//改变复制后的值观察复制后的对象是否发生改变
			obj.e.c.obj.y = 'hello';
			console.log(obj, obj1);</code></pre>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181230173201112.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70">&nbsp;</p>

<h3>终极版深复制：（解决进阶版的问题）</h3>

<pre class="has"><code class="language-javascript">			var obj = {
				a: 1,
				b: 'hello',
				c: function () {
					console.log(this.a, this.b);
				},
				d: [1, 2, 3, 4, 'a', 'b', false],
				e: {
					a: 11,
					b: '11',
					c: {
						arr: [5, 4, 1, 2, 3],
						obj: {
							z: 'hello',
							y: 'world'
						}
					}
				},
				f: null,
				g: undefined,
				set count(val) {
					this.f = val;
				},
				get count() {
					return this.f
				}
			}
			var obj1 = {}

			function copyObj(org, tag) {
				var tag = tag || {}; //初始化要复制的对象
				var name = Object.getOwnPropertyNames(org); //获取该对象的属性名，以字符串数组返回
				for (var i = 0; i &lt; name.length; i++) { //遍历对象
					var desc = Object.getOwnPropertyDescriptor(org, name[i]); //获取对象的属性描述对象，无引用关系，返回另一个对象，改变时原对象不发生变化(复制的关键)
					if (typeof desc.value === 'object' &amp;&amp; desc.value !== null) { //若遍历的每一项非空且为对象，则为引用值，则进行下一步
						var obj = desc.value.toString() === '[object Object]' ? {} : []; //判断是数组还是对象
						Object.defineProperty(tag, name[i], { //设置对象属性值，前三个的值是返回true或false
							configurable: desc.configurable, //是否可删除可替换
							enumerable: desc.enumerable, //是否可枚举可遍历
							writable: desc.writable, //是否可写入
							value: obj //对象的值
						});
						copyObj(desc.value, obj); //再次执行函数
					} else {
						Object.defineProperty(tag, name[i], desc); //否则直接将该对象的属性值进行复制(原始值)
					}
				}
				return tag;
			}
			copyObj(obj, obj1)
			obj.e.c.obj.z = 'world'; //改变复制后的值观察复制后的对象是否发生改变
			obj.e.c.obj.y = 'hello';
			console.log(obj, obj1);</code></pre>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181230174051591.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70"></p>            ]]></description></item><item><title>React（四）进阶</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/30/12438925.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 30 Dec 2018 07:18:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/30/12438925.html</guid><description><![CDATA[
                                            <h2>搭建脚手架 create-react-app：（类似Vue）：</h2>

<p>步骤：</p>

<p>全局安装 npm install create-react-app -g</p>

<p>在项目目录下安装&nbsp;create-react-app myapp(项目名称）</p>

<p>npm start 运行项目</p>

<p>npm run eject--------将配置文件迁移到外部（产生config文件夹）</p>

<p><img alt="" class="has" height="410" src="https://img-blog.csdnimg.cn/201812301515375.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="246"></p>

<h2>Redux：</h2>

<p>如果你不知道是否需要 Redux，那就是不需要它</p>

<p>只有遇到 React 实在解决不了的问题，你才需要 Redux</p>

<p>redux的条件：</p>

<ul><li>某个组件的状态，需要共享</li>
	<li>某个状态需要在任何地方都可以拿到</li>
	<li>一个组件需要改变全局状态</li>
	<li>一个组件需要改变另一个组件的状态</li>
</ul><p>安装： npm install --save redux&nbsp;</p>

<p>安装redux工具：</p>

<p>npm install --save react-redux<br>
npm install --save-dev redux-devtools</p>

<h3>原理：</h3>

<p>组件触发actionCreate中的函数</p>

<pre class="has"><code class="language-javascript">function addTodoWithDispatch(text) {
  const action = {
    type: ADD_TODO,//自定类型
    text//抛出的内容
  }
  dispatch(action)//抛出action对象
}</code></pre>

<p>但是只会经过Store而不会操作，直接抛出到Reducers，&nbsp;<span style="color:#f33b45;"><u>不能修改&nbsp;<code>state，因为对象的引用关系，会将原数据修改</code></u></span></p>

<pre class="has"><code class="language-javascript">import { VisibilityFilters } from './actions'//引入actions

function todoApp(state, action) {
  if (typeof state === 'undefined') {
    return initialState
  }

  // 这里暂不处理任何 action，
  // 仅返回传入的 state。
  return state
}</code></pre>

<p>若要对state修改，需另附值（对象复制），再做修改</p>

<p>&nbsp;</p>

<pre class="has"><code class="language-javascript">import { VisibilityFilters } from './actions'//引入actions

function todoApp(state, action) {
  if (typeof state === 'undefined') {
    return initialState
  }
return Object.assign({}, state, {
        visibilityFilter: action.filter
      })//复制了state，并返回
}</code></pre>

<p>获取返回的state</p>

<h3><span style="color:#f33b45;">&nbsp;</span><a href="https://www.redux.org.cn/docs/api/Store.html#getState" rel="nofollow"><span style="color:#f33b45;"><code>getState()</code></span></a><span style="color:#f33b45;">&nbsp;</span>方法获取 state；&nbsp;</h3>

<h3><span style="color:#f33b45;">&nbsp;</span><a href="https://www.redux.org.cn/docs/api/Store.html#dispatch" rel="nofollow"><span style="color:#f33b45;"><code>dispatch(action)</code></span></a><span style="color:#f33b45;">&nbsp;</span>方法更新 state；</h3>

<h3><span style="color:#f33b45;">&nbsp;</span><a href="https://www.redux.org.cn/docs/api/Store.html#subscribe" rel="nofollow"><span style="color:#f33b45;"><code>subscribe(listener)</code></span></a><span style="color:#f33b45;">&nbsp;</span>注册监听器;</h3>

<h3><span style="color:#f33b45;">&nbsp;</span><a href="https://www.redux.org.cn/docs/api/Store.html#subscribe" rel="nofollow"><span style="color:#f33b45;"><code>subscribe(listener)</code></span></a><span style="color:#f33b45;">&nbsp;</span>返回的函数注销监听器。</h3>

<p><img alt="" class="has" height="310" src="https://img-blog.csdnimg.cn/20181231141248528.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="413"></p>

<h1>react-router-dom和react-router（路由）：</h1>

<h2>react-router-dom：</h2>

<p>安装：npm install react-router-dom</p>

<p>使用一个js文件实现路由功能：</p>

<p>需要路由操作的页面引入路由方法：</p>

<pre class="has"><code class="language-javascript">import {HashRouter,BrowserRouter,Link,NavLink,Route,Switch} from 'react-router-dom'</code></pre>

<p>HashRouter：根据哈希变化进行路由操作；</p>

<p>BrowserRouter：根据Path路径变化而操作；</p>

<p>Link 和 Route：类似于Vue的routerlink 和 route-view，连接路由的组件，显示路由的组件；</p>

<h2>例如：</h2>

<p>引入要路由的文件：</p>

<pre class="has"><code class="language-javascript">import A from './a'
import B from './b'
import C from './c'</code></pre>

<p>路由操作：</p>

<pre class="has"><code class="language-javascript">    render(){
        return(
            &lt;HashRouter&gt;
                
                &lt;div&gt;
               
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to='/'&gt;a&lt;/Link&gt;{/*匹配全部的*/}
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;Link to='/b'&gt;b&lt;/Link&gt;{/*匹配b的*/}
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;Link to='/c'&gt;c&lt;/Link&gt;{/*匹配c的*/}
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;hr/&gt;
                 &lt;Route exact={true} path='/' component={A}&gt;&lt;/Route&gt;{/*跳到a*/}
                 &lt;Route path='/b' component={B}&gt;&lt;/Route&gt;{/*跳到b*/}
                 &lt;Route path='/c' component={C}&gt;&lt;/Route&gt;{/*跳到c*/}
                 &lt;/div&gt;
            &lt;/HashRouter&gt;
            )
    }</code></pre>

<h2>react-router：</h2>

<p>React Router 是一个基于React之上的强大路由库；</p>

<pre class="has"><code>import { Router, Route, Link } from 'react-router'</code></pre>

<h3>&nbsp;传参：</h3>

<ul><li>params：在编程式导航的push或replace中加&nbsp;/ : key，传递方式由路由匹配，只能传字符（JOSN处理），刷新界面依然保存</li>
	<li>query：在路由path处写{path：‘/admin’，query：{name：aaa，age：20}},无需动态路由（即，在路径处有个 /：key），刷新后不保存，可传任何数据</li>
	<li>state：类似query，在路由path处写{path：‘/admin’，state：{name：aaa，age：20}}，无需动态路由，刷新后保存，可传任何数据</li>
</ul>                                    ]]></description></item><item><title>React（三）TableBar，ToDoList，Redux案例</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/27/10193676.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 27 Dec 2018 15:57:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/27/10193676.html</guid><description><![CDATA[<h3>直接上代码：</h3>
<p>TableBar:</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src="./react.min.js"&gt;&lt;/script&gt;
  &lt;script src="./react-dom.min.js"&gt;&lt;/script&gt;
  &lt;script src="./browser.min.js"&gt;&lt;/script&gt;
  &lt;style&gt;
    * {
        margin: 0;
        padding: 0;
      }
      body{
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
      ul {
        list-style: none;
      }
      .title li {
        float: left;
        background: lightcoral;
        width: 100px;
        height: 60px;
        text-align: center;
        line-height: 60px;
        cursor: pointer;
      }
      #tabbar {
        width: 500px;
        margin: 50px auto 0;
      }
      .title .change{
          background: lightgreen;
      }
      .area li{
        text-align: center;
        width: 100%;
        padding: 10px 0;
        background: lightblue;
      }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id="tabbar"&gt;&lt;/div&gt;
  &lt;script type="text/babel"&gt;
    var Tab = React.createClass({
        getDefaultProps() {
          return {
            list: [//数据
              {
                name: "北京",
                area: [
                  "东城区",
                  "西城区",
                  "崇文区",
                  "宣武区",
                  "朝阳区",
                  "丰台区",
                  "石景山区",
                  "海淀区",
                  "门头沟区",
                  "房山区",
                  "通州区",
                  "顺义区",
                  "昌平区",
                  "大兴区",
                  "平谷区",
                  "怀柔区",
                  "密云县",
                  "延庆县"
                ]
              },
              {
                name: "上海",
                area: [
                  "黄浦区",
                  "卢湾区",
                  "徐汇区",
                  "长宁区",
                  "静安区",
                  "普陀区",
                  "闸北区",
                  "虹口区",
                  "杨浦区",
                  "宝山区",
                  "闵行区",
                  "嘉定区",
                  "松江区",
                  "金山区",
                  "青浦区",
                  "南汇区",
                  "奉贤区",
                  "浦东新区",
                  "崇明县"
                ]
              },
              {
                name: "广州",
                area: [
                  "越秀区",
                  "荔湾区",
                  "海珠区",
                  "天河区",
                  "白云区",
                  "黄埔区",
                  "番禺区",
                  "花都区",
                  "南沙区",
                  "萝岗区",
                  "增城市",
                  "从化市"
                ]
              },
              {
                name: "深圳",
                area: [
                  "福田区",
                  "罗湖区",
                  "南山区",
                  "宝安区",
                  "龙岗区",
                  "盐田区"
                ]
              },
              {
                name: "南昌",
                area: [
                  "东湖区",
                  "西湖区",
                  "青云谱区",
                  "湾里区",
                  "青山湖区",
                  "新建县",
                  "南昌县",
                  "进贤县",
                  "安义县"
                ]
              }
            ]
          };
        },
        getInitialState() {
          return {//默认值
            str: "南昌",
            arr:[
                  "东湖区",
                  "西湖区",
                  "青云谱区",
                  "湾里区",
                  "青山湖区",
                  "新建县",
                  "南昌县",
                  "进贤县",
                  "安义县"
                ]
          };
        },
        render() {
          return (
            &lt;div&gt;
              &lt;ul className="title"&gt;{this.init()}&lt;/ul&gt;{/*初始化数据，遍历生成li*/}
              &lt;Bar list={this.state.arr}&gt;&lt;/Bar&gt;{/*传列表到子元素*/}
            &lt;/div&gt;
          );
        },
        init() {
          var arr = [];
          for (var i = 0; i &lt; this.props.list.length; i++) {
            arr.push(//将元素放到数组中，绑定事件，让单击到的那个li改变颜色，绑定事件时将全局this，用bind绑定到事件函数
              &lt;li className={this.state.str===this.props.list[i].name?'change':''} onClick={this.changeName.bind(this,this.props.list[i].name,this.props.list[i].area)}&gt;
                {this.props.list[i].name}
              &lt;/li&gt;
            );
          }
          return arr;
        },
        changeName(count,area) {
          if (count===this.state.str) {
              return;
          }
          this.setState({ str: count ,arr:area});//动态设置新的数据
        }
      });
      var Bar = React.createClass({
        render() {
          return (
            &lt;ul className='area'&gt;
            {
              this.init()
            }
          &lt;/ul&gt;
          );
          
        },
        init() {//类似于上面的父组件，将传过来的数据遍历渲染到页面
          var arr = [];
          for (var i = 0; i &lt; this.props.list.length; i++) {
            arr.push(
              &lt;li&gt;
                {this.props.list[i]}
              &lt;/li&gt;
            );
          }
          return arr;
        }
      });
      ReactDOM.render(&lt;Tab /&gt;, tabbar);
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>ToDoList：</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src="./react.min.js"&gt;&lt;/script&gt;
    &lt;script src="./react-dom.min.js"&gt;&lt;/script&gt;
    &lt;script src="./browser.min.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        *{
            margin: 0;
            padding: 0;
        }
        #todo{
            width: 900px;
            margin: 50px auto 0;
        }
        .text{
            width: 500px;
            height: 30px;
            margin-left: 200px;
        }
        .btn{
            width: 100px;
            height: 30px;
        }
        .list{
            background: lightblue;
        }
        .list li{
            height: 50px;
            line-height: 50px;
        }
        ul{
            list-style: none;
        }
        .finish{
            height: 50px;
            line-height: 50px; 
            background: lightgray;
            width: 110px;
            float: right;
            text-align: center;
        }
        .unfinish{
            height: 50px;
            line-height: 50px;
            background: lightseagreen;
            width: 110px;
            float: right;
            text-align: center;
        }
        .list button{
            float: right;
            vertical-align: middle;
            height: 50px;
            line-height: 50px;
            width: 110px;
        }
        .time{
            height: 50px;
            line-height: 50px;
            width: 110px;
            float:right;
            background: lightcyan;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="todo"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;
        var Todo = React.createClass({
                getInitialState() {
                    return {
                        arr:[]//初始化消息容器
                    };
                },
                render() {
                    return (
                        &lt;div&gt;{/*组件的一些布局，onclick触发父元素的提交事件，将每次改变的数据以及子组件执行父组件中对数据的操作函数传递到子组件*/}
                            &lt;input className='text' id='txt' type="text"/&gt;
                            &lt;button className='btn' onClick={this.clickHandler}&gt;提交
                            &lt;/button&gt;
                            &lt;List listData={this.state.arr} changeItem={this.changeItem}/&gt;
                        &lt;/div&gt;
                    );
                },
                clickHandler(){
                    if(!txt.value) return;
                    var list = this.state.arr||[];//初始化点击前的容器
                    list.push({id:this.state.arr.length,concent:txt.value,time:new Date().toLocaleTimeString(),finish:false});//点击时更新数据
                    this.setState({arr:list})//将数据更新到state中
                },
                changeItem(item,how){//子组件执行的函数，删除和修改状态
                    for (var i = 0; i &lt; this.state.arr.length; i++) {//遍历数据
                        if (how=='delete'&amp;&amp;this.state.arr[i].id===item) {//根据参数的类型判断修改状态还是删除
                            this.state.arr.splice(i,1);
                            break;
                        }else if(how=='finish'&amp;&amp;this.state.arr[i].id===item){
                            this.state.arr[i].finish=true;
                            break;
                        }
                    }
                    this.setState({})//更新state
                }
            });
            var List = React.createClass({
                render() {
                return (
                    &lt;ul className='list'&gt;
                    {
                    this.init()//初始化，遍历数据新建li
                    }
                &lt;/ul&gt;
                );
                },
                init() {
                var arr = [];//初始化容器
                for (var i = 0; i &lt; this.props.listData.length; i++) {
                    arr.push(
                    &lt;li&gt;
                        {this.props.listData[i].concent}{/*显示内容*/}
                        &lt;span className='time'&gt;{this.props.listData[i].time||''}&lt;/span&gt;{/*显示新建的时间*/}
                        {this.props.listData[i].finish?&lt;span className='finish'&gt;已完成&lt;/span&gt;:&lt;span className='unfinish' onClick={this.changeOne.bind(this,this.props.listData[i].id,'finish')}&gt;未完成&lt;/span&gt;}{/*更改状态，调用子组件的函数触发父组件的函数*/}
                        &lt;button onClick={this.changeOne.bind(this,this.props.listData[i].id,'delete')}&gt;删除&lt;/button&gt;{/*删除，调用子组件的函数触发父组件的函数*/}
                    &lt;/li&gt;
                    );
                }
                return arr;
                },
                changeOne(id,how){//执行父组件的函数
                    this.props.changeItem(id,how)
                }
            });
            ReactDOM.render(&lt;Todo/&gt;,todo);
        &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>&nbsp;</p>
<h1>Redux案例:</h1>
<p>待办事项和计算器（GitHub）：<a href="https://github.com/ZbyA/React_todolist_computer.git" rel="nofollow" target="_blank">https://github.com/ZbyA/React_todolist_computer.git</a>（首先在项目内用npm install（默认下依赖包）</p>
<p>然后运行项目即可）</p>]]></description></item><item><title>React（二）组件通信</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/27/10193677.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 27 Dec 2018 07:48:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/27/10193677.html</guid><description><![CDATA[<h1>组件通信：(react版本是15版本，可能和16版本的操作有部分差异)</h1>
<h2>父子组件：</h2>
<h3>父=&gt;子</h3>
<ol>
<li>用props：</li>
<li>
<p>通过ref进行标记</p>
</li>
</ol>
<p>1.用props</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Life&lt;/title&gt;
        &lt;script src="../react.min.js"&gt;&lt;/script&gt;
        &lt;script src="../react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="../browser.min.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            div{
                width: 100px;
                height: 100px;
                line-height: 100px;
                text-align: center;
                background: lightgreen;
            }
            .yes{
                background: lightblue;
            }
            .no{
                background: lightcoral;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;script type="text/babel"&gt;
            var Father = React.createClass({
                getInitialState(){
                    return{
                        isTrue:'Hello'
                    }
                },
                render() {
                    return (
                        &lt;li&gt;{/*组件传参，用bind绑定this，以取到this.state.isTrue，
                        将this.state.isTrue作为属性传到子组件中
                        */}
                            &lt;div onClick={this.clickHandler.bind(this,this.state.isTrue)}&gt;&lt;/div&gt;
                            &lt;Son name={this.state.isTrue}/&gt;
                        &lt;/li&gt;
                    );
                },
                clickHandler(a){
                    // 将state的值改变，使Hello取World，World取Hello
                    this.setState({isTrue:this.state.isTrue=='Hello'?'World':'Hello'});
                }
            });
            var Son = React.createClass({
                render() {//取到父组件的值，修改颜色
                    return (
                        &lt;div className={this.props.name==='Hello'?'yes':'no'}&gt;{this.props.name}&lt;/div&gt;
                    );
                }
            });
            ReactDOM.render(&lt;Father/&gt;,app);
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>2.ref标记：</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Life&lt;/title&gt;
        &lt;script src="../react.min.js"&gt;&lt;/script&gt;
        &lt;script src="../react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="../browser.min.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            div{
                width: 100px;
                height: 100px;
                line-height: 100px;
                text-align: center;
                background: lightgreen;
            }
            .yes{
                background: lightblue;
            }
            .no{
                background: lightcoral;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;script type="text/babel"&gt;
            var Father = React.createClass({
                init(){
                    this.self.clickHandler()//执行子组件的方法
                },
                render() {
                    return (
                        &lt;li&gt;
                            &lt;div onClick={this.init}&gt;&lt;/div&gt;
                            &lt;Son ref={(el)=&gt; this.self=el}/&gt;{/*绑定一个标记绑定在自己身上，使this.self等于子组件，于是调用this.self以达到调用子组件的方法*/}
                        &lt;/li&gt;
                    );
                }
            });
            var Son = React.createClass({
                getInitialState(){
                    return{
                        str:'Hello'
                    }
                },
                render() {
                    return (
                        &lt;div className={this.state.str==='Hello'?'yes':'no'}&gt;{this.state.str}&lt;/div&gt;
                    );
                },
                clickHandler(){
                    // 将state的值改变，使Hello取World，World取Hello，该方法被父组件调用
                    this.setState({str:this.state.str=='Hello'?'World':'Hello'});
                }
            });
            ReactDOM.render(&lt;Father/&gt;,app);
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h3>子=&gt;父：</h3>
<p>通过子组件调用父组件的函数传递信息</p>
<p>下面是个简单的小例子：</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
        &lt;title&gt;s_f&lt;/title&gt;
        &lt;script src="../react.min.js"&gt;&lt;/script&gt;
        &lt;script src="../react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="../browser.min.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            div {
        width: 100px;
        height: 100px;
        line-height: 100px;
        text-align: center;
        background: lightgreen;
      }
      .yes {
        background: lightblue;
      }
      .no {
        background: lightcoral;
      }
    &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;script type="text/babel"&gt;
            var Father = React.createClass({
        getInitialState() {
          return {
            str: "Hello"
          };
        },
        render() {
          return (
            &lt;li&gt;{/*父组件添加点击事件改变自身颜色和数据，并将自己的函数和state附在子组件的属性上*/}
              &lt;div className={this.state.str==='Hello'?'yes':'no'} onClick={this.clickHandler}&gt;{this.state.str}&lt;/div&gt;
              &lt;Son Fn={this.clickHandler} str={this.state.str} /&gt;
            &lt;/li&gt;
          );
        },
        clickHandler() {//点击事件，单击时将world换成hello，hello换成world
          this.setState({ str: this.state.str == "Hello" ? "World" : "Hello" });
        }
      });
      var Son = React.createClass({
        render() {
          return ({/*子组件中将调用父组件传过来的函数及数据，并修改自身样式，达到子组件修改父组件的方法，从而父组件变化，子组件也变化，子组件变化，父组件也变化*/}
            &lt;div className={this.props.str==='Hello'?'no':'yes'} onClick={this.props.Fn}&gt;{this.props.str}
            &lt;/div&gt;
          );
        }
      });
      ReactDOM.render(&lt;Father/&gt;, app);
    &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h2>简单的兄弟组件（非redux、flux）</h2>
<p>将以上两种结合即可，子传父，父传子</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
        &lt;title&gt;s_s&lt;/title&gt;
        &lt;script src="../react.min.js"&gt;&lt;/script&gt;
        &lt;script src="../react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="../browser.min.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            div {
        width: 100px;
        height: 100px;
        line-height: 100px;
        text-align: center;
        background: lightgreen;
      }
      .yes {
        background: lightblue;
      }
      .no {
        background: lightcoral;
      }
    &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;script type="text/babel"&gt;
            var Father = React.createClass({
        getInitialState() {
          return {
            str: "Hello"
          };
        },
        render() {
          return (
            &lt;li&gt;{/*父组件添加点击事件改变自身颜色和数据，并将自己的函数和state附在子组件的属性上*/}
              &lt;div&gt;{this.state.str}&lt;/div&gt;
              &lt;Son Fn={this.clickHandler}/&gt;{/*Son组件触发父组件的事件*/}
              &lt;Son1 str={this.state.str}/&gt;{/*父组件将数据更新传给Son1组件*/}
            &lt;/li&gt;
          );
        },
        clickHandler() {//点击事件，单击时将world换成hello，hello换成world
          this.setState({ str: this.state.str == "Hello" ? "World" : "Hello" });
        }
      });
      var Son = React.createClass({
        render() {//Son触发事件改变数据
          return (
            &lt;div onClick={this.props.Fn}&gt;Son
            &lt;/div&gt;
          );
        }
      });
      var Son1 = React.createClass({
        render() {//Son1对传来的数据进行改变
          return (
            &lt;div className={this.props.str==='Hello'?'no':'yes'}&gt;Son1
            &lt;/div&gt;
          );
        }
      });
      ReactDOM.render(&lt;Father/&gt;, app);
    &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>&nbsp;</p>]]></description></item><item><title>React（一）起步</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/25/10193678.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 25 Dec 2018 13:24:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/25/10193678.html</guid><description><![CDATA[<h1>轻量级的视图层框架</h1>
<p>React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式</p>
<h2>React高性能的原理：</h2>
<p>减少对DOM进行操作，引入了虚拟DOM，如：先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A ，不发生任何变化。</p>
<h2>特点：</h2>
<p>虚拟DOM</p>
<p>组件系统</p>
<p>单向数据流</p>
<p>JSX 语法</p>
<h2>起步：</h2>
<p>引入三个js文件：(react版本是15版本，可能和16版本的操作有部分差异)</p>
<p>react.js<br />
react-dom.js<br />
browser.js</p>
<p>最简单的React操作：</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script src="./react.min.js"&gt;&lt;/script&gt;
        &lt;script src="./react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="./browser.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;script type='text/babel'&gt;
            //创建组件
    var Hello = React.createClass({
        render:function () {
            return (
                //jsx语法
                &lt;div&gt;HelloWorld&lt;/div&gt;
            )
        }
    })
    //利用ReactDOM对象的render方法将组件渲染到某个节点里
    ReactDOM.render(&lt;Hello/&gt;,app)
   &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h3 id="jsx">JSX：</h3>
<p>JSX是一种语法，全称：javascript xml</p>
<p>用法：</p>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script src="./react.min.js"&gt;&lt;/script&gt;
        &lt;script src="./react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="./browser.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app1"&gt;&lt;/div&gt;
        &lt;script type='text/babel'&gt;
            var World = React.createElement(
            'h1',
            {className:'abc',id:'haha'},
            [React.createElement('span',null,'Hello'),
            React.createElement('mark',null,'World')])
            ReactDOM.render(World,app1)
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h2>添加样式：</h2>
<p>行内样式：</p>
<pre class="has"><code class="language-html">&lt;div style = { {color:'red',fontSize:2+'em'} }&gt;Hello world&lt;/div&gt;
//{ }的作用类似于Vue中的表达式符号</code></pre>
<p>写在React.createClass中用this调用：</p>
<pre class="has"><code class="language-javascript">var Hello = React.createClass({
        style:{
            background:'lightgreen',
            color:'deepskyblue'
        },
        render:function () {
            return (
                //jsx语法
                &lt;div style={this.style}&gt;HelloWorld&lt;/div&gt;
            )
        }
    })</code></pre>
<h2>事件：（类似于原生，在React.createClass中添加事件触发的函数，在元素中用this.handler调用）</h2>
<pre class="has"><code class="language-javascript">&lt;script type="text/babel"&gt;
            var Hello = React.createClass({
            clickHandler(){
            console.log('HelloWorld');
            },
          render:function () {
              return (
                  &lt;div&gt;
                      &lt;div onClick={this.clickHandler}&gt;Click&lt;/div&gt;
                  &lt;/div&gt;

              )
          }
      })
      ReactDOM.render(&lt;Hello/&gt;,app)
    &lt;/script&gt;</code></pre>
<h2>React与原生事件的不同点：（react中对于事件进行了处理，解决了一些兼容性问题，如果不取值的话，值都是null）</h2>
<p><img class="has" src="https://img-blog.csdnimg.cn/20181226174550595.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" alt="" width="461" height="369" /><img class="has" src="https://img-blog.csdnimg.cn/20181226174613381.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" alt="" width="399" height="368" /></p>
<h2>组件包含：（在父组件直接写子组件即可）</h2>
<pre class="has"><code class="language-javascript">&lt;script type="text/babel"&gt;
            var Hello = React.createClass({
            clickHandler(){
            console.log('HelloWorld');
            },
          render:function () {
              return (
                  &lt;div&gt;
                      &lt;World/&gt;//子元素
                  &lt;/div&gt;
              )
          }
      })
      var World = React.createClass({
            clickHandler(){
            console.log('HelloWorld');
            },
          render:function () {
              return (
                  &lt;div&gt;
                      &lt;div onClick={this.clickHandler}&gt;Click&lt;/div&gt;
                  &lt;/div&gt;
              )
          }
      })
      ReactDOM.render(&lt;Hello/&gt;,app)</code></pre>
<h3>state（状态）与组件本身有关，由自己修改</h3>
<h3>props（属性）并非自己修改，可以从父组件获取，也可以给子组件设置</h3>
<h2>props（属性）：在父组件包含的子组件标签中加入参数，在子组件中用this.props.children调用：</h2>
<pre class="has"><code class="language-javascript">&lt;script type="text/babel"&gt;
            var Hello = React.createClass({
          render:function () {
              return (
                  &lt;div&gt;
                      &lt;World&gt;{{a:1,b:2}}&lt;/World&gt;
                  &lt;/div&gt;
              )
          }
      })
      var World = React.createClass({
            clickHandler(){
            console.log(this.props);
            },
          render:function () {
              return (
                  &lt;div&gt;
                      &lt;div onClick={this.clickHandler}&gt;Click&lt;/div&gt;
                  &lt;/div&gt;
              )
          }
      })
      ReactDOM.render(&lt;Hello/&gt;,app)
    &lt;/script&gt;</code></pre>
<h2>state（状态）：组件自己可修改的状态（数据）配合setState(params)使用：</h2>
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script src="./react.min.js"&gt;&lt;/script&gt;
        &lt;script src="./react-dom.min.js"&gt;&lt;/script&gt;
        &lt;script src="./browser.min.js"&gt;&lt;/script&gt;
        &lt;style&gt;

        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
        &lt;script type="text/babel"&gt;
            var Hello = React.createClass({
                getInitialState(){//设置state的数据
                return {
                    name:'World'
                }
            },
            render:function () {
              return (
                  &lt;div&gt;
                      {this.state.name}{/*这里渲染了state的name*/}
                  &lt;/div&gt;
              )
          }
      })
      ReactDOM.render(&lt;Hello/&gt;,app)
    &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h2>生命周期：</h2>
<p style="text-align: center;"><img class="has" src="https://img-blog.csdnimg.cn/20181226171123283.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" alt="" /></p>
<h3>React组件生命周期：</h3>
<h3>初始化：</h3>
<ol>
<li>执行getDefaultProps钩子函数，执行一次，挂载属性props（无Dom元素，有组件相关的this但是无法获取数据）</li>
<li>执行getInitialState钩子函数，初始化自身状态state（同上，无Dom元素，有组件相关的this，但是无法获取数据）</li>
<li>componentWillMount（）挂载前（类似于Vue的created加beforeMount阶段，可以进行数据请求（ajax））</li>
<li>componentDidMount（）挂载完成（有Dom元素，数据准备完毕）</li>
</ol>
<h3>运行中：</h3>
<ol>
<li>componentWillReceiveProps函数：当props发生变化时调用</li>
<li>shouldComponentUpdate函数：主要做效率优化，控制组件是否随之更新，函数返回的true或false表示视图是否渲染，如：在函数中比较this.props.name（数据更新前）和props.name（数据更新后）对比，二者是否相同，从而避免重复渲染，加强优化</li>
<li>componentWillUpdate函数：准备工作，不允许更改数值，否则会死循环，类似Vue中的beforeUpdate</li>
<li>render：重新渲染Dom</li>
<li>componentDidUpdate：页面更新渲染完成，类似Vue的updated</li>
</ol>
<h3>组件销毁：</h3>
<ol>
<li>componentWillUnmount：组件将要销毁，可以将定时器，事件等取消或结束&nbsp;（ReactDOM.unmountComponentAtNode(node) 销毁节点中的组件）</li>
</ol>
<p>&nbsp;</p>]]></description></item><item><title>Vue（二）进阶</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/24/10205454.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 24 Dec 2018 02:31:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/24/10205454.html</guid><description><![CDATA[
                <h3>Vue脚手架：</h3>

<h3>&nbsp;vue-cli：</h3>

<p>全局安装：</p>

<pre class="has"><code class="language-html">npm install  -g  vue-cli
</code></pre>

<p>查看版本：</p>

<pre class="has"><code class="language-html">vue -V </code></pre>

<p>初始化脚手架：</p>

<pre class="has"><code class="language-html">vue init webpack + 项目的名字</code></pre>

<p>运行项目：</p>

<pre class="has"><code class="language-html">npm run dev
</code></pre>

<p>打包项目：</p>

<pre class="has"><code class="language-html">npm run build</code></pre>

<h3>文件及文件夹的信息：</h3>

<p><img alt="" class="has" height="387" src="https://img-blog.csdnimg.cn/20181223235455492.jpg" width="225"><img alt="" class="has" height="371" src="https://img-blog.csdnimg.cn/20181223235948289.jpg" width="284"></p>

<pre class="has"><code class="language-html">开发依赖：  开发编译打包需要的依赖，打包之后就不要了 
生产依赖：  打包前后都需要的依赖</code></pre>

<h3>Vue-router：</h3>

<pre class="has"><code class="language-html">下载安装：
npm install vue-router</code></pre>

<p>在router文件夹下新建js文件：</p>

<pre class="has"><code class="language-javascript">import VueRouter from 'vue-router'//引入路由模块
       import Vue from 'vue'
       Vue.use(VueRouter)//依赖模块
       let router=new VueRouter({
       	routes:[
			{path:'路径（加斜杠访问）',name:"名字（直接访问）",component:'注册组件（跳转的位置）',chidern:[]子路由}
			{path:'/',redirect:"/home"},//路由的重定向 如果hash 为'/' 指向到 /home
       	]
       })
       export default router</code></pre>

<p>通过&lt;router-link to='/path'&gt;标签来切换组件</p>

<p>通过&lt;router-view&gt;标签显示</p>

<p>keep-alive:在component组件、router-view外面包裹上keep-alive的话，就会对组件进行缓存，当切换回来的时候，组件会立即渲染，理论来说，切换组件的时候其实会把上一个组件销毁，使用了keep-alive则不会(就是组件一直存在于缓存中)</p>

<p>include匹配到的组件会被缓存，exclude匹配到的不会被缓存</p>

<p>值可以为逗号隔开的字符串include = ‘a,b’;正则:include = ‘/a|b/’;数组:include=[‘a’,’b’]</p>

<p>多级路由：</p>

<pre class="has"><code class="language-javascript">const routes = [
  {path:'/main',component:AppMain},
  {path:'/news',component:AppNews,children:[//children是子目录
    {path:'inside',component:AppNewsInside},
    {path:'outside',component:AppNewsOutside}
  ]},
]</code></pre>

<p>默认路由：</p>

<pre class="has"><code class="language-html">{path:'',component:Main}//将默认路径设置成Main</code></pre>

<p>动态路由：</p>

<pre class="has"><code class="language-html">{path:'/user/:id',component:User}//id为传的值</code></pre>

<p>命名路由：</p>

<p>直接用name : main在hash中写name就可以路由</p>

<p>路由跳转：</p>

<pre class="has"><code class="language-javascript">router.push = router-link:to router.replace = router-link:to.replace router.go() = window.history.go</code></pre>

<p>&nbsp;路由钩子：</p>

<p>全局路由钩子：</p>

<pre class="has"><code class="language-javascript">router.beforeEach((to, from, next) =&gt; {
    //会在任意路由跳转前执行，next一定要记着执行，不然路由不能跳转了
  console.log('beforeEach')
  console.log(to,from)
  //
  next()
})
//
router.afterEach((to, from) =&gt; {
    //会在任意路由跳转后执行
  console.log('afterEach')
})</code></pre>

<p>局部路由：</p>

<pre class="has"><code class="language-javascript"> routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]</code></pre>

<p>组件内的路由钩子：</p>

<pre class="has"><code class="language-javascript">beforeRouteEnter (to, from, next) //confirm 前调用
beforeRouteUpdate (to, from, next) //在当前路由改变调用
beforeRouteLeave (to, from, next)//导航离开该组件的对应路由时调用</code></pre>

<h3>生命周期：</h3>

<p style="text-align:center;"><img alt="" class="has" height="1200" src="https://img-blog.csdnimg.cn/20181224114138567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="600"></p>

<h3>beforeCreate：</h3>

<p>创建组件之前，没有组件，没有元素，没有事件，没有生命周期</p>

<h3>created：</h3>

<p>创建组件结束，有数据，没有元素</p>

<h3>beforeMount：</h3>

<p>挂载之前，有数据，没有元素</p>

<h3>mounted：</h3>

<p>挂载完成，有元素，有数据</p>

<h3>beforeUpdate：（在mounted后执行）</h3>

<p>用于监听数据变化</p>

<h3>updated：</h3>

<p>用于监听数据变化</p>

<h3>beforeDestroy：</h3>

<p>销毁实例，元素数据还在</p>

<h3>destroyed：</h3>

<p>销毁实例</p>

<h3>Vue中的ajax：</h3>

<h3>axios：</h3>

<p>载入：npm install axios</p>

<p>在main.js中</p>

<pre class="has"><code class="language-javascript">import Axios from 'axios';//引入
Vue.prototype.$axios = Axios;//将Axios附着在Vue，以供全局调用
Axios.defaults.baseURL = 'http://localhost:1024';//设置默认接口地址</code></pre>

<p>然后在需要请求的组件中：</p>

<pre class="has"><code class="language-javascript">this.$axios
        .post("hash",data)//hash是接口地址，不需要加主机地址（http://localhost/index直接写/index）data是传输的对象
        .then(res =&gt; {//返回值
          if (res.data.err == 0) {
           console.log(res)
          }
        })
        .catch(err =&gt; {
          console.log(err);
        });</code></pre>

<h3>axios拦截器：</h3>

<p>请求拦截：</p>

<pre class="has"><code class="language-javascript">axios.interceptors.request.use(function (config) {//发送之前进行过滤
    return config;
  }, function (error) {
    return Promise.reject(error);
  });</code></pre>

<p>响应拦截：</p>

<pre class="has"><code class="language-javascript">axios.interceptors.response.use(function (response) {//请求到数据后进行过滤
    return response;
  }, function (error) {
    return Promise.reject(error);
  });</code></pre>

<h3>Vuex：</h3>

<p>作用：多个组件共享状态及数据</p>

<p>安装：npm install vuex</p>

<p>配置：在src中新建store文件夹：在里面新建js文件</p>

<pre class="has"><code class="language-javascript">import Vue from 'vue'
import Vuex from 'vuex'//引入Vuex
Vue.use(Vuex);
import login from './login/index'
const store = new Vuex.Store({
  modules: {
    login: login,
  }
})
export default store;//抛出vuex实例</code></pre>

<p>在src中新建的store文件夹中新建另一个文件夹：里面有5个js文件</p>

<p><img alt="" class="has" src="https://img-blog.csdnimg.cn/20181224152242677.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70"></p>

<p>大致示范一下里面的内容(部分购物车内容，大概看一下就好)：</p>

<h3>index.js</h3>

<pre class="has"><code class="language-javascript">import state from './state';
import mutations from './mutations';
import getters from './getters';
import actions from './actions';
let store = {
  state,
  mutations,
  getters,
  actions
};

export default store;
</code></pre>

<h3>state.js</h3>

<pre class="has"><code class="language-javascript">export default {
  carObj: [],
}
</code></pre>

<h3>getters.js</h3>

<pre class="has"><code class="language-javascript">export default {
  // 派生属性
  all(state) {
    var price = 0;
    var sum = 0;
    var seleceAll = true;
    for (let i = 0; i &lt; state.carObj.length; i++) {
      if (state.carObj[i].sel) {
        price += state.carObj[i].price * state.carObj[i].num;
        sum += state.carObj[i].num;
      }
      seleceAll *= state.carObj[i].sel;
    }
    return {
      price: price,
      sum: sum,
      seleceAll: seleceAll
    }
  }
}
</code></pre>

<h3>mutations.js:</h3>

<pre class="has"><code class="language-javascript">export default {
  //只做状态值得修改 不做任何逻辑操作
  addTo(state, carObj) {
    state.carObj = carObj
  }
}
</code></pre>

<h3>actions.js:</h3>

<pre class="has"><code class="language-javascript">export default {
  // // 异步处理逻辑操作
  initCar({
    commit
  }) {
    let carlist = localStorage.carlist ? JSON.parse(localStorage.carlist) : [];
    commit('addTo', carlist)
  }
}
</code></pre>

<p>主要流程：（官网的）</p>

<p>初步理解就是：通过actions的函数改变states（数据），渲染到所有绑定的页面，页面再次调用actions（函数），再次修改</p>

<p><img alt="" class="has" height="300" src="https://img-blog.csdnimg.cn/20181224153524350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="405"></p>

<p>深层理解：组件触发actions传递数据（抛发），触发mutations修改状态值，修改state的值，渲染到页面</p>

<p><img alt="" class="has" height="402" src="https://img-blog.csdnimg.cn/20181224161037290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="512"></p>

<h3>辅助工具：</h3>

<pre class="has"><code class="language-javascript">import { mapState，mapGetters，mapMutations，mapActions } from 'vuex'
</code></pre>

<p>&nbsp;引入辅助工具使组件可以设置或获取到函数及数据</p>

<pre class="has"><code class="language-javascript">this.$store//获取到store</code></pre>

<p>mapStates：</p>

<pre class="has"><code class="language-javascript">computed: {
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
        //state中的变量名
  })
}</code></pre>

<p>mapGetters：</p>

<pre class="has"><code class="language-javascript"> computed: {
  // 使用对象展开运算符将 getter 混入 computed 对象中
    ...mapGetters([
      'doneTodosCount',
      'anotherGetter'
    ])
  }</code></pre>

<p>&nbsp;mapMutations：</p>

<pre class="has"><code class="language-javascript">methods: {
    ...mapMutations([
      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`
      // `mapMutations` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
    ])
  }</code></pre>

<p>mapActions：</p>

<pre class="has"><code class="language-javascript"> methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`
      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ])
  }</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Vue（一）初识</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/14/10205455.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Fri, 14 Dec 2018 12:56:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/14/10205455.html</guid><description><![CDATA[
                <pre>Vue的意义：将开发者的精力从dom操作解脱，更加专注于数据的操作，</pre>

<pre>数据驱动，界面的渲染 随着数据的变化自动变化
    1.将开发者的精力从dom中解除， 极少做dom操作
    2.通过指令（directive）将元素和数据进行绑定  
    3.数据变化元素界面变化
    4.开发者关注数据的变化</pre>

<p>配置：Vue官网下载；或npm install vue</p>

<h3>js引入包后，实例化Vue对象；</h3>

<pre class="has"><code class="language-javascript">var vm = new Vue({//实例化
             el: '#btn',//选择标签（作用区域）
             data: {//变量（数据），关联页面的标签
                    bool: true
                }，
            methods:{//写方法的对象
                Fn1(){//方法
                        },
                Fn2(){
                        }
                }

            });</code></pre>

<h3>渲染数据：</h3>

<pre class="has"><code class="language-javascript">&lt;div id='app'&gt;{{name}}&lt;/div&gt;//用插值的方式{{}}来放置data的变量</code></pre>

<p>Vue的数据是双向数据的绑定，数据相互依赖，缺点是源头很难找到，但是提升了数据的感知</p>

<h3>指令：</h3>

<p>v-if（条件渲染）</p>

<pre class="has"><code class="language-javascript">&lt;p v-if='bool'&gt;&lt;/p&gt;//条件满足时显示元素
&lt;p v-else&gt;&lt;/p&gt;//否则显示元素
&lt;p v-else-if='bool'&gt;&lt;/p&gt;//条件满足时显示元素</code></pre>

<p>v-for（列表渲染）用for in和for of都行（<span style="color:#f33b45;">注意：若遍历数组的时候有重复项，要用一个bind绑定数据否则会出错，如&lt;li v-for='(item,index) in list' v-bind : key=index&gt;{{item}}--{{index}}&lt;/li&gt;</span>）</p>

<pre class="has"><code class="language-html">//数组
&lt;li v-for='item in list'&gt;{{item}}&lt;/li&gt;//item是每一项，list是操作的数组（根据list的长度新建li）

&lt;li v-for='(item,index) in list'&gt;{{item}}--{{index}}&lt;/li&gt;//item是每一项，index是数组索引，list是操作的数组（根据list的长度新建li）

&lt;li v-for='item in 20'&gt;{{item}}&lt;/li&gt;//直接创造20个li

//字符串
&lt;li v-for='item in "hello vue"'&gt;{{item}}&lt;/li&gt;//遍历字符串，输出9个li分别是字符每一项

//对象
&lt;li v-for="(val,key,index) in obj"&gt;{{key}}:{{val}}---{{index}}&lt;/li&gt;//val,key,index分别是对象的每项的属性，属性名，索引</code></pre>

<p>v-click（事件指令）</p>

<pre class="has"><code class="language-html">&lt;button v-on:click="test"&gt;点我&lt;/button&gt;//类似于onclick，test是Vue实例化中的函数
//v-on:click相当于@click
&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;//取消冒泡事件
&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;//只有点击这个元素自身才会触发</code></pre>

<p>v-bind（属性设置）</p>

<pre class="has"><code class="language-html">&lt;div v-bind:class='state?"red":"green"'&gt;//v-bind：'属性名'='属性值'
//可以写成&lt;div v-bind:class='state?"red":"green"'&gt;</code></pre>

<h3>过滤器：（对数据进行处理的函数）</h3>

<p>全局过滤器：和局部过滤的区别（局部过滤器只能在当前的组件中使用）</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;

        &lt;/style&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            {{nowTime|getTime}}
            &lt;!--  这是参数   这是过滤，中间用|隔开--&gt;
        &lt;/div&gt;
        &lt;script&gt;
            //全局过滤
            Vue.filter('getTime', function (value) {
                //中间可以写对数据的处理
                return value;
            });
            var vm = new Vue({
                el: '#box',
                data: {
                    nowTime: Date.now()
                }
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>局部过滤：</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;

        &lt;/style&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            {{nowTime|getTime}}
            &lt;!--  这是参数   这是过滤，中间用|隔开--&gt;
        &lt;/div&gt;
        &lt;script&gt;
            //局部过滤
            var vm = new Vue({
                el: '#box',
                data: {
                    nowTime: Date.now()
                },
                filters: {
                    getTime: function (value) {
                        //中间可以写对数据的处理
                        return value;
                    }
                }
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h3>组件：就是vue的一个拓展实例</h3>

<p>全局组件：（整个页面都能使用）</p>

<pre class="has"><code class="language-html">&lt;template id="tp1"&gt;
            &lt;!-- 组件创建 --&gt;
            &lt;div&gt;&lt;/div&gt;
&lt;/template&gt;</code></pre>

<pre class="has"><code class="language-javascript">var mod = {//组件配置
                template: '#tp1',//选中组件
                data() {
                    return {
                    //写变量
                }
                },
                methods: {
                    //写函数
                }
            }</code></pre>

<pre class="has"><code class="language-javascript">Vue.component('mod', mod);//注册组件</code></pre>

<pre class="has"><code class="language-html">//直接在页面中输入
&lt;mod&gt;&lt;/mod&gt;
//即可使用</code></pre>

<p>局部组件：（只能在当前选中作用范围中使用）</p>

<pre class="has"><code class="language-javascript">let box = new Vue({
                el: '#box',//当前作用范围是id为box的标签内
                data: {
                    
                },
                methods: {
                   
                },
                components: {//新建局部组件
                    mod: ({
                        template: '#tp1',
                        data() {
                            return {}
                        },
                        methods: {

                        }
                    })
                }
            });</code></pre>

<h3>组件间数据的传输：（类似事件抛发和监听）</h3>

<p>父组件传给子组件：</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;fat&gt;&lt;/fat&gt;
        &lt;/div&gt;
        &lt;!-- 子组件 --&gt;
        &lt;template id="son"&gt;
            &lt;div&gt;{{callson}}&lt;/div&gt;
        &lt;/template&gt;
        &lt;!-- 父组件，父组件中包含子组件 --&gt;
        &lt;template id="fat"&gt;
            &lt;div&gt;
                &lt;!-- 当父组件数据改变时，通过将数据保存在自身属性的方法传输 --&gt;
                &lt;div&gt;{{fbool}}&lt;/div&gt;
                &lt;button @click='change'&gt;Change&lt;/button&gt;
                &lt;!-- 将callson作为属性，附带数据传输给子元素 --&gt;
                &lt;son :callson='fbool'&gt;&lt;/son&gt;
            &lt;/div&gt;
        &lt;/template&gt;
        &lt;script&gt;
            Vue.component('son', {
                template: '#son',
                data: function () {
                    return {

                    }
                },
                props: ['callson'] //子组件在该处接收数据
            });
            Vue.component('fat', {
                template: '#fat',
                data: function () {
                    return {
                        fbool: false
                    }
                },
                methods: { //点击父组件的按钮时，父组件内数据改变
                    change() {
                        this.fbool = !this.fbool;
                    }
                }
            });
            var box = new Vue({
                el: '#box'
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>子组件传给父组件：</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;fat&gt;&lt;/fat&gt;
        &lt;/div&gt;
        &lt;template id="son"&gt;
            &lt;div&gt;
                &lt;button @click='change'&gt;Change&lt;/button&gt;
                &lt;!-- &lt;div&gt;{{sbool}}&lt;/div&gt; --&gt;
            &lt;/div&gt;

        &lt;/template&gt;
        &lt;template id="fat"&gt;
            &lt;div&gt;
                &lt;div&gt;{{fbool}}&lt;/div&gt;
                &lt;!-- 新建自定义事件，绑定父元素中的函数，传参数写在后面用逗号隔开 --&gt;
                &lt;son @callfat='changeF'&gt;&lt;/son&gt;
                &lt;!-- 当子元素被点击时触发父元素的方法 --&gt;
            &lt;/div&gt;
        &lt;/template&gt;
        &lt;script&gt;
            Vue.component('son', {//点击子组件的按钮时，子组件内数据改变
                template: '#son',
                data: function () {
                    return {
                        sbool: false
                    }
                },
                methods: {
                    change() {
                        this.$emit('callfat');
                        this.sbool = !this.sbool;
                    }
                }
            });
            Vue.component('fat', { 
                template: '#fat',
                data: function () {
                    return {
                        fbool: false
                    }
                },
                methods: {
                    changeF() {
                        this.fbool = !this.fbool;
                    }
                }
            });
            var box = new Vue({
                el: '#box'
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>兄弟组件：（结合子传父，父再传子）：</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;fat&gt;&lt;/fat&gt;
        &lt;/div&gt;
        &lt;template id="sonf"&gt;
            &lt;div&gt;
                &lt;button @click='change'&gt;Change&lt;/button&gt;
                &lt;div&gt;First &lt;br&gt;{{sfbool}}&lt;/div&gt;
            &lt;/div&gt;

        &lt;/template&gt;
        &lt;template id="sons"&gt;
            &lt;div&gt;Second &lt;br&gt;{{callson}}&lt;/div&gt;
        &lt;/template&gt;
        &lt;template id="fat"&gt;
            &lt;div&gt;
                &lt;sonf @callfat='changeF'&gt;&lt;/sonf&gt;
                &lt;sons :callson='fbool'&gt;&lt;/sons&gt;
            &lt;/div&gt;
        &lt;/template&gt;
        &lt;script&gt;
            Vue.component('sonf', {
                template: '#sonf',
                data: function () {
                    return {
                        sfbool: false
                    }
                },
                methods: {
                    change() {
                        this.$emit('callfat');
                        this.sfbool = !this.sfbool;
                    }
                }
            });

            Vue.component('sons', {
                template: '#sons',
                data: function () {
                    return {

                    }
                },
                props: ['callson']
            });

            Vue.component('fat', {
                template: '#fat',
                data: function () {
                    return {
                        fbool: false
                    }
                },
                methods: {
                    changeF() {
                        this.fbool = !this.fbool;
                    }
                }
            });
            var box = new Vue({
                el: '#box'
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>不相邻兄弟组件：</p>

<pre class="has"><code class="language-javascript">let angel=new Vue();//引入一个Vue实例</code></pre>

<pre class="has"><code class="language-javascript">angel.$emit('test','Hello')//传送方在函数中抛出事件及数据
angel.$on('test',this.change)//接收方接收事件及数据</code></pre>

<h3>动画：</h3>

<pre class="has"><code class="language-html">&lt;transition name='aaa'&gt;css中用name值进行动画
若中间有1个以上元素，需要在外面嵌套一个元素，再给该元素加
  	&lt;div v-if='show'&gt;
  		&lt;p&gt;Hello&lt;/p&gt;
  	    &lt;p&gt;World&lt;/p&gt;
  	&lt;/div&gt;
&lt;/transition&gt;</code></pre>

<pre class="has"><code class="language-css">        .aaa-enter{进入前
			opacity: 0;
		}
		.aaa-enter-to{进入后
			opacity: 1;
		}
		.aaa-enter-active{过渡时间
			transition: all 3s;
		}

		.aaa-leave{离开前
			opacity: 1;
		}
		.aaa-leave-to{离开后
			opacity: 0;
		}
		.aaa-leave-active{过渡时间
			transition: all 3s;
		}</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Vue（三）两个案例（todolist，tableBar）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/11/10205456.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 11 Dec 2018 03:57:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/11/10205456.html</guid><description><![CDATA[
                <h3>待办事项：</h3>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;
            #addItem{
        font-size: 28px;
        vertical-align: middle;  
    }
    #txt{
        height: 30px;
        width: 250px;
        vertical-align: middle;
    }
    li{
        list-style: none;
        width: 400px;
        height: 70px;
        line-height: 70px;
        border: 1px solid lightgreen;
    }
    li:hover{
        background: lightcoral;
    }
&lt;/style&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;input id="txt" type="text"&gt;&lt;button id="addItem" v-on:click='createList'&gt;+&lt;/button&gt;
            &lt;ul&gt;
                &lt;li v-for='(item,index) in list'&gt;{{item.value}}
                    &lt;span v-if='item.sure' style="color:red;font-size: 18px"&gt;Be Sure&lt;/span&gt;
                    &lt;button v-on:click="delItem(index)"&gt;Del&lt;/button&gt;
                    &lt;button v-if='!item.sure' v-on:click='item.sure=true'&gt;Sure&lt;/button&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;script&gt;
            let add = new Vue({
                el: '#box',
                data: {
                    list: []
                },
                methods: {
                    createList() {
                        this.list.push({
                            value: txt.value,
                            sure: false
                        });
                    },
                    delItem(num){
                        this.list.splice(num,1);
                    }
                }
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h3>table选项卡：</h3>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;
            li {
                list-style: none;
                text-align: center;
            }

            #box {
                width: 280px;
                margin: 50px auto;
                background: lightblue;
            }

            #box:after {
                content: '';
                height: 0;
                clear: both;
                visibility: hidden;
                display: block;
            }

            #title li {
                width: 50px;
                height: 30px;
                float: left;
                padding: 20px 15px;
            }

            #title li:hover {
                background: lightcoral;
            }

            #content {
                display: block;
            }
        &lt;/style&gt;
        &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;ul id="title"&gt;
                &lt;li v-for='(item,index) in list' v-on:click='changeContent(index)'&gt;{{index}}&lt;/li&gt;
            &lt;/ul&gt;
            &lt;ul id="content"&gt;
                &lt;li v-for='(item,index) in list[str]'&gt;{{item}}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;script&gt;
            var vm = new Vue({
                el: '#box',
                data: {
                    list: {
                        'movie': ['aaa', 'bbb', 'ccc', 'ddd', 'aaa', 'bbb', 'ccc', 'ddd', 'aaa', 'bbb', 'ccc',
                            'ddd', 'aaa', 'bbb', 'ccc', 'ddd'
                        ],
                        'game': ['eee', 'fff', 'ggg', 'hhh', 'eee', 'fff', 'ggg', 'hhh', 'eee', 'fff', 'ggg',
                            'hhh', 'eee', 'fff', 'ggg', 'hhh', 'eee', 'fff', 'ggg', 'hhh'
                        ],
                        'music': ['iii', 'jjj', 'kkk', 'lll', 'mmm', 'iii', 'jjj', 'kkk', 'lll', 'mmm', 'iii',
                            'jjj', 'kkk', 'lll', 'mmm', 'iii', 'jjj', 'kkk', 'lll', 'mmm', 'iii', 'jjj',
                            'kkk', 'lll', 'mmm'
                        ]
                    },
                    str: ''
                },
                methods: {
                    changeContent(data) {
                        this.str = data;
                    }
                }
            });
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：轮播图（面向对象），最终版（注释全面）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/08/10193682.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 08 Dec 2018 13:46:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/08/10193682.html</guid><description><![CDATA[
                <h2>Html：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;Carousel&lt;/title&gt;
    &lt;script src="js/Carousel.js"&gt;&lt;/script&gt;
    &lt;style&gt;&lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;script&gt;
      var arr = ["img/left.png", "img/right.png"]; //左右按钮
      var arr1 = [
        "img/a.png",
        "img/b.png",
        "img/c.png",
        "img/d.png",
        "img/e.png"
      ]; //新建源
      var arr2 = [
        "img/1.jpg",
        "img/2.jpg",
        "img/3.jpg",
        "img/4.jpg",
        "img/5.jpg",
        "img/6.jpg",
        "img/7.jpg"
      ]; //新建源
      var arr3 = ["img/aaa.jpg", "img/bbb.jpg", "img/ccc.jpg"]; //新建源
      var carousel = new Carousel(document.body, arr1, arr); //实例化轮播图
      var carousel2 = new Carousel(document.body, arr2, arr); //实例化轮播图
      var carousel3 = new Carousel(document.body, arr3, arr); //实例化轮播图
      carousel.autoPlay = true; //自动播放
      carousel2.autoPlay = true; //自动播放
      carousel3.autoPlay = true; //自动播放
      // carousel.heightValue = 600;//高宽可控
      // carousel3.widthValue =1600;//高宽可控
      animate();

      function animate() {
        //用一个动画函数控制轮播
        requestAnimationFrame(animate);
        carousel.animate();
        carousel2.animate();
        carousel3.animate();
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>Js：</h2>

<pre class="has"><code class="language-javascript">var Carousel = (function () {
    var liStyle = { //初始化下面的小点样式
        width: "20px",
        height: "20px",
        borderRadius: "20px",
        backgroundColor: "rgba(240,137,137,0.3)",
        border: "1px solid #F08989",
        float: "left",
        lineHeight: "20px",
        textAlign: "center",
        marginLeft: "20px",
        color: "white"
    };
    var ulStyle = { //小点盒子
        margin: 0,
        padding: 0,
        listStyle: "none",
        position: "absolute",
        bottom: "20px"
    };
    var imgConStyle = { //图片盒子
        position: "absolute",
        left: "0px"
    };
    var maskDivStyle = { //最大的盒子
        overflow: "hidden",
        position: "relative",
        margin: "auto",
        backgroundColor: "antiquewhite"
    };
    //功能：实现高宽可改，图片预加载，可换图片源
    function Carousel(parent, list, btnList) {
        this.init(parent, btnList); //入口函数
        this.sourse = list; //引入图片源
    }
    Carousel.prototype = {
        loadImg: null, //正在加载的图片
        imgList: [], //加载的图片
        carouselBox: null, //装图片的盒子（最大的盒子）
        _width: 0, //可修改的宽
        _height: 0, //可修改的高
        _sourse: [], //加载图片的源（路径）
        bool: false, //是否允许轮播
        index: 0, //当前加载图片的索引
        direct: "", //轮播方向
        speed: 30, //轮播的速度
        autoPlay: false, //是否自动轮播
        dotLi: null, //小点，根据源的图片数切换
        autoTime: 200, //自动轮播时间间隔，以每帧乘以200计算
        set sourse(value) { //设置切换的源时初始化其他属性
            if (!value || !Array.isArray(value) || !value.length) return; //当源不是数组或者为空时，截断并跳出
            this.widthValue = 0;
            this.heightValue = 0; //初始化宽高
            if (this.loadImg) { //初始化加载的图片，设为空
                this.loadImg.removeEventListener("load", this.loadImgHandler);
            }
            this.imgList.length = 0; //清空图片列表
            this._sourse = value; //传入源
            this.reLoadImg(value); //执行加载图片
        },
        get sourse() {
            return this._sourse;
        },
        set widthValue(value) {
            this._width = value; //根据传入的宽度改变轮播图宽度
            if (this._width === 0) return;
            this.carouselBox.style.width = value + "px"; //每次更新，轮播图宽度改变
            var ul = this.carouselBox.lastElementChild; //初始化，装小点的盒子
            ul.style.left = (value - ul.offsetWidth) / 2 + "px"; // 当宽度改变时，小点自适应（定位在盒子宽度中间）
        },
        get widthValue() {
            return this._width;
        },
        set heightValue(value) { //根据传入的高度改变轮播图高度
            this._height = value;
            if (this._height === 0) return;
            this.carouselBox.style.height = value + "px";
            this.carouselBox.firstElementChild.style.height = value + "px"; //每次更新，轮播图高度改变
            this.carouselBox.children[1].style.top = this.carouselBox.children[2].style.top = (this.heightValue - this.carouselBox.children[1].offsetHeight) / 2 + "px"; // 当宽度改变时，左右按钮自适应（定位在盒子高度中间）
        },
        get heightValue() {
            return this._height;
        },
        reLoadImg: function (list) {
            var img = new Image(); //生成初始图片
            img.addEventListener("load", this.loadImgHandler); //图片加载完成后，执行下一张图片加载
            img.self = this;
            img.num = 0; //当前图片索引
            img.list = list;
            img.imgList = []; //图片列表初始
            img.src = list[img.num]; //通过事件传数据
        },
        loadImgHandler: function (e) {
            this.imgList.push(this.cloneNode(false)); //图片列表放入被加载的图片
            this.num++; //下一张图片索引
            if (this.num &gt; this.list.length - 1) { //当全部加载完成后，继续执行其他函数
                this.self.imgLoadFinish(this.imgList);
                return;
            }
            this.src = this.list[this.num]; //否则继续加载
        },
        init: function (parent, btnList) { //入口函数
            if (!this.carouselBox) { //保证对象单例
                this.carouselBox = document.createElement("div"); //装图片的盒子（最大的盒子）
                var imgBox = document.createElement("div"); //加载图片的盒子，装在最大的盒子里，控制图片切换和移动
                this.carouselBox.appendChild(imgBox);
                for (var i = 0; i &lt; btnList.length; i++) { //加载按钮
                    var btimg = new Image();
                    btimg.src = btnList[i];
                    this.carouselBox.appendChild(btimg);
                    if (i === 0) { //设置位置
                        btimg.style.left = "10px";
                        btimg.style.position = "absolute";
                    } else {
                        btimg.style.right = "10px";
                        btimg.style.position = "absolute";
                    }
                    btimg.self = this;
                    this.carouselBox.self = this;
                    this.carouselBox.addEventListener("mouseenter", this.isAuto); //控制开启关闭自动轮播
                    this.carouselBox.addEventListener("mouseleave", this.isAuto);
                    btimg.addEventListener("click", this.changeImgHandler); //加载点击事件
                }
                var ul = document.createElement("ul"); //小点盒子
                Object.assign(ul.style, ulStyle); //设置样式
                Object.assign(this.carouselBox.style, maskDivStyle); //设置样式
                Object.assign(imgBox.style, imgConStyle); //设置样式
                this.carouselBox.appendChild(ul);
                parent.appendChild(this.carouselBox);
            }
            return this.carouselBox;
        },
        imgLoadFinish: function (imgList) { //图片加载完成后执行，传入图片列表
            this.imgList = imgList;
            var imgCon = this.carouselBox.firstElementChild; //初始化小点盒子和图片盒子（不是最大的盒子）
            var ul = this.carouselBox.lastElementChild;
            this.clearNode(imgCon); //清除子元素方法（初始化）
            this.clearNode(ul);
            for (var i = 0; i &lt; this.imgList.length; i++) { //创建小点
                var li = document.createElement("li");
                ul.appendChild(li);
                Object.assign(li.style, liStyle); //小点样式
            }
            ul.style.left = (this.widthValue - ul.offsetWidth) / 2 + "px"; //小点盒子的默认位置
            imgCon.appendChild(this.imgList[0]);
            ul.self = this;
            ul.addEventListener("click", this.changeDot); //小点点击事件
            if (this.widthValue === 0) {
                this.widthValue = this.imgList[0].width; //当传入的宽为0时，将宽设置为默认宽
            } else {
                this.carouselBox.style.width = this.widthValue + "px"; //否则设置为改变的宽
                this.setSize(imgCon, this.widthValue, 0); //调用下面的设置宽高方法，将图片宽高重设
            }
            if (this.heightValue === 0) { //同上
                this.heightValue = this.imgList[0].height;
            } else {
                this.carouselBox.style.height = this.heightValue + "px";
                imgCon.firstElementChild.style.height = this.heightValue + "px";
                this.setSize(imgCon, 0, this.heightValue);
            }
            this.dotColor(); //执行小点样式切换
            this.carouselBox.children[1].style.top = this.carouselBox.children[2].style.top = (this.heightValue - this.carouselBox.children[1].offsetHeight) / 2 + "px"; //按钮位置重设，自适应
        },
        setSize: function (con, w, h) { //设置子元素宽高函数
            for (var i = 0; i &lt; con.children.length; i++) {
                if (w) {
                    con.children[i].style.width = w + "px";
                }
                if (h) {
                    con.children[i].style.height = h + "px";
                }
            }
        },
        clearNode: function (node) { //清除子元素函数
            var len = node.children.length;
            for (var i = 0; i &lt; len; i++) {
                node.firstElementChild.remove();
            }
        },
        changeImgHandler: function (e) {
            if (this.self.bool) return; //当点击一次后，执行完一次轮播才能再次点击
            if (this.style.left === "10px") { //根据位置判断左右按钮
                this.self.direct = "right"; //改变轮播方向
                this.self.index--; //索引值减一，即加载上一张图片
                if (this.self.index &lt; 0) { //当减到0时，加载最后一张
                    this.self.index = this.self.imgList.length - 1;
                }
            } else if (this.style.right === "10px") { //同上（相反）
                this.self.direct = "left";
                this.self.index++;
                if (this.self.index &gt; this.self.imgList.length - 1) {
                    this.self.index = 0;
                }
            }
            this.self.creatNextPic(); //跳到加载下一张图片函数
        },
        creatNextPic: function () {
            if (this.direct !== "left" &amp;&amp; this.direct !== "right") return; //当未点击左或者右时跳出
            var imgCount = this.carouselBox.firstElementChild; //获取装图片的盒子（控制图片轮播的盒子，不是最大的盒子）
            if (this.direct === "left") { //当方向为左，即单击了左按钮
                imgCount.appendChild(this.imgList[this.index]); //装图片的盒子根据当前索引加入图片（插在后面）
                imgCount.style.width = this.widthValue * 2 + "px"; //装图片的盒子宽度设置为图片宽度的两倍（放下两张图片）
                imgCount.style.left = 0; //初始盒子位置
            } else {
                imgCount.insertBefore(this.imgList[this.index], imgCount.firstElementChild); //装图片的盒子根据当前索引加入图片（插在前面）
                imgCount.style.width = this.widthValue * 2 + "px"; //装图片的盒子宽度设置为图片宽度的两倍（放下两张图片）
                imgCount.style.left = -this.widthValue + "px"; //初始盒子位置
            }
            if (!this.widthValue) { //重设宽高
                this.imgList[this.index].style.width = this.widthValue + "px";
            }
            if (!this.heightValue) {
                this.imgList[this.index].style.height = this.heightValue + "px";
            }
            this.dotColor(); //切换小点颜色
            this.bool = true; //允许下一次点击
        },
        movePic: function () { //轮播动画
            if (!this.bool) return; //若没加载好下一张，跳出
            if (this.direct !== "left" &amp;&amp; this.direct !== "right") {
                this.bool = false;
                return;
            } //若没单击，跳出
            var imgCount = this.carouselBox.firstElementChild; //初始图片盒子
            if (this.direct === "left") { //轮播方向为左时，以设定的速度向左移动
                imgCount.style.left = imgCount.offsetLeft - this.speed + "px";
                if (imgCount.offsetLeft &lt;= -this.widthValue) { //当后面的图片移动到0时停止
                    imgCount.firstElementChild.remove(); //删除左边的图片
                    imgCount.style.left = 0 + "px"; //初始化盒子的位置
                    this.direct = ""; //制空方向，将轮播开关关闭，需要下次点击才打开
                    this.bool = false;
                }
            } else { //轮播方向为右时，以设定的速度向右移动
                imgCount.style.left = imgCount.offsetLeft + this.speed + "px";
                if (imgCount.offsetLeft &gt;= 0) { //当前面的图片移动到0时停止
                    imgCount.lastElementChild.remove(); //删除右边的图片
                    imgCount.style.left = 0 + "px"; //初始化盒子的位置
                    this.direct = ""; //制空方向，将轮播开关关闭，需要下次点击才打开
                    this.bool = false;
                }
            }
        },
        changeDot: function (e) {
            if (this.self.bool) return; //点击按钮或小点时，跳出
            if (e.target instanceof HTMLUListElement) return; //没有点击小点(li）时跳出
            var arr = Array.from(this.children); //小点数组化
            var count = arr.indexOf(e.target); //查找小点索引
            if (count === this.self.index) return; //点击自身时跳出
            if (count &gt; this.self.index) { //当点击的小点大于当前小点时，将方向置为左
                this.self.direct = "left";
            } else if (count &lt; this.self.index) { //反之向右
                this.self.direct = "right";
            }
            this.self.index = count; //将图片索引设置为点击小点索引
            this.self.creatNextPic(); //创建下张图片
            this.self.dotColor(); //改变小点样式
        },
        dotColor: function () { //前一个小点背景透明
            if (this.dotLi) {
                this.dotLi.style.backgroundColor = "rgba(240,137,137,0.3)";
            } //将被切换的小点赋值给当前小点，使其根据计数器切换
            this.dotLi = this.carouselBox.lastElementChild.children[this.index];
            this.dotLi.style.backgroundColor = "rgba(240,137,137,1)";
        },
        isAuto: function (e) { //根据鼠标是否进入轮播图判断是否自动轮播
            if (e.type === "mouseenter") {
                this.self.autoPlay = false;
            } else {
                this.self.autoPlay = true;
            }
        },
        carouselAuto: function () { //自动轮播
            if (!this.autoPlay) return; //当计数器为0时执行一次
            this.autoTime--; //每帧使计时器减一
            if (this.autoTime &gt; 0) return;
            this.autoTime = 200;
            this.direct = "left"; //默认自动轮播方向
            this.index++;
            if (this.index &gt; this.imgList.length - 1) {
                this.index = 0;
            }
            this.creatNextPic(); //创建下一张图
        },
        animate: function () { //单一动画，每帧执行一次，将动画放在一个函数内
            this.movePic();
            this.carouselAuto();
        }
    };
    Carousel.prototype.constructor = Carousel;
    return Carousel;
})();</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（十二）加密解密</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/05/10193683.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Wed, 05 Dec 2018 10:01:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/05/10193683.html</guid><description><![CDATA[
                <h3>token：（引入jsonwebtoken模块）</h3>

<h3><br>
对称加密，一个秘钥进行加密解密</h3>

<pre class="has"><code class="language-javascript">const crypto = require('crypto');

// 产生token

let obj = {

    a: 1,

    b: 2,

};

let sec = 'HelloWorld'

let res = jwt.sign(obj, sec,{ algorithm: 'RS256'});//传入加密的对象，秘钥，加密方式

console.log(res);

//解析token

let sec2 = jwt.verify('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhIjoxLCJiIjoyLCJpYXQiOjE1NDM5ODA0NTF9.ORMQa_LBbDCd7XEEHgVGN2EnccL2kTOyDidE-b4ANMY', sec);

console.log(sec2);
</code></pre>

<h3>非对称加密，通过私钥进行加密，公钥解密</h3>

<p>产生私钥 openssl genrsa -out private_key.pem 1024</p>

<p>由私钥产生公钥 openssl rsa -in private_key.pem -pubout -out public_key.pem</p>

<pre class="has"><code class="language-javascript">var selfkey = fs.readFileSync(path.join(__dirname, 'key.pem'));//读取私钥路径
var jwtset = jwt.sign({
    a: 1,
    b: 2,
    c: 3
}, selfkey, {
    algorithm: 'RS256'
});
console.log(jwtset);

var otherkey = fs.readFileSync(path.join(__dirname, 'public_key.pem'));//读取公钥路径
var jwtget = jwt.verify(jwtset, otherkey, {
    algorithm: 'RS256'
});
console.log(jwtget);</code></pre>

<h3>&nbsp;crypto和bcrypt</h3>

<pre class="has"><code class="language-javascript">// 数据库密码加密
// 内置crypto
// MD5
const hash = crypto.createHash('md5');
hash.update('HelloWorld');
console.log(hash.digest('hex'));
// Hmac
const hmac = crypto.createHmac('sha256', '12345');
hmac.update('HelloWorld');
console.log(hmac.digest('hex'));
// 第三方bcrypt
const pass = 'qazwsx123';
const saltRounds = 10;
bcrypt.genSalt(saltRounds, (err, salt) =&gt; {
    bcrypt.hash(pass, salt, (err, hash) =&gt; {
        let result= bcrypt.compareSync('qazwsx123', hash);
        console.log(result);
    });
});</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：轮播图（第二代）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/04/10193684.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 04 Dec 2018 12:09:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/04/10193684.html</guid><description><![CDATA[
                <p>较上个版本功能全面，函数模块化，降低联系，bug减少，附上代码：</p>

<h2>Html：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;link rel="stylesheet" href="./css/main.css"&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;div id="pic_box"&gt;&lt;/div&gt;
            &lt;img id="left" src="img/left.png" alt=""&gt;
            &lt;img id="right" src="img/right.png" alt=""&gt;
            &lt;ul id="dot_box"&gt;&lt;/ul&gt;
        &lt;/div&gt;

        &lt;script src="./js/main.js"&gt;

        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>Css：</h2>

<pre class="has"><code class="language-css">* {
    margin: 0;
    padding: 0;
}

#box {
    margin: 50px auto;
    width: 960px;
    height: 320px;
    background: lightcoral;
    position: relative;
    overflow: hidden;
}

#pic_box {
    height: 320px;
    background: lightblue;
    position: absolute;
}

#left {
    position: absolute;
    top: 130px;
    left: 10px;
}

#right {
    position: absolute;
    top: 130px;
    right: 10px;
}

ul {
    list-style: none;
    position: absolute;
    bottom: 20px;
    left: 400px;
}

li {
    width: 20px;
    height: 20px;
    list-style: none;
    border-radius: 50%;
    float: left;
    margin-left: 5px;
}</code></pre>

<h2>JS：</h2>

<pre class="has"><code class="language-javascript">var box, pic_box, left, right, dot_box, liList; //定义最外面的大盒子，装图片的盒子，左右按键，盒子下面的小点容器，及当前小点容器.
var count = 0; //记录当前显示的图片索引
var num = 160; //定时器帧数控制
var direct; //左右方向（方向为左向右移动，反之向左移动）方向是按钮的方向
var bool = false; //控制是否允许轮播
var autoPlay = false; //是否自动轮播
var picurl = ["img/a.jpeg", "img/b.jpeg", "img/c.jpeg", "img/d.jpeg", "img/e.jpeg"]; //图片路径
var piclist = []; //加载的图片（两张）
init(); //入口函数

function init() { //获取所有元素并赋值给变量，添加事件
    box = document.getElementById("box");
    pic_box = document.getElementById("pic_box");
    left = document.getElementById("left");
    right = document.getElementById("right");
    dot_box = document.getElementById("dot_box");
    left.addEventListener("click", picChange); //点击左键
    right.addEventListener("click", picChange); //点击右键
    box.addEventListener("mouseenter", isAuto); //鼠标进入大盒子取消自动轮播
    box.addEventListener("mouseleave", isAuto); //鼠标离开大盒子自动轮播
    creatImg(); //初始化并加载所有图片
    animation(); //开启每帧移动函数
    creatDot(); //新建小点（点击切换图片）
}

function creatImg() {
    for (var j = 0; j &lt; picurl.length; j++) { //根据图片源新建图片
        piclist[j] = new Image();
        piclist[j].src = picurl[j];
        piclist[j].style.width = "960px";
        piclist[j].style.height = "320px";
    }
    pic_box.appendChild(piclist[0]); //初始化装图片的盒子，插入第一张图片

}

function picChange(e) {
    if (bool) return; //若轮播开关为真时，不执行函数，即点击一次后需要等整张图片轮播完才能点击下一次
    if (this === left) { //当单击向左按钮
        direct = "left"; //将方向改成左
        count--; //图片索引减一
        if (count === -1) { //当减到-1时，让索引为图片总数减一（数组从零开始）
            count = picurl.length - 1;
        }
    } else if (this === right) { //当单击向右按钮
        direct = "right"; //将方向改成右
        count++; //图片索引加一
        if (count === picurl.length) { //当加到图片总数减一时，让索引为0（数组从零开始）
            count = 0;
        }
    }
    nextPic(); //创造下一张
}

function nextPic() { //加载下一张图片

    pic_box.style.width = 960 * 2 + "px"; //初始化位置
    if (direct === "right") { //当方向为右时，在图片后面插入下一张图片
        pic_box.appendChild(piclist[count]);
        pic_box.style.left = 0;
    } else if (direct === "left") { //当方向为左时，在图片前面插入下一张图片
        pic_box.insertBefore(piclist[count], pic_box.firstElementChild);
        pic_box.style.left = -960 + "px";
    }
    bool = true; //图片加载完成后，让控制图片轮播的开关为真，防止图片轮播时执行其他事件
    liChange(); //让小点改变
}

function animation() { //动画函数，自动轮播和轮播
    requestAnimationFrame(animation);
    picMove();
    autoScroll();
}

function creatDot() { //新建小点，控制点击切换图片
    for (var i = 0; i &lt; picurl.length; i++) {
        var li = document.createElement("li");
        dot_box.appendChild(li);
        li.style.background = "rgba(255,255,255,0.7)";
    }
    dot_box.firstElementChild.style.background = "rgba(255,255,255,1)"; //默认选中第一个小点
    dot_box.addEventListener("click", changeDot); //点击小点触发事件，切换图片
    liChange();
}

function changeDot(e) {
    if (bool) return; //若轮播开关为真时，不执行函数，即点击一次后需要等整张图片轮播完才能点击下一次
    var list = Array.from(dot_box.children); //将小点放至数组
    var index = list.indexOf(e.target); //查找当前的小点
    if (index === count) { //若当前点击的图片与索引相等，表示不切换（就是本身）
        return;
    }
    if (index &gt; count) { //当点击的小点在当前右边，将方向换成右
        direct = "right";
    } else if (index &lt; count) { //当点击的小点在当前左边，将方向换成左
        direct = "left";
    }
    count = index; //将当前索引切换成点击的那个
    nextPic(); //新建下一张图片
}

function liChange() {
    if (liList) { //前一个小点背景透明
        liList.style.backgroundColor = "rgba(255,255,255,0.7)";
    }
    liList = dot_box.children[count]; //将被切换的小点赋值给当前小点，使其根据计数器切换
    liList.style.background = "rgba(255,255,255,1)";
}

function picMove() {
    if (!bool) return; //若轮播开关为假时，不执行函数，即点击一次按钮或小点后才能开始轮播
    if (direct === "left") { //向右移动
        pic_box.style.left = pic_box.offsetLeft + 20 + "px"; //移动速度，每次20px，当移动到0时关闭轮播开关，并将最后一张图删除
        if (pic_box.offsetLeft === 0) {
            bool = false;
            pic_box.lastElementChild.remove();
        }
    } else if (direct === "right") { //向左移动
        pic_box.style.left = pic_box.offsetLeft - 20 + "px"; //移动速度，每次-20px，当移动到-960时关闭轮播开关，并将第一张图删除，重置位置为0
        if (pic_box.offsetLeft === -960) {
            bool = false;
            pic_box.firstElementChild.remove();
            pic_box.style.left = 0;
        }
    }
}

function autoScroll() { //自动轮播
    if (!autoPlay) return; //若自动轮播开关为非（鼠标移入时），不自动轮播
    num--; //定时器帧数计数器减一，减到0时赋值为160
    if (num === 0) {
        num = 160;
        direct = "right";
        count++;
        if (count === picurl.length) {
            count = 0;
        }
        nextPic();
    }

}

function isAuto(e) { //鼠标移入时，不自动轮播，反之，自动轮播
    if (e.type === "mouseenter") {
        autoPlay = false;
    } else if (e.type = "mouseleave") {
        autoPlay = true;
    }
}</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：轮播图（第一代）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/04/10193685.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 04 Dec 2018 06:53:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/04/10193685.html</guid><description><![CDATA[
                <h2>初级版轮播图，实现左右按钮切换图片，下方小点切换图片，简单的自动轮播</h2>

<p>代码：（缺点，固定图片张数和宽度高度，每次用时都需要复制，代码累赘，多处功能不完善）</p>

<h2>Html：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
        &lt;title&gt;Page Title&lt;/title&gt;
        &lt;link rel="stylesheet" href="./css/main.css"&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="box"&gt;
            &lt;div id="pic_box"&gt;&lt;/div&gt;
            &lt;img id="left" src="img/left.png" alt=""&gt;
            &lt;img id="right" src="img/right.png" alt=""&gt;
            &lt;ul id="dot_box"&gt;&lt;/ul&gt;
        &lt;/div&gt;
        &lt;script src="./js/main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>Css：</h2>

<pre class="has"><code class="language-css">* {
    margin: 0;
    padding: 0;
}

#box {
    margin: 50px auto;
    width: 960px;
    height: 320px;
    background: lightcoral;
    position: relative;
    overflow: hidden;
}

#pic_box {
    height: 320px;
    width: 4800px;
    background: lightblue;
    position: absolute;
    transition: all 1s;
}

#left {
    position: absolute;
    top: 130px;
    left: 10px;
}

#right {
    position: absolute;
    top: 130px;
    right: 10px;
}

ul {
    list-style: none;
    position: absolute;
    bottom: 20px;
    left: 400px;
}

li {
    width: 20px;
    height: 20px;
    list-style: none;
    border-radius: 50%;
    border: 3px solid lightcoral;
    float: left;
    margin-left: 5px;
}</code></pre>

<h2>JS：</h2>

<pre class="has"><code class="language-javascript">var pic_box, box, left, right, dot_box, dot, count = 0; //定义装图片的盒子，最外面的大盒子，左右按键，盒子下面的小点容器，及当前小点容器，计数值，记录当前显示的图片张数
var arr_img = ["a.jpeg", "b.jpeg", "c.jpeg", "d.jpeg", "e.jpeg"];
//图片路径
init();

function init() { //入口函数，获取所有元素并赋值给变量
    dot_box = document.getElementById("dot_box");
    pic_box = document.getElementById("pic_box");
    box = document.getElementById("box");
    left = document.getElementById("left");
    right = document.getElementById("right");
    pic_box.style.left = 0; //放图片的盒子左边相对父元素（最大的盒子）定位初始化
    for (var i = 0; i &lt; arr_img.length; i++) { //新建图片及宽高
        var img = new Image();
        img.src = "img/" + arr_img[i];
        img.style.width = "960px";
        img.style.height = "320px";
        pic_box.appendChild(img);
        var li = document.createElement("li"); //新建盒子下面的小点（点击切换）
        dot_box.appendChild(li);
    }
    dot = dot_box.firstElementChild; //默认第一个小点的样式
    dot.style.backgroundColor = "lightcoral";
    //给盒子下面的小点和左右按钮增加监听事件
    left.addEventListener("click", change_pic);
    right.addEventListener("click", change_pic);
    dot_box.addEventListener("click", changedot);
}

function change_pic(e) {
    //左按钮
    if (this === left) {
        count--; //计数器减减，直到小于零时跳到最后一张
        if (count &lt; 0) {
            count = arr_img.length - 1;
        }
        //右按钮
    } else if (this === right) {
        count++; //计数器加加，直到大于总图片数减一时跳到第一张
        if (count &gt; arr_img.length - 1) {
            count = 0;
        }
    }
    pic_box.style.left = -count * 960 + "px"; //单击后切换定位位置，达到水平移动
    count_pic(); //每次移动后改变小点位置
}

function changedot(e) { //点击小点让计数器的值等于点击的那个小点的索引，移动图片，切换小点
    for (var j = 0; j &lt; arr_img.length; j++) {
        if (dot_box.children[j] === e.target) {
            count = j;
        }
    }
    pic_box.style.left = -count * 960 + "px";
    count_pic();
}

function count_pic() {
    dot.style.backgroundColor = "transparent"; //前一个小点背景透明
    dot = dot_box.children[count]; //将被切换的小点赋值给当前小点，使其根据计数器切换
    dot.style.backgroundColor = "lightcoral";
}

function autochange() { //自动轮播，3秒切换一次
    count++;
    if (count &gt; arr_img.length - 1) {
        count = 0;
    }
    pic_box.style.left = -count * 960 + "px";
    count_pic();
}
setInterval(autochange, 3000);</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（十一）mongoose配合Node实现注册登录(注册上传头像，登录成功后显示用户信息)</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/03/10193686.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Mon, 03 Dec 2018 09:35:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/03/10193686.html</guid><description><![CDATA[
                <h3>需要引入的模块和框架：JQ，monogoDB，mongoose模块，express模块，nodemailer模块，cors模块，multer模块，body-parser模块。</h3>

<p>文件夹（大致）结构如下：</p>

<p><img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20181203171617714.png" width="225"></p>

<p>css：主页样式；</p>

<p>get_pic： 临时文件存放；</p>

<p>img：默认头像路径；</p>

<p>js：首页的js；</p>

<p>main：入口server文件（终端执行的）；</p>

<p>node_moudules:下载的模块和框架；</p>

<p>savePic：保存静态文件；</p>

<p>set：注册，登录，mongoose初始，邮件发送等模块；</p>

<p>index：主页；</p>

<p>首先，主页的Html，Css，Js文件：</p>

<h2>Html</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src="./jquery.js"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="./css/main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul id="list"&gt;
      &lt;li id="regChange"&gt;注册&lt;/li&gt;
      &lt;li id="loginChange"&gt;登录&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id="reg"&gt;
      &lt;input type="file" name="img" id="fileData"&gt;
      &lt;button id="send"&gt;上传头像&lt;/button&gt;
      &lt;img id="headImg" src=""&gt;
      &lt;input type="text" placeholder="邮箱" id="user" /&gt;
      &lt;input type="text" placeholder="密码" id="psd" /&gt;
      &lt;input type="text" placeholder="验证码" id="sendmail" /&gt;
      &lt;button id="email"&gt;发送验证码&lt;/button&gt;
      &lt;button id="btn"&gt;注册&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id="login"&gt;
      &lt;input type="text" placeholder="用户名" id="loguser" /&gt;
      &lt;input type="text" placeholder="密码" id="logpsd" /&gt;
      &lt;button id="logbtn"&gt;登录&lt;/button&gt;
    &lt;/div&gt;
    &lt;script src="./js/main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>Css</h2>

<pre class="has"><code class="language-css">* {
    margin: 0;
    padding: 0;
  }
  div:nth-child(3) {
    display: none;
  }
  input {
    display: block;
    height: 40px;
    width: 200px;
    margin: 20px auto;
  }
  button:not(#email) {
    display: block;
    height: 30px;
    width: 70px;
    background: lightcoral;
    border: none;
    margin: 0 auto;
  }
  #send{
    display: inline-block;
    
  }
  #headImg{
    display: block;
    margin: 0 auto;
  }
  #email {
    display: block;
    height: 30px;
    width: 100px;
    margin: 0 auto;
  }
  ul {
    height: 50px;
    width: 200px;
    background: lightblue;
    margin: 0 auto;
    list-style: none;
  }
  li {
    height: 50px;
    width: 100px;
    float: left;
    text-align: center;
    line-height: 50px;
  }
  li:hover {
    background: lightgreen;
    cursor: pointer;
  }
  table{
    margin: 50px auto 0;
  }
  td{
    text-align: center;
    border: 1px solid lightcoral;
  }
  td img{
    vertical-align: top;
  }</code></pre>

<h2>Js</h2>

<pre class="has"><code class="language-javascript">
//主页js文件


//增加监听事件
btn.addEventListener("click", clickHandler); //注册
logbtn.addEventListener("click", clickHandler); //登录
email.addEventListener("click", sendHandler); //发送验证码
regChange.addEventListener("click", changeHandler); //切换登录注册
loginChange.addEventListener("click", changeHandler);
$('#send').on('click', sendHead);
webAdd = 'http://localhost:1024/main';
var table; //新建登陆成功后的表格

function sendHead(e) { //上传文件
    var picData = new FormData(); //实例化文件对象
    picData.append("sendImg", $("#fileData")[0].files[0]); //将上传文件的添加到文件中
    $.ajax({ //ajax方式上传至后台
        url: webAdd + '/head',
        type: 'POST',
        data: picData,
        cache: false,
        contentType: false,
        processData: false,
        success: function (data) {
            if (!data.error) {
                alert('Success');
                headImg.src = data.data; //成功时将图片显示
                headImg.style.width = '100px';
            }
        },
        error: function () {
            alert('Error');
        }
    });
}

function clickHandler(e) {
    if (this.textContent === "注册") {
        //若为空时跳出
        if (!user.value || !psd.value || !sendmail.value) {
            alert("输入不能为空");
            return;
        }
        var AllData = {
            email: user.value,
            password: psd.value,
            mailnum: sendmail.value,
            headPic: headImg.src
        };
        //点击注册时将邮箱号，密码，验证码，头像传送至后台
        $.post(webAdd + '/reg', AllData,
            function (res) {
                //后台返回的对象，若hasUser为真，说明已有用户名，否则注册成功
                if (res.hasUser) {
                    // location.reload();
                    alert("注册失败");
                    return;
                } else {
                    alert("注册成功~");
                }
                //成功后隐藏注册，显示登录
                reg.style.display = "none";
                login.style.display = "block";
            }

        );
    } else if (this.textContent === "登录") {
        // 同注册，不能为空

        if (!loguser.value || !logpsd.value) {
            alert("不能为空");
            return;
        }
        //点击登录时将邮箱号，密码传送至后台
        $.post(webAdd + '/login', {
                email: loguser.value,
                password: logpsd.value
            },
            function (res) {
                //后台返回的对象，若isUser为真，说明正确，并跳转至欢迎页，否则失败
                if (res.isUser) {
                    alert("登录成功");
                    login.style.display = "none";
                    list.style.display = 'none';
                    createTab(document.body, res.data[0]); //若登陆成功，创建用户表格
                } else {
                    alert("用户名或密码不正确");
                    return;
                }
            }
        );
    }
}

function sendHandler(e) {
    //   点击获取验证码后将验证码发送到后端进行比对
    $.post(webAdd + '/sendmail', {
        email: user.value
    });
}

function changeHandler(e) {
    //   点击上方的注册登录切换
    if (e.target.textContent === "注册") {
        reg.style.display = "block";
        login.style.display = "none";
    } else {
        reg.style.display = "none";
        login.style.display = "block";
    }
}

function createTab(parent, data) {//新建表格函数
    if (table) {
        table.remove();//若表格存在，删除表格
    }
    table = document.createElement('table');
    for (var str in data) {//根据遍历数据创建表格
        var tr = document.createElement('tr');
        var td = document.createElement('td');
        if (str === 'head') {
            td.textContent = '头像:'
            var img = new Image();
            img.src = data[str];
            td.appendChild(img);
        } else {
            td.textContent = str + ':' + data[str];
        }
        tr.appendChild(td);
        table.appendChild(tr);
    }

    parent.appendChild(table);
}</code></pre>

<p>之后是其他模块：</p>

<h2>mongoose的Schema：</h2>

<pre class="has"><code class="language-javascript">const mongoose = require('./main'); //引入main模块
const Schema = mongoose.Schema; //新建schema对象
let userSchema = new Schema({
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    head: {
        type: String,
        required: true
    }
}); //实例化对象
let userModel = mongoose.model('allUser', userSchema); //新建数据库
module.exports = userModel; //抛出模块</code></pre>

<h2>mongoose数据库连接：</h2>

<pre class="has"><code class="language-javascript">const mongoose = require('mongoose');//引入mongoose
mongoose.connect('mongodb://localhost:27017/UserList', {
    useNewUrlParser: true
});//连接数据库
let db = mongoose.connection;
db.on("error", function (error) {
    console.log("错误：" + error);
});

db.on("open", function () {
    console.log("连接成功");
});

db.on('disconnected', function () {
    console.log('连接断开');
});
module.exports = mongoose;//抛出mongose对象</code></pre>

<h2>电子邮件验证模块：</h2>

<pre class="has"><code class="language-javascript">const nodemailer = require("nodemailer");
let obj = {
  transporter: nodemailer.createTransport({
    service: "qq", // 运营商  qq邮箱 网易//
    port: 465,
    secure: true,
    auth: {
      user: "********@qq.com", //发送方的邮箱
      pass: "**********" // pop3 授权码
    }
  }),
  send: function(mail, content,callback) {
    mailOptions = {
      from: '"Hello World~" &lt;**********@qq.com&gt;',
      to: mail,
      subject: content,
      text: content,
      html: "&lt;h1&gt;" + content + "&lt;/h1&gt;"
    };
    this.transporter.sendMail(mailOptions, (error, info) =&gt; {
      if (error) {
        return console.log(error);
      }
      console.log("Message sent: %s", info.messageId);
      callback();
    });
  }
};
module.exports = obj;
</code></pre>

<h2>头像上传：</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const router = express.Router(); //新建路由
var multer = require('multer'); //文件获取储存的第三方模块
const fs = require('fs');
const path = require('path');
var upload = multer({
    dest: '../get_pic/'
}); //将头像临时文件夹
router.post('/head', upload.single('sendImg'), (req, res) =&gt; { //路由地址
    //读取传输的头像
    fs.readFile(req.file.path, (err, data) =&gt; {
        if (err) {
            throw ('Load_Err');
        }
        let type = req.file.mimetype.split('/')[1]; //获取文件类型名
        let name = new Date().getTime() + parseInt(Math.random() * Math.random() * 1000000); //使用时间戳和随机数生成随机名，并且连成完整的文件名
        //保存文件至savePic文件夹
        let filename = name + '.' + type;
        fs.writeFile(path.join(__dirname, '../savePic/' + filename), data, (err) =&gt; {
            // 返回信息给前端
            if (err) {
                res.send({
                    err: 1,
                    msg: '上传失败'
                });
                //保存图片后删除临时文件
                fs.unlink(req.file.path, (err) =&gt; {
                    if (err) {
                        console.log('删除失败');
                    }
                });
                return;
            }
            res.send({
                err: 0,
                msg: '上传成功',
                data: 'savePic/' + filename
            });
            //保存图片后删除临时文件
            fs.unlink(req.file.path, (err) =&gt; {
                if (err) {
                    console.log('删除失败');
                }
            });
        });
    });


});
module.exports = router;</code></pre>

<h2>注册：</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const router = express.Router(); //新建路由
const Model = require('./mod'); //传入数据库对象
const fs = require('fs');
const path = require('path');
const sendMail = require('./send'); //传入邮件发送的模块对象
var count = ""; //新建一个空字符存放验证码，可供全局调用
//用post方法传输数据
router.post('/reg', (req, res) =&gt; {
    //保存前端传来的数据
    var mail = req.body.email;
    var psd = req.body.password;
    var mailnum = req.body.mailnum;
    var headUrl = req.body.headPic;
    //使用Model对象连接数据库
    Model.find({ // 查询邮箱
        'email': mail
    }).then((data) =&gt; {
        //若返回的邮箱找到或验证码不对，则抛错
        if (data.length &gt;= 1 || mailnum !== count) {
            res.send({
                hasUser: true
            });
            return;
        }
        res.send({
            hasUser: false
        });
        //若前端传了图片，则保存上传的图片，否则使用默认图片
        if (headUrl==='http://localhost:1024/') {
            headUrl = 'http://localhost:1024/img/cat.gif';
        }
        Model.insertMany({ //反之将邮箱插入到数据库
            'email': mail,
            'password': psd,
            'head':headUrl
        }).then((result) =&gt; {
            console.log(result);
        })
    }).catch((err) =&gt; {
        console.log(err);
    });
});

//邮箱验证接口
router.post("/sendmail", (req, res) =&gt; {
    count = ""; //初始化验证码容器
    var mail = req.body.email; //获取前端传来的邮箱号
    for (let i = 0; i &lt; 4; i++) {
        count += Math.floor(Math.random() * 10); //生成4个随机数
    }
    var callback = () =&gt; {
        console.log("发送成功");
    };
    sendMail.send(mail, count, callback); //调用邮件发送模块
    res.send('send');
});

module.exports = router;</code></pre>

<h2>登录：</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const router = express.Router();//新建路由
const Model = require('./mod');//获取数据库对象

router.post('/login', (req, res) =&gt; {//路由地址
    //保存前端传来的数据
    var mail = req.body.email;
    var psd = req.body.password;
    Model.find({
        // 查询是否有该用户，若用户邮箱和密码符合，则抛出正确，否则抛出错误对象
        'email': mail,
        'password': psd
    }).then((data) =&gt; {
        if (data.length &gt;= 1) {
            res.send({
                isUser: true,
                data:data
            });
        } else {
            res.send({
                isUser: false
            });
        }
    }).catch((err) =&gt; {
        console.log(err);
    });
});
module.exports = router;</code></pre>

<h2>最后server.js</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const app = express();
const cors = require("cors"); //引入cors模块（解决跨域问题）
const path = require('path');
var bodyParser = require('body-parser');

app.use(cors());
// 下面的类似于http请求的头文件(另一篇文章有写到http请求，也是注册登录)
app.all("*", function (req, res, next) {
    //设置允许跨域的域名，*代表允许任意域名跨域
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "content-type"); //允许的header类型
    res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS"); //跨域允许的请求方式
    next(); //是否继续向下执行
});
//创建静态文件目录
app.use(express.static(path.join(__dirname, '../../user_info')));
//解决post传输的数据格式问题
app.use(bodyParser.urlencoded({
    extended: false
}))
app.use(bodyParser.json())
// 路由选择导入注册
const reg = require('../set/reg.js');
app.use('/main', reg);
// 路由选择导入登录
const login = require('../set/login.js');
app.use('/main', login);
// 路由选择上传图片模块
const head = require('../set/sendhead.js');
app.use('/main', head);
// 开启监听
app.listen(1024, () =&gt; {
    console.log('Server Start~');
});</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：购物车操作（简单实现）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193687.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 02 Dec 2018 12:14:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193687.html</guid><description><![CDATA[
                <h2>Html：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;shop&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/shop.css"&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;script src="js/shop.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      // 新建数据
      var obj = [
        {
          select: false,
          img:"img/1.jpg",//图片路径
          name: "OPPO R11 全网通4G 双卡双待手机玫瑰金色",
          price: 2799,
          num: 1,
          sum: 0,
          del: false
        },
        {
          select: false,
          img:"img/2.jpg",//图片路径
          name: "Apple iPhone8 64G 金色 移动联通电信4G手机",
          price: 5888,
          num: 1,
          sum: 0,
          del: false
        }
      ];
      // 实例化对象，传入数据
      var table = new Table(obj);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>Css：</h2>

<pre class="has"><code class="language-css">*{
    margin: 0;
    padding: 0;
}
table{
    width: 1200px;
    /* background: lightcoral; */
    margin: 50px auto;
}
tr:nth-child(1){
    background: #F3F3F3;
    height: 26px;
}
img{
    height: 30%;
    vertical-align: middle;
}
img+span{
    font-size: 10px;
}
td{
    text-align: center;
    vertical-align: middle;
}
tr td:nth-child(2){
    text-align: left;
}
tr td:nth-child(4) div button{
    height: 20px;
    width: 20px;
    border: none;
    text-align: center;
    vertical-align: middle;
}
tr td:nth-child(4) div input{
    height: 20px;
    width: 27px;
    vertical-align: middle;
}
tr td:nth-child(3),tr td:nth-child(5){
    width: 100px;
}
table&gt;div{
    width: 300px;
    text-align: right;
}</code></pre>

<h2>JS：</h2>

<pre class="has"><code class="language-javascript">function Table(obj) {
  this.obj = obj; //引入数组对象
  this.init(obj); //入口函数
}
Table.prototype = {
  table: null, //初始化表格
  allSum: 0, //商品总和
  allNum: 0, //商品数量总和
  allselect: false, //全选
  init: function (obj) {
    this.createTab(obj); //创建表格
  },
  createTab: function (obj) {
    if (this.table) { //初始化表格，若表格存在，则删除表格再新建
      this.table.remove();
      this.table = null;
    }
    this.table = document.createElement("table"); //创建表格
    var thr = document.createElement("tr"); //创建表格标题
    var selectAll = document.createElement("th");
    var selectAllInput = document.createElement("input"); //全选
    selectAllInput.self = this;
    selectAllInput.addEventListener("change", this.selectHandler); //添加事件，当全选建改变时触发
    selectAllInput.type = "checkbox";
    selectAllInput.checked = this.allselect; //给其选中添加值，让数据驱动更改选中状态
    selectAll.textContent = "全选";
    selectAll.appendChild(selectAllInput);
    thr.appendChild(selectAll); //createName方法添加表头内容
    this.createName("商品", thr);
    this.createName("单价", thr);
    this.createName("数量", thr);
    this.createName("小计", thr);
    this.createName("操作", thr);
    this.table.appendChild(thr);
    for (var i = 0; i &lt; obj.length; i++) { //根据数组对象创建表格
      var tr = document.createElement("tr");
      for (var str in obj[i]) { //跳过name那项（因为里面有两个属性，后面会讲到）
        if (str === "name") continue;
        var td = document.createElement("td");
        if (str === "select") { //当属性名为select时创建多选按钮，添加更改时触发的事件
          var select = document.createElement("input");
          select.type = "checkbox";
          select.self = this;
          select.index = i; //传递当前点击索引
          select.addEventListener("change", this.selectHandler);
          select.checked = obj[i].select; //给其选中添加值，让数据驱动更改选中状态
          td.appendChild(select);
        } else if (str === "img") { //当属性名为img时创建图片以及商品名
          var img = new Image();
          img.src = obj[i][str];
          var name = document.createElement("span");
          name.textContent = obj[i].name;
          td.appendChild(img);
          td.appendChild(name);
        } else if (str === "price") { //当属性名为price时创建价格，同样数据驱动
          td.price = obj[i][str];
          td.textContent = td.price;
        } else if (str === "num") { //数据驱动商品的个数
          var num = document.createElement("div");
          num.index = i;
          num.data = obj; //将数据赋给num（后面会用到）
          num.self = this;
          //创建-和+按钮，以及文本框，改变商品个数
          var left = document.createElement("button");
          var text = document.createElement("input");
          var right = document.createElement("button");
          left.textContent = "-";
          right.textContent = "+";
          text.value = obj[i].num;
          //添加事件，当点击+或-时触发事件，当文本框中失焦触发另一个事件
          left.addEventListener("click", this.changeNum);
          text.addEventListener("blur", this.changeNum);
          right.addEventListener("click", this.changeNum);
          num.appendChild(left);
          num.appendChild(text);
          num.appendChild(right);
          td.appendChild(num);
        } else if (str === "sum") { //新建单商品的总价（个数乘以单价）
          var sum = document.createElement("div");
          sum.data = obj[i]; //将该商品的数据传递
          sum.textContent = obj[i].num * obj[i].price;
          td.appendChild(sum);
        } else if (str === "del") { //新建删除按钮
          var del = document.createElement("button");
          del.textContent = "Del";
          del.data = obj; //将该商品的数据传递
          del.index = i; //该项的索引通过事件传递
          del.self = this;
          del.addEventListener("click", this.delHandler); //删除事件
          td.appendChild(del);
        }
        tr.appendChild(td);
      }
      this.table.appendChild(tr);
    }
    this.addAll(obj, this.table); //根据更新的表格数据新建商品总价及总个数
    document.body.appendChild(this.table);
    return this.table;
  },
  addAll: function (obj, parent) { //商品总价及总个数
    var addAllItem = document.createElement("div");
    var addAllPrice = document.createElement("div");
    var sum = 0; //初始化总价及数量
    var price = 0;
    for (var i = 0; i &lt; obj.length; i++) {
      sum += obj[i].num;
      price += obj[i].price * obj[i].num; //求总价和总和
    }
    addAllItem.textContent = "总数:" + sum;
    addAllPrice.textContent = "总价:" + price;
    parent.appendChild(addAllItem);
    parent.appendChild(addAllPrice);
  },
  createName: function (text, parent) { //createName方法添加表头内容
    var item = document.createElement("th");
    item.textContent = text;
    parent.appendChild(item);
    return item;
  },
  changeNum: function (e) {
    if (this.textContent === "+") { //当点击+按钮使数组对象中的商品数加一，当商品数量大于99就不再增加
      this.parentNode.data[this.parentNode.index].num++;
      if (this.parentNode.data[this.parentNode.index].num &gt; 99) {
        this.parentNode.data[this.parentNode.index].num = 99;
      }
    } else if (this.textContent === "-") { //当点击-按钮使数组对象中的商品数减一，当商品数量小于0就不再减少
      this.parentNode.data[this.parentNode.index].num--;
      if (this.parentNode.data[this.parentNode.index].num &lt; 1) {
        this.parentNode.data[this.parentNode.index].num = 1;
      }
    } else { //当在文本框输入个数时对数组对象中的商品数进行操作
      if (isNaN(this.value)) { //当输入的不为数值时，使其变成1
        this.parentNode.data[this.parentNode.index].num = 1;
      } else if (Number(this.value) &gt; 99) { //当输入的大于99时，使其变成99
        this.parentNode.data[this.parentNode.index].num = 99;
      } else if (Number(this.value) &lt; 1) { //当输入的小于1时，使其变成1
        this.parentNode.data[this.parentNode.index].num = 1;
      } else { //否则直接让对象中的数值等于输入的值
        this.parentNode.data[this.parentNode.index].num = Number(this.value);
      }
    }
    this.parentNode.self.init(this.parentNode.data); //根据更改后的数据驱动创建表格
  },
  delHandler: function (e) {
    this.data.splice(this.index, 1); //删除当前选择的那项,根据更改后的数据驱动创建表格
    this.self.init(this.data);
  },
  selectHandler: function (e) { //全选时使所有的单选框都根据数据更改
    if (this.parentNode.textContent === "全选") {
      this.self.allselect = !this.self.allselect;
      for (var i = 0; i &lt; this.self.obj.length; i++) {
        this.self.obj[i].select = this.self.allselect;
      }
    } else {
      var sum = 1; //当所有的单选框选中的值为true时，将全选选中(true是1，false是0)
      this.self.obj[this.index].select = !this.self.obj[this.index].select;
      for (var i = 0; i &lt; this.self.obj.length; i++) {
        sum *= this.self.obj[i].select;
      }
      if (sum) {
        this.self.allselect = true;
      } else {
        this.self.allselect = false;
      }
    }
    this.self.init(this.self.obj); //根据更改后的数据驱动创建表格
    console.log(this.checked);
  }
};
Table.prototype.constructor = Table;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：Jq中的fadeOut和fadeIn实现简单轮播（没完善，简单实现）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193688.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 02 Dec 2018 11:33:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193688.html</guid><description><![CDATA[
                <p>代码：</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;
            * {
                margin: 0;
                padding: 0;
            }

            #nav {
                width: 120px;
                height: 80px;
                position: absolute;
                right: 310px;
                top: 60px;
                z-index: 2;
            }

            #nav img {
                width: 100%;
                height: 100%;
                margin: 10px 0;
                transition: 0.5s;
            }

            #nav img:hover {
                border: 5px solid lightcoral;
                box-sizing: border-box;
            }

            #pic {
                width: 1000px;
                height: 600px;
                position: relative;
                margin: 50px auto;
            }

            #pic img {
                width: 100%;
                height: 100%;
                position: absolute;
                display: none;
            }
        &lt;/style&gt;
        &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="nav"&gt;
            &lt;img src="img/1.jpg" alt="1" /&gt;
            &lt;img src="img/2.jpg" alt="2" /&gt;
            &lt;img src="img/3.jpg" alt="3" /&gt;
            &lt;img src="img/4.jpg" alt="4" /&gt;
            &lt;img src="img/5.jpg" alt="5" /&gt;
        &lt;/div&gt;
        &lt;div id="pic"&gt;
            &lt;img src="img/1.jpg" alt="1" /&gt;
            &lt;img src="img/2.jpg" alt="2" /&gt;
            &lt;img src="img/3.jpg" alt="3" /&gt;
            &lt;img src="img/4.jpg" alt="4" /&gt;
            &lt;img src="img/5.jpg" alt="5" /&gt;
        &lt;/div&gt;
        &lt;script&gt;
            var count = 0; //记录图片是第几张
            $("#pic img").eq(0).fadeIn(1); //初始图片显示状态，不写的话，第一张图片不会显示
            $("#nav img").on("click", changePic); //给导航框小图片添加点击事件
            var list = Array.from($("#nav img")); //将小图图片列表，放在数组中
            function changePic(e) { //小图点击事件
                var index = list.indexOf(this); //在数组中查找被点击的那一项索引
                count = index; //当点击时将自动切换的索引换成点击的那个
                $("#pic img:visible").fadeOut(500); //初始化所有图片，将显示的隐藏
                $("#pic img").eq(index).fadeIn(500); //将被单击的显示
            }
            setInterval(autoMove, 3000); //每三秒切换一次
            function autoMove() {
                count++; //切换图片
                if (count &gt; 4) {
                    count = 0;
                }
                $("#pic img:visible").fadeOut(500); //初始化所有图片，将显示的隐藏
                $("#pic img").eq(count).fadeIn(500); //将被单击的显示
            }
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：小球拖动，记录轨迹，并原路返回</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193689.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 02 Dec 2018 08:57:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193689.html</guid><description><![CDATA[
                <h2>附上代码：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;
            .box {
                width: 100px;
                height: 100px;
                position: absolute;
                background: lightcoral;
                border-radius: 50%;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            var arrX = [];//新建数组，记录小球的x轴路径
            var arrY = [];//新建数组，记录小球的y轴路径
            var i = 0;//小球移动时数组的第i项存进数组
            var stop;//小球的运动
            function Ball() {}//新建小球类
            Ball.prototype = {
                ball:null,//新建小球
                createBall: function () {//创建小球，添加到body中
                    this.ball = document.createElement("div");
                    document.body.appendChild(this.ball);
                    this.ball.className = "box";
                    this.ball.self = this;//引入小球的属性self指向Ball对象（this）
                    this.ball.addEventListener("mousedown", this.mouseHandler);//添加点击事件
                    return this.ball;
                },
                mouseHandler: function (e) {
                    if (e.type === "mousedown") {//当鼠标点击时添加移动事件给document，添加鼠标松开事件给小球，并且使用回调，每次执行一个函数，对e.type进行判断
                        this.addEventListener("mouseup", this.self.mouseHandler);
                        document.ball = this;//引入对象ball给document
                        document.boxObj = {//给document添加对象属性鼠标相对小球位置
                            x: e.offsetX,
                            y: e.offsetY
                        };
                        document.addEventListener("mousemove", this.self.mouseHandler);
                    } else if (e.type === "mousemove") {//鼠标移动时让小球位置等于鼠标在当前窗口的位置减去鼠标相对小球位置
                        this.ball.style.left = e.x - this.boxObj.x + "px";
                        this.ball.style.top = e.y - this.boxObj.y + "px";
                        arrX.push(this.ball.style.left);//小球每次移动将位置存入数组中
                        arrY.push(this.ball.style.top);
                    } else if (e.type === "mouseup") {//当鼠标松开时，解除监听事件并且执行自动返回函数
                        this.removeEventListener("mouseHandler", this.self.mouseHandler);
                        document.removeEventListener("mousemove", this.self.mouseHandler);
                        document.self = this;
                        i = arrX.length;
                        stop = setInterval(this.self.autoMove, 16);
                    }
                },
                autoMove: function () {//返回函数，当小球运动到初始状态时，取消Interval函数
                    document.self.style.left = arrX[i];
                    document.self.style.top = arrY[i];
                    if (i &lt;= 0) {
                        arrX.length = 0;
                        arrY.length = 0;
                        clearInterval(stop);
                        return;
                    }
                    i--;
                }
            };
            //实例化小球，并且执行小球方法
            var ball = new Ball();
            ball.createBall();
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node(十)之Mongoose配合Node路由实现邮箱注册登录（Post版）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193690.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sun, 02 Dec 2018 07:36:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/02/10193690.html</guid><description><![CDATA[
                <h2>首先新建一个HTML：（引入jq）</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src="./jquery.js"&gt;&lt;/script&gt;
    &lt;style&gt;
      * {
        margin: 0;
        padding: 0;
      }
      div:nth-child(3) {
        display: none;
      }
      input {
        display: block;
        height: 40px;
        width: 200px;
        margin: 20px auto;
      }
      button:not(#email) {
        display: block;
        height: 30px;
        width: 70px;
        background: lightcoral;
        border: none;
        margin: 0 auto;
      }
      #email {
        display: block;
        height: 30px;
        width: 100px;
        margin: 0 auto;
      }
      ul {
        height: 50px;
        width: 200px;
        background: lightblue;
        margin: 0 auto;
        list-style: none;
      }
      li {
        height: 50px;
        width: 100px;
        float: left;
        text-align: center;
        line-height: 50px;
      }
      li:hover {
        background: lightgreen;
        cursor: pointer;
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;ul&gt;
      &lt;li id="regChange"&gt;注册&lt;/li&gt;
      &lt;li id="loginChange"&gt;登录&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id="reg"&gt;
      &lt;input type="text" placeholder="邮箱" id="user" /&gt;
      &lt;input type="text" placeholder="密码" id="psd" /&gt;
      &lt;input type="text" placeholder="验证码" id="sendmail" /&gt;
      &lt;button id="email"&gt;发送验证码&lt;/button&gt; &lt;button id="btn"&gt;注册&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id="login"&gt;
      &lt;input type="text" placeholder="用户名" id="loguser" /&gt;
      &lt;input type="text" placeholder="密码" id="logpsd" /&gt;
      &lt;button id="logbtn"&gt;登录&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
      //增加监听事件
      btn.addEventListener("click", clickHandler);
      logbtn.addEventListener("click", clickHandler);
      email.addEventListener("click", sendHandler);
      regChange.addEventListener("click", changeHandler);
      loginChange.addEventListener("click", changeHandler);

      function clickHandler(e) {
        if (this.textContent === "注册") {
          //若为空时跳出
          if (!user.value || !psd.value || !sendmail.value) {
            alert("不能为空");
            return;
          }
          //点击注册时将邮箱号，密码，验证码传送至后台
          $.post("http://localhost:1024/main/reg", {
              email: user.value,
              password: psd.value,
              mailnum: sendmail.value
            },
            function (res) {
              //后台返回的对象，若hasUser为真，说明已有用户名，否则注册成功
              if (res.hasUser) {
                alert("注册失败");
                return;
              } else {
                alert("注册成功~");
              }
              //成功后隐藏注册，显示登录
              reg.style.display = "none";
              login.style.display = "block";
            }

          );
        } else if (this.textContent === "登录") {
          // 同注册，不能为空
          if (!loguser.value || !logpsd.value) {
            alert("不能为空");
            return;
          }
          //点击登录时将邮箱号，密码传送至后台
          $.post("http://localhost:1024/main/login", {
              email: loguser.value,
              password: logpsd.value
            },
            function (res) {
              //后台返回的对象，若isUser为真，说明正确，并跳转至欢迎页，否则失败
              if (res.isUser) {
                alert("登录成功");
                location.href = "./welcome.html";
              } else {
                alert("用户名或密码不正确");
                return;
              }
            }
          );
        }
      }
      function sendHandler(e) {
        //   点击获取验证码后将验证码发送到后端进行比对
        $.post("http://localhost:1024/main/sendmail", {
          email: user.value
        });
      }

      function changeHandler(e) {
        //   点击上方的注册登录切换
        if (e.target.textContent === "注册") {
          reg.style.display = "block";
          login.style.display = "none";
        } else {
          reg.style.display = "none";
          login.style.display = "block";
        }
      }
    &lt;/script&gt;
  &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>新建set文件夹，在文件夹中新建几个js文件：</h2>

<h2>main.js(连接mongoose数据库)</h2>

<pre class="has"><code class="language-javascript">const mongoose = require('mongoose');//引入mongoose
mongoose.connect('mongodb://localhost:27017/UserList', {
    useNewUrlParser: true
});//连接数据库
let db = mongoose.connection;
db.on("error", function (error) {
    console.log("错误：" + error);
});

db.on("open", function () {
    console.log("连接成功");
});

db.on('disconnected', function () {
    console.log('连接断开');
});
module.exports = mongoose;//抛出mongose对象</code></pre>

<h2>mod.js（实例化Schema，新建数据库）</h2>

<pre class="has"><code class="language-javascript">const mongoose = require('./main');//引入main模块
const Schema = mongoose.Schema;//新建schema对象
let userSchema = new Schema({
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    }
});//实例化对象
let userModel = mongoose.model('allUser', userSchema);//新建数据库
module.exports = userModel;//抛出模块</code></pre>

<h2>send.js（邮件发送模块）</h2>

<pre class="has"><code class="language-javascript">const nodemailer = require("nodemailer");
let obj = {
  transporter: nodemailer.createTransport({
    service: "qq", // 运营商  qq邮箱 网易//
    port: 465,
    secure: true,
    auth: {
      user: "*******@qq.com", //发送方的邮箱
      pass: "********" // pop3 授权码
    }
  }),
  send: function(mail, content,callback) {
    mailOptions = {
      from: '"Hello World~" &lt;******@qq.com&gt;',
      to: mail,
      subject: content,
      text: content,
      html: "&lt;h1&gt;" + content + "&lt;/h1&gt;"
    };
    this.transporter.sendMail(mailOptions, (error, info) =&gt; {
      if (error) {
        return console.log(error);
      }
      console.log("Message sent: %s", info.messageId);
      callback();
    });
  }
};
module.exports = obj;
</code></pre>

<h2>reg.js（创建注册模块）</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const router = express.Router(); //新建路由
const Model = require('./mod'); //传入数据库对象
const sendMail = require('./send'); //传入邮件发送的模块对象
var count = ""; //新建一个空字符存放验证码，可供全局调用
//用post方法传输数据
router.post('/reg', (req, res) =&gt; {
    //保存前端传来的数据
    var mail = req.body.email;
    var psd = req.body.password;
    var mailnum = req.body.mailnum;
    //使用Model对象连接数据库
    Model.find({// 查询邮箱
        'email': mail
    }).then((data) =&gt; {
        //若返回的邮箱找到或验证码不对，则抛错
        if (data.length &gt;= 1 || mailnum !== count) {
            res.send({
                hasUser: true
            });
            return;
        }
        res.send({
            hasUser: false
        })
        Model.insertMany({//反之将邮箱插入到数据库
            'email': mail,
            'password': psd
        }).then((result) =&gt; {
            console.log(result);
        })
    }).catch((err) =&gt; {
        console.log(err);
    });
});

//邮箱验证接口
router.post("/sendmail", (req, res) =&gt; {
    count = ""; //初始化验证码容器
    var mail = req.body.email; //获取前端传来的邮箱号
    for (let i = 0; i &lt; 4; i++) {
        count += Math.floor(Math.random() * 10); //生成4个随机数
    }
    var callback = () =&gt; {
        console.log("发送成功");
    };
    sendMail.send(mail, count, callback); //调用邮件发送模块
    res.send('send');
});

module.exports = router;</code></pre>

<h2>login.js（登录模块）</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const router = express.Router();//新建路由
const Model = require('./mod');//获取数据库对象

router.post('/login', (req, res) =&gt; {//路由地址
    //保存前端传来的数据
    var mail = req.body.email;
    var psd = req.body.password;
    Model.find({
        // 查询是否有该用户，若用户邮箱和密码符合，则抛出正确，否则抛出错误对象
        'email': mail,
        'password': psd
    }).then((data) =&gt; {
        if (data.length &gt;= 1) {
            res.send({
                isUser: true
            });
        } else {
            res.send({
                isUser: false
            });
        }
    }).catch((err) =&gt; {
        console.log(err);
    });
});
module.exports = router;</code></pre>

<h2>然后在set文件夹外面新建一个服务（server.js），将所有的模块拼接：</h2>

<pre class="has"><code class="language-javascript">const express = require('express');
const app = express();
const cors = require("cors"); //引入cors模块（解决跨域问题）
var bodyParser = require('body-parser');

app.use(cors());
// 下面的类似于http请求的头文件(另一篇文章有写到http请求，也是注册登录)
app.all("*", function (req, res, next) {
    //设置允许跨域的域名，*代表允许任意域名跨域
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "content-type"); //允许的header类型
    res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS"); //跨域允许的请求方式
    next(); //是否继续向下执行
});
//解决post传输的数据格式问题
app.use(bodyParser.urlencoded({
    extended: false
}))
app.use(bodyParser.json())
// 路由选择导入注册
const reg = require('../set/reg.js');
app.use('/main', reg);
// 路由选择导入登录
const login = require('../set/login.js');
app.use('/main', login);
// 开启监听
app.listen(1024, () =&gt; {
    console.log('Server Start~');
});</code></pre>

<h3>最后运行server.js实现注册登录</h3>

<h2>注意：案例需要用到monogoDB，Jq，mongoose模块，express模块，nodemailer模块，cors模块，<br>
body-parser模块</h2>            ]]></description></item><item><title>Node(九)之Node配合MongoDB实现简单的注册登录</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/01/10193691.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Sat, 01 Dec 2018 08:47:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/12/01/10193691.html</guid><description><![CDATA[
                <p>附上代码：（较之前的用txt实现的没有什么区别，只是后端用数据库实现了接口功能）</p>

<h2>Html：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src="./jquery.js"&gt;&lt;/script&gt;
    &lt;style&gt;
      * {
        margin: 0;
        padding: 0;
      }
      div:nth-child(2) {
        display: none;
      }
      input {
        display: block;
        height: 40px;
        width: 200px;
        margin: 20px auto;
      }
      button:not(#email) {
        display: block;
        height: 30px;
        width: 70px;
        background: lightcoral;
        border: none;
        margin: 0 auto;
      }
      #email {
        display: block;
        height: 30px;
        width: 100px;
        margin: 0 auto;
      }
      ul {
        height: 50px;
        width: 200px;
        background: lightblue;
        margin: 0 auto;
        list-style: none;
      }
      li {
        height: 50px;
        width: 100px;
        float: left;
        text-align: center;
        line-height: 50px;
      }
      li:hover {
        background: lightgreen;
        cursor: pointer;
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;ul&gt;
      &lt;li id="regChange"&gt;注册&lt;/li&gt;
      &lt;li id="loginChange"&gt;登录&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id="reg"&gt;
      &lt;input type="text" placeholder="邮箱" id="user" /&gt;
      &lt;input type="text" placeholder="密码" id="psd" /&gt;
      &lt;input type="text" placeholder="验证码" id="sendmail" /&gt;
      &lt;button id="email"&gt;发送验证码&lt;/button&gt; &lt;button id="btn"&gt;注册&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id="login"&gt;
      &lt;input type="text" placeholder="用户名" id="loguser" /&gt;
      &lt;input type="text" placeholder="密码" id="logpsd" /&gt;
      &lt;button id="logbtn"&gt;登录&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
      //增加监听事件
      btn.addEventListener("click", clickHandler);
      logbtn.addEventListener("click", clickHandler);
      email.addEventListener("click", sendHandler);
      regChange.addEventListener("click", changeHandler);
      loginChange.addEventListener("click", changeHandler);

      function clickHandler(e) {
        if (this.textContent === "注册") {
          //若为空时跳出
          if (!user.value || !psd.value || !sendmail.value) {
            alert("Can't be empty");
            return;
          }
          //点击注册时将邮箱号，密码，验证码传送至后台
          $.get(
            `http://localhost:1024/index/reg?user=${user.value}&amp;psd=${
              psd.value
            }&amp;mail=${sendmail.value}`,
            function (res) {
              //后台返回的对象，若hasUser为真，说明已有用户名，否则注册成功
              if (res.hasUser) {
                alert("注册失败");
                return;
              } else {
                alert("注册成功~");
              }
              //成功后隐藏注册，显示登录
              reg.style.display = "none";
              login.style.display = "block";
            }
          );
        } else if (this.textContent === "登录") {
          // 同注册，不能为空
          if (!loguser.value || !logpsd.value) {
            alert("Can't be empty");
            return;
          }
          //点击注册时将邮箱号，密码传送至后台
          $.get(
            `http://localhost:1024/index/login?user=${loguser.value}&amp;psd=${
              logpsd.value
            }`,
            function (res) {
              //后台返回的对象，若isUser为真，说明正确，并跳转至欢迎页，否则失败
              if (res.isUser) {
                alert("登录成功");
                location.href = "./welcome.html";
              } else {
                alert("用户名或密码不正确");
                return;
              }
            }
          );
        }
      }

      function sendHandler(e) {
        //   点击获取验证码后将验证码发送到后端进行比对
        $.get(`http://localhost:1024/index/sendmail?${user.value}`);
      }

      function changeHandler(e) {
        //   点击上方的注册登录切换
        if (e.target.textContent === "注册") {
          reg.style.display = "block";
          login.style.display = "none";
        } else {
          reg.style.display = "none";
          login.style.display = "block";
        }
      }
    &lt;/script&gt;
  &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>JS部分：同样要用到express框架，cors，nodemailer，并且不需要File System，Path模块</h2>

<pre class="has"><code class="language-javascript">var MongoClient = require("mongodb").MongoClient;//mongoDb模块引入
var mongoDB = "mongodb://localhost:27017/";//初始化地址
const express = require("express"); //引入express框架（需要先下载，官网有教程）
const url = require("url");
const cors = require("cors"); //引入cors模块（解决跨域问题）
const app = express();
const sendMail = require("./send"); //这个模块是发送邮件模块（在我第三篇node文章里有）

app.use(cors());
// 下面的类似于http请求的头文件(另一篇文章有写到http请求，也是注册登录)
app.all("*", function(req, res, next) {
  //设置允许跨域的域名，*代表允许任意域名跨域
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "content-type"); //允许的header类型
  res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS"); //跨域允许的请求方式
  next(); //是否继续向下执行
});

//注册接口
var count = ""; //新建一个空字符存放验证码，可供全局调用
app.get("/index/reg", (req, res) =&gt; {
  let search = url
    .parse(req.url)
    .query.split("&amp;")[0]
    .split("=")[1]; //保存前端传来的数据
  let query = url.parse(req.url).query.split("&amp;");
  MongoClient.connect(//连接数据库
    mongoDB,
    {
      useNewUrlParser: true
    },
    function(err, db) {
      if (err) {
        throw err;
      }
      console.log("连接成功！");
      var dball = db.db("UserList");
      // 查询邮箱
      dball
        .collection("allUser")
        .find({
          email: search
        })
        .toArray(function(err, result) {
          if (err) {
            console.log(err);
            return;
          }

          function test() {//应用promise执行，若找到该用户，返回正确，反之返回错误
            return new Promise((resolve, reject) =&gt; {//若用户邮箱不存在并且验证码正确，则抛出正确，否则抛出错误对象
              if (!result.length &amp;&amp; query[2].split("=")[1] === count) {
                resolve({
                  hasUser: false
                });
                //找到后将数据存储至数据库
                dball.collection("allUser").insert(
                  [
                    {
                      email: query[0].split("=")[1],
                      password: query[1].split("=")[1]
                    }
                  ],
                  function(err, result) {
                    if (err) {
                      console.log("Error:" + err);
                      return;
                    }
                  }
                );
              } else {//反之抛出错误对象至前端
                reject({
                  hasUser: true
                });
              }
            });
          }
          test()
            .then(data =&gt; {
              console.log(data);
              res.send(data);
            })
            .catch(err =&gt; {
              console.log(err);
              res.send(err);
            });
        });
    }
  );
});

//登录接口
app.get("/index/login", (req, res) =&gt; {
  //保存前端传来的数据
  let query = url.parse(req.url).query.split("&amp;");
  MongoClient.connect(
    mongoDB,
    {
      useNewUrlParser: true
    },
    function(err, db) {
      if (err) {
        throw err;
      }
      console.log("连接成功！");
      var dball = db.db("UserList");
      // 查询是否有该用户
      dball
        .collection("allUser")
        .find({
          email: query[0].split("=")[1]
        })
        .toArray(function(err, result) {
          if (err) {
            console.log(err);
            return;
          }
          function test() {//若用户邮箱和密码符合，则抛出正确，否则抛出错误对象
            return new Promise((resolve, reject) =&gt; {
              if (
                result.length &amp;&amp;
                result[0].password === query[1].split("=")[1]
              ) {
                resolve({
                  isUser: true
                });
              } else {
                reject({
                  isUser: false
                });
              }
            });
          }
          test()
            .then(data =&gt; {
              console.log(data);
              res.send(data);
            })
            .catch(err =&gt; {
              console.log(err);
              res.send(err);
            });
        });
    }
  );
});

//邮箱验证接口
app.get("/index/sendmail", (req, res) =&gt; {
  count = ""; //初始化验证码容器
  let Email = url.parse(req.url).query; //获取前端传来的邮箱号
  for (let i = 0; i &lt; 4; i++) {
    count += Math.floor(Math.random() * 10); //生成4个随机数
  }
  sendMail.send(Email, count); //调用邮件发送模块
  res.send(count);
});
//监听服务
app.listen(1024, () =&gt; {
  console.log("Server Start~");
});
</code></pre>

<h2>邮箱的js文件（send.js）</h2>

<pre class="has"><code class="language-javascript">const nodemailer = require("nodemailer");
let obj = {
  transporter: nodemailer.createTransport({
    service: "qq", // 运营商  qq邮箱 网易//
    port: 465,
    secure: true,
    auth: {
      user: "*********@qq.com", //发送方的邮箱
      pass: "*******" // pop3 授权码
    }
  }),
  send: function(mail, content) {
    mailOptions = {
      from: '"Hello World~" &lt;**********@qq.com&gt;',
      to: mail,
      subject: content,
      text: content,
      html: "&lt;h1&gt;" + content + "&lt;/h1&gt;"
    };
    this.transporter.sendMail(mailOptions, (error, info) =&gt; {
      if (error) {
        return console.log(error);
      }
      console.log("Message sent: %s", info.messageId);
    });
  }
};
module.exports = obj;
</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（八）之MongoDB简单应用</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/30/10193692.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Fri, 30 Nov 2018 12:38:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/30/10193692.html</guid><description><![CDATA[
                <h2>初始：</h2>

<ol><li>下载mongodb的安装包，<a href="https://www.mongodb.com/download-center/community" rel="nofollow">https://www.mongodb.com/download-center/community</a></li>
	<li>安装</li>
	<li>安装完成后在data文件夹下新建一个db文件夹</li>
	<li>加入环境变量：复制安装目录下bin文件夹的目录，右击我的电脑=&gt;属性（见下图）在环境变量中粘贴bin文件路径，用分号<br>
	隔开环境变量<img alt="" class="has" height="407" src="https://img-blog.csdnimg.cn/20181130194122427.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpbWVfX19fXw==,size_16,color_FFFFFF,t_70" width="556"></li>
	<li>打开控制台输入：mongod 查看是否安装成功</li>
	<li>使用mongo命令连接至数据库</li>
</ol><h2>&nbsp;db操作：</h2>

<p>这里新建一个名字为User的数据库</p>

<pre class="has"><code class="language-html">use User------数据库名称（切换当前操作的数据库，若没有则是创建新数据库）</code></pre>

<pre class="has"><code class="language-html">show dbs------显示所有数据库</code></pre>

<pre class="has"><code class="language-html">db.User.insert({"name":"abc"})-----插入name为'abc'的一项</code></pre>

<h2>collection：集合</h2>

<p>db.createCollection('集合名')；&nbsp; 创建集合</p>

<p>db.集合名.drop()&nbsp; 删除一个集合</p>

<p>show&nbsp;collections&nbsp; 查看所有的集合</p>

<p>每个数据库都要有集合，不然创建的是临时数据</p>

<h2>document操作：</h2>

<p>插入文档：</p>

<p>db.col.insert({<br>
&nbsp; &nbsp; &nbsp; &nbsp; "email" : "admin",<br>
&nbsp; &nbsp; &nbsp; &nbsp; "password" : "root"<br>
})</p>

<p>查找文档：</p>

<pre class="has"><code class="language-html">db.col.find(条件，不填则查找全部)</code></pre>

<p>&nbsp;更新文档：</p>

<pre class="has"><code class="language-javascript">db.col.update({
  "email" : "admin"
}, {
  $set: {
    "email" : "admin1",
     "password" : "root1"
  }
}, {
  multi: true
})</code></pre>

<p>寻找所有email为admin的值，并且更新值email为admin1和password为root1，<code>multi</code>设置为true时可以更新多个文档</p>

<p>覆盖更新：</p>

<pre class="has"><code class="language-javascript">db.col.save({
  '_id':3,
  'email': 'abc'
})</code></pre>

<p>根据传入的id，覆盖旧值</p>

<p>删除文档：</p>

<pre class="has"><code class="language-html">db.col.remove({
  '_id':3
})</code></pre>

<p>删除id为3的那一项</p>

<p>db.col.remove({})</p>

<p>将col全部删除</p>

<p>限制显示的条数：</p>

<pre class="has"><code class="language-html">db.col.find().limit(2)   表示显示查找到的前两项</code></pre>

<p>跳过显示的数据：</p>

<pre class="has"><code class="language-html">db.age.find().skip(2)   表示跳过查找到的前两项</code></pre>

<p>排序：</p>

<pre class="has"><code class="language-html">db.col.find().sort({age:1})  根据age升序排列（-1是降序排列）</code></pre>

<h2>连接Node</h2>

<p>首先下载node插件：</p>

<pre class="has"><code class="language-html">npm install mongodb</code></pre>

<p>然后执行以下代码：</p>

<pre class="has"><code class="language-javascript">var MongoClient = require("mongodb").MongoClient;//获取mongo模块
var mongoDB = "mongodb://localhost:27017/";
//新建数据库连接
MongoClient.connect(
    mongoDB,
    function (err, db) {
        if (err) {
            throw err;
        }
        console.log("连接成功！");
        db.close();//断开连接
    }
);</code></pre>

<h2>Node查询：</h2>

<pre class="has"><code class="language-javascript">var MongoClient = require("mongodb").MongoClient;
var mongoDB = "mongodb://localhost:27017/";
MongoClient.connect(
    mongoDB,{useNewUrlParser: true},
    function (err, db) {
        if (err) {
            throw err;
        }
        console.log("连接成功！");
        var dball = db.db('UserList');//数据库名
        dball.collection('allUser').find({}).toArray(function(err,result) {//查询语句
            if (err) {
                console.log(arr);//抛错
                return;
            }
            console.log(result);//打印查询结果（这里是查询所有）
            db.close();
        });
    }
);</code></pre>

<h2>Node插入：</h2>

<pre class="has"><code class="language-javascript">var MongoClient = require("mongodb").MongoClient;
var mongoDB = "mongodb://localhost:27017/";
MongoClient.connect(
    mongoDB,{useNewUrlParser: true},
    function (err, db) {
        if (err) {
            throw err;
        }
        console.log("连接成功！");
        var dball = db.db('UserList');      
        // 添加
        dball.collection("allUser").insert([{//插入两项，放在数组中
            email: '12345',
            password:'54321'
        }, {
            email: 'root',
            password:'root'
        }], function (err, result) {
            if (err) {
                console.log('Error:' + err);
                return;
            }
            console.log(result)//返回插入结果
        })
        db.close();//关闭数据库连接

    }
);</code></pre>

<h2>Node更新：</h2>

<pre class="has"><code class="language-javascript">var MongoClient = require("mongodb").MongoClient;
var mongoDB = "mongodb://localhost:27017/";
MongoClient.connect(
    mongoDB,{useNewUrlParser: true},
    function (err, db) {
        if (err) {
            throw err;
        }
        console.log("连接成功！");
        var dball = db.db('UserList');
        // 更新数据库
        dball.collection("allUser").update({//查找email为abcde的，将email换成12345，password换成12345
            email: 'abcde'
        }, {$set:{
            email: '12345',
            password:'12345'
        }}, function (err) {
            if (err) {
                console.log('Error:' + err);
                return;
            }
        })
        db.close();
    }
);</code></pre>

<h2>Node删除：</h2>

<pre class="has"><code class="language-javascript">var MongoClient = require("mongodb").MongoClient;
var mongoDB = "mongodb://localhost:27017/";
MongoClient.connect(
    mongoDB,{useNewUrlParser: true},
    function (err, db) {
        if (err) {
            throw err;
        }
        console.log("连接成功！");
        var dball = db.db('UserList');
        // 删除
        dball.collection("allUser").remove({
        //删除email为12345的那项
            email: '12345'
        }, function (err) {
            if (err) {
                console.log('Error:' + err);
                return;
            }
        })
        db.close();
    }
);</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS案例：Ajax实现简单局域网聊天室</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/30/10193693.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Fri, 30 Nov 2018 02:59:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/30/10193693.html</guid><description><![CDATA[
                <p>利用Ajax将数据提交到后台，再由后台发送到前端，渲染内容</p>

<p>代码如下：</p>

<h2>HTML：</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style&gt;
            *{margin: 0;padding: 0;}
    #textBox{width: 800px;height: 600px;border: 1px solid black;margin: 50px 0;font-size: 20px;}
    &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;textarea id="textBox"&gt;&lt;/textarea&gt;&lt;br&gt;
        &lt;input type="text"&gt;:&lt;input type="text" style="width:600px;"&gt;&lt;button&gt;Send&lt;/button&gt;
        &lt;script&gt;
            var names = document.querySelectorAll("input")[0];
            var msgs = document.querySelectorAll("input")[1];
            var box = document.getElementById("textBox");
            var btn = document.querySelectorAll("button")[0];
            //设置刷新时间为一秒一次
            setInterval(loadHandler, 1000);
            // 点击发送。监听事件
            btn.addEventListener("click", sendText);
            // 点击后执行Ajax
            function loadHandler(data) {
                if (!data) {
                    data = {
                        id: 2
                    };
                }
                var xhr = new XMLHttpRequest();
                xhr.addEventListener("load", startPost);
                xhr.open("POST", "http://10.9.48.155:1024/"); //这里一定是主机的IP地址
                xhr.send(JSON.stringify(data));

            }



            function startPost(e) {
                box.value = (JSON.parse(this.response)).resu.join("\n"); //将后台拼接好的数据返回到聊天面板
            }

            function sendText(e) {
                // 将从输入框获取的内容添加到对象发送到后端
                if (names.value.length === 0) return;
                if (msgs.value.length === 0) return;
                var obj = {
                    id: 1,
                    user: names.value,
                    mas: msgs.value
                }
                loadHandler(obj);
            }
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<h2>node代码：</h2>

<pre class="has"><code class="language-javascript">var http = require("http");//获取http请求（前面的文章有详细注释）
var arr = []; //新建消息容器，存放消息集

var server = http.createServer(function (req, res) {
    var data = "";
    req.on("data", function (d) {
        data += d;
    });
    req.on("end", function () {
        var obj = JSON.parse(data);
        //解析对象，将user和msg取出
        if (obj.id === 1) {
            arr.push(obj.user + ":" + obj.mas);
        }
        // 返回数组和错误信息（没有则为空）
        var result = {
            resu: arr,
            error: null
        };
        res.writeHead(200, {
            "Content-Type": "text/plain",
            "Access-Control-Allow-Origin": "*"
        });
        res.write(JSON.stringify(result));//将打包好的对象传到前端
        res.end();
    });
});
// 监听服务
server.listen(1024, "10.9.48.155", function () {
    console.log("侦听开始");
})</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS瀑布流懒加载案例</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/29/10193694.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 29 Nov 2018 12:33:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/29/10193694.html</guid><description><![CDATA[
                <p>代码附上：</p>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;fall_out&lt;/title&gt;
        &lt;style&gt;
            * {
                margin: 0;
                padding: 0;
            }

            ul {
                list-style: none;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;ul&gt;&lt;/ul&gt;
        &lt;script&gt;
            var ul, img;
            // 创建容器
            const count = 5;//总列数
            var arr = [];//存放高度之后用来比较
            var pic = 1;//图片索引
            init();//入口函数

            function init() {
                ul = document.querySelector("ul");//获取ul
                for (var i = 0; i &lt; count; i++) {//根据count创建li
                    var li = document.createElement("li");
                    ul.appendChild(li);
                    //设置样式
                    li.style.margin = "5px";
                    li.style.width = (document.documentElement.clientWidth) / count - 22 + "px";
                    li.style.border = "1px solid lightcoral";
                    li.style.float = "left";
                    arr.push(0);//初始化第一排图片的高
                }
                //新建第一张图片
                img = new Image();
                img.src = "img/" + pic + ".jpg";
                img.addEventListener("load", addPic);//添加加载事件
                document.addEventListener("scroll", move);//给右侧滚轮添加滚轮事件
            }

            function addPic(e) {
                // 复制第一张图片
                var copy = this.cloneNode(false);
                var min = Math.min.apply(null, arr);
                var index = arr.indexOf(min);//寻找高度最小的图片
                ul.children[index].appendChild(copy);//将图片加载到ul的高度最小的li中
                copy.style.width = "100%";
                arr[index] = copy.parentElement.offsetHeight;//将高度添加到数组的该项
                if ((document.documentElement.scrollHeight - document.documentElement.scrollTop) / document.documentElement
                    .clientHeight &gt; 4) {//当右边滚轮到达屏幕高度四倍时跳出函数
                    return;
                }
                pic = parseInt(Math.random() * 10 + 1);//否则继续加载图片
                img.src = "img/" + pic + ".jpg";
            }

            function move(e) {//当文档高度减滚动条的位置小于屏幕两倍时，继续加载
                if ((document.documentElement.scrollHeight - document.documentElement.scrollTop) / document.documentElement
                    .clientHeight &lt; 2) {
                    pic = parseInt(Math.random() * 10 + 1);
                    img.src = "img/" + pic + ".jpg";
                }
            }
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>JS表格小案例</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/29/10193695.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 29 Nov 2018 11:47:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/29/10193695.html</guid><description><![CDATA[
                <h2>创建一个表单，根据表单填写内容，创建表格行内容，每行后面有删除按钮，删除后可以删除该行一个搜索文本框，输入内容，点击按钮显示当前模糊查找到所有内容，显示在表格内</h2>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type="text/css"&gt;
			table {
				width: 800px;
				border: 1px solid lightcoral;
				border-collapse: collapse;
			}
		&lt;/style&gt;
	&lt;/head&gt;

	&lt;body&gt;
		&lt;input type="text" id="search" placeholder="search" /&gt;
		&lt;input type="button" value="搜索" id="find" /&gt;
		&lt;input type="text" id="name" placeholder="name" /&gt;
		&lt;input type="text" id="psd" placeholder="password" /&gt;
		&lt;input type="text" id="num" placeholder="number" /&gt;
		&lt;input type="button" value="提交" id="send" onclick="add()" /&gt;
		&lt;table id="tab"&gt;

		&lt;/table&gt;
		&lt;script type="text/javascript"&gt;
			//				通过ID获取所有元素
			var search = document.getElementById("search");
			var find = document.getElementById("find");
			var name1 = document.getElementById("name");
			var psd1 = document.getElementById("psd");
			var num1 = document.getElementById("num");
			var send = document.getElementById("send");
			var tab = document.getElementById("tab");
			//				定义一个数组,用来存放所有的输入的对象
			var arr = [];

			function add() {
				//					判断输入是否为空
				if (name1.value &amp;&amp; psd1.value &amp;&amp; num1.value) {
					//						定义对象存放输入的属性及属性值
					var obj = {};
					//					创建每行的tr以及删除键a
					var tr = document.createElement("tr");
					var aa = document.createElement("a");
					aa.textContent = "Del";
					tab.appendChild(tr);
					//					向对象添加用户输入的属性及属性值
					obj.name = name1.value;
					obj.psd = psd1.value;
					obj.num = num1.value;
					//					遍历对象输出到每行的tr
					for (var str in obj) {
						var td = document.createElement("td");
						td.textContent = str + " : " + obj[str];
						tr.appendChild(td);
					}

					tr.appendChild(aa);
					//					对删除键添加点击事件
					aa.addEventListener("click", del);
					//					创建点击事件,使tr删除
					function del(e) {
						e = e || window.event;
						tr.remove();

					}
					//					每次执行后清空输入内容
					name1.value = psd1.value = num1.value = "";
					//					将每次的对象放入数组中
					arr.push(obj);
					//					console.log(arr);
					//					为搜索键添加监听事件
					find.addEventListener("click", clickHandler);
					//					新建点击函数,遍历数组,查找搜索的关键字
					function clickHandler(e) {
						e = e || window.event;
						var str = search.value;
						var data = arr.filter(function (t) {
							return t.name.indexOf(str) &gt; -1;
						});
						//		            清空表格
						tab.textContent = "";
						//遍历数组对象
						for (var j = 0; j &lt; data.length; j++) {
							//新建每一行
							var tr = document.createElement("tr");
							var aa = document.createElement("a");
							aa.textContent = "Del";
							tab.appendChild(tr);
							//新建每行的每一项
							for (var str in data[j]) {
								var td = document.createElement("td");
								td.textContent = str + " : " + data[j][str];
								tr.appendChild(td);
							}
						}
					}
				} else {
					alert("Error");
				}
			}
		&lt;/script&gt;
	&lt;/body&gt;

&lt;/html&gt;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（七）之express框架，简单的邮箱注册小案例（Get方式）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/29/10193696.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Thu, 29 Nov 2018 09:13:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/29/10193696.html</guid><description><![CDATA[
                <p>附上代码：</p>

<h3 id="HTML%E9%83%A8%E5%88%86%EF%BC%88%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0Jq%EF%BC%89">HTML部分（需要用到Jq）</h3>

<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src="./jquery.js"&gt;&lt;/script&gt;
    &lt;style&gt;
      * {
        margin: 0;
        padding: 0;
      }
      div:nth-child(2) {
        display: none;
      }
      input {
        display: block;
        height: 40px;
        width: 200px;
        margin: 20px auto;
      }
      button:not(#email) {
        display: block;
        height: 30px;
        width: 70px;
        background: lightcoral;
        border: none;
        margin: 0 auto;
      }
      #email {
        display: block;
        height: 30px;
        width: 100px;
        margin: 0 auto;
      }
      ul {
        height: 50px;
        width: 200px;
        background: lightblue;
        margin: 0 auto;
        list-style: none;
      }
      li {
        height: 50px;
        width: 100px;
        float: left;
        text-align: center;
        line-height: 50px;
      }
      li:hover {
        background: lightgreen;
        cursor: pointer;
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;ul&gt;
      &lt;li id="regChange"&gt;注册&lt;/li&gt;
      &lt;li id="loginChange"&gt;登录&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id="reg"&gt;
      &lt;input type="text" placeholder="邮箱" id="user" /&gt;
      &lt;input type="text" placeholder="密码" id="psd" /&gt;
      &lt;input type="text" placeholder="验证码" id="sendmail" /&gt;
      &lt;button id="email"&gt;发送验证码&lt;/button&gt; &lt;button id="btn"&gt;注册&lt;/button&gt;
    &lt;/div&gt;
    &lt;div id="login"&gt;
      &lt;input type="text" placeholder="用户名" id="loguser" /&gt;
      &lt;input type="text" placeholder="密码" id="logpsd" /&gt;
      &lt;button id="logbtn"&gt;登录&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        //增加监听事件
      btn.addEventListener("click", clickHandler);
      logbtn.addEventListener("click", clickHandler);
      email.addEventListener("click", sendHandler);
      regChange.addEventListener("click", changeHandler);
      loginChange.addEventListener("click", changeHandler);

      function clickHandler(e) {
        if (this.textContent === "注册") {
            //若为空时跳出
          if (!user.value || !psd.value || !sendmail.value) {
            alert("Can't be empty");
            return;
          }
          //点击注册时将邮箱号，密码，验证码传送至后台
          $.get(
            `http://localhost:1024/index/reg?user=${user.value}&amp;psd=${
              psd.value
            }&amp;mail=${sendmail.value}`,
            function(res) {
                //后台返回的对象，若hasUser为真，说明已有用户名，否则注册成功
              if (res.hasUser) {
                alert("注册失败");
                return;
              } else {
                alert("注册成功~");
              }
              //成功后隐藏注册，显示登录
              reg.style.display = "none";
              login.style.display = "block";
            }
          );
        } else if (this.textContent === "登录") {
            // 同注册，不能为空
          if (!loguser.value || !logpsd.value) {
            alert("Can't be empty");
            return;
          }
          //点击登录时将邮箱号，密码传送至后台
          $.get(
            `http://localhost:1024/index/login?user=${loguser.value}&amp;psd=${
              logpsd.value
            }`,
            function(res) {
                //后台返回的对象，若isUser为真，说明正确，并跳转至欢迎页，否则失败
              if (res.isUser) {
                alert("登录成功");
                location.href = "./welcome.html";
              } else {
                alert("用户名或密码不正确");
                return;
              }
            }
          );
        }
      }

      function sendHandler(e) {
        //   点击获取验证码后将验证码发送到后端进行比对
        $.get(`http://localhost:1024/index/sendmail?${user.value}`);
      }

      function changeHandler(e) {
        //   点击上方的注册登录切换
        if (e.target.textContent === "注册") {
          reg.style.display = "block";
          login.style.display = "none";
        } else {
          reg.style.display = "none";
          login.style.display = "block";
        }
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="node%E5%90%8E%E5%8F%B0%E9%83%A8%E5%88%86%EF%BC%9A%C2%A0">node后台部分： 需要引入的第三方模块有：express框架，cors，nodemailer，</h3>

<pre class="has"><code class="language-javascript">const express = require('express');//引入express框架（需要先下载，官网有教程）
const url = require('url');
const path = require('path');
const fs = require('fs');
const cors = require('cors');//引入cors模块（解决跨域问题）
const app = express();
// const bodyparser = require('body-parser');
const sendMail = require('./send');//这个模块是发送邮件模块（在我第三篇node文章里有）


app.use(cors());
// 下面的类似于http请求的头文件(另一篇文章有写到http请求，也是注册登录)
app.all("*", function (req, res, next) {
    //设置允许跨域的域名，*代表允许任意域名跨域
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "content-type");//允许的header类型
    res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS");//跨域允许的请求方式 
    next();//是否继续向下执行
})

//注册接口
var count = '';//新建一个空字符存放验证码，可供全局调用
app.get('/index/reg', (req, res) =&gt; {
    let search = url.parse(req.url).search;//保存前端传来的数据
    files = path.join(__dirname, './user.txt');//用一个txt来记录用户名和密码
    fs.readFile(files, 'utf8', (err, data) =&gt; {
        //读取txt文件，判断是否存在用户名，并对验证码进行判断
        if (data.indexOf(search.split('&amp;')[0]) === -1 &amp;&amp; search.split('&amp;')[2].split('=')[1] === count) {
            fs.appendFile(files, search.split('&amp;')[0] + '&amp;' + search.split('&amp;')[1]);//符合条件就将信息存至TXT中，并返回一个对象至前端，表示验证成功（hasUser为真，说明该用户已存在）
            res.send({
                hasUser: false
            });
        } else {
            //不符合条件就返回一个对象至前端，表示验证失败
            res.send({
                hasUser: true
            });
        }

    });
});

//登录接口
app.get('/index/login', (req, res) =&gt; {
    let search = url.parse(req.url).search;//保存前端传来的数据
    files = path.join(__dirname, './user.txt');
    //读取txt文件，判断是否存在用户名和对应的密码
    fs.readFile(files, 'utf8', (err, data) =&gt; {
        //符合条件就返回一个对象至前端，表示验证失败（isUser为真，说明该用户名与密码不符）
        if (data.indexOf(search) === -1) {
            res.send({
                isUser: false
            });
        } else {
            res.send({
                isUser: true
            });
        }
    });
});

//邮箱验证接口
app.get('/index/sendmail', (req, res) =&gt; {
    count = '';//初始化验证码容器
    let Email = url.parse(req.url).query;//获取前端传来的邮箱号
    for (let i = 0; i &lt; 4; i++) {
        count += Math.floor(Math.random() * 10);//生成4个随机数
    }
    sendMail.send(Email, count);//调用邮件发送模块（传入注册的邮箱，验证码）
    res.send(count);
});
//监听服务
app.listen(1024, () =&gt; {
    console.log('Server Start~');
});</code></pre>

<h3>附上发送邮件的模块(在我前面的文章中也有)</h3>

<pre class="has"><code class="language-javascript">//引入模块
 
const nodemailer = require("nodemailer");
 
//新建对象
 
let obj = {
 
transporter: nodemailer.createTransport({
 
service: "qq", // 运营商 qq邮箱 网易//
 
port: 465,
 
secure: true,
 
auth: {
 
user: "**********@qq.com", //发送方的邮箱
 
pass: "***************" // pop3 授权码
 
}
 
}),
 
//传参（对方的mail地址,内容）
 
send: function(mail, content) {
 
mailOptions = {
 
//发送方的邮箱地址
 
from: '"Hello World~" &lt;***********@qq.com&gt;',
 
to: mail,
 
subject: content,
 
text: content,
 
html: "&lt;h1&gt;" + content + "&lt;/h1&gt;"
 
};
 
this.transporter.sendMail(mailOptions, (error, info) =&gt; {
 
if (error) {
 
return console.log(error);
 
}
 
console.log("Message sent: %s", info.messageId);
 
});
 
}
 
};
 
//抛出对象以接收
 
module.exports = obj;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（六）其他常用内置模块</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/28/10193697.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Wed, 28 Nov 2018 08:28:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/28/10193697.html</guid><description><![CDATA[
                <h1>HTTP模块</h1>

<p>跨域：用代理的方式跨域，打个比方，我自己有一个前端，一个后台，小明有一个后台。我的前端需要访问小明的后台就是所谓的跨域，但是如果用我自己的后台使用http请求访问小明的后台，就不用跨域，于是我就可以通过自己的前端用ajax访问自己的后端完成数据请求。·</p>

<p>创建服务器：通过ajax的post传至data中</p>

<pre class="has"><code class="language-javascript">//加载库中http.js，加载进入赋值给变量http，是一个对象
var reg = require("http");
//req就是客户端向服务器端请求的数据
//res就服务器项客户端发送的数据
//reg.createServer创建服务
var server = reg.createServer(function (req, res) {
    var data = "";
//req.on("data")是客户端请求的数据正在接收中的事件
    req.on("data", function (d) {
        data += d;
    });
//req.on("end")是客户端请求的数据接收完毕
    req.on("end", function () {
        var obj = JSON.parse(data);
//头文件，最后的*表示允许所有域访问
        res.writeHead(200, {
            "Content-Type": "text/plain",
            "Access-Control-Allow-Origin": "*"
        });
        res.write(JSON.stringify(obj));
        res.end();
    });
});
//侦听事件
server.listen(1024, "localhost", function () {
    console.log("注册服务开启，开始侦听");
});</code></pre>

<p>爬虫 获取数据：</p>

<pre class="has"><code class="language-javascript">//引入http模块
const http = require('http');
//发起服务器短的请求
const fs = require('fs');
http.get('http://localhost/test/1.html', (res) =&gt; {
    const {
        statusCode
    } = res;//状态码
    const contentType = res.headers['content-type'];//请求的类型
    let error;
    if (statusCode !== 200) {
        error = new Error('状态码错误');
    }
    if (error) {
        console.log(error.message);
        res.resume();// 清除请求缓存
        return;
    }
// 数据处理
    res.setEncoding('utf8');//设置数据的编码格式
    let data = '';
    res.on('data', function (d) {
        data += d;//接收分段信息
    });
    res.on('end', () =&gt; {
        // console.log(data);
//接收后写入至本地文件
        fs.writeFile('./test1.html', data, 'utf8', (err) =&gt; {
            if (err) {
                throw err
            }
            console.log('下载完成');
        })
    });
}).on('error', (e) =&gt; {
    console.error(`Got error: ${e.message}`);//出错返回信息
});</code></pre>

<h1>URL模块</h1>

<p>引入：const url = require('url');</p>

<pre class="has"><code class="language-javascript">let urlstring='http://www.baidu.com:8080/home/login/test?name=wy&amp;ps=wanger#hash'
const myURL = url.parse(urlstring,true);
//parse 将url字符串变成url格式的对象</code></pre>

<pre class="has"><code class="language-javascript"> let obj={
	protocol: 'http:',
	slashes: true,
	auth: null,
	host: 'www.baidu.com:8080',
	port: '8080',
	hostname: 'www.baidu.com',
	hash: '#hash',
	search: '?name=wy&amp;ps=wanger',
	query: { name: 'wy', ps: 'wanger' },
	pathname: '/home/login/test',
	path: '/home/login/test?name=wy&amp;ps=wanger',
	href:'http://www.baidu.com:8080/home/login/test?name=wy&amp;ps=wanger#hash' 
}
let result=url.format(obj)
//format将url对象变成url格式的字符</code></pre>

<h1>QueryString模块</h1>

<p>引入：let qs=require('querystring');</p>

<pre class="has"><code class="language-javascript">parse(query,"%",'@')//将字符串转化为对象
qs.stringify(obj,'@',"!")//将对象转为字符
qs.escape(query)//将query 中的汉字或者特殊字符进行编码
qs.unescape(code)//将query 中的汉字或者特殊字符进行解码</code></pre>

<h1>Path模块</h1>

<p>引入：const path=require('path');</p>

<pre class="has"><code class="language-javascript">path.join()//实现路径拼接
path.join(__dirname,'./file.js')//__dirname是当前文件的文件夹，可以拼接多个，以逗号隔开：
path.join(__dirname,'../','./hw','mail.js')
path.basename('path')//当前文件名
path.dirname('path')//当前文件夹名
path.extname('path')//拓展名</code></pre>

<h1>Events模块</h1>

<p>引入：const Event = require('events');</p>

<p>首先要进行以下代码（与其他模块不同）</p>

<pre class="has"><code class="language-javascript">class MyEmitter extends Event {}

// 类的继承

const myEmitter = new MyEmitter();

// 实例化对象 new对象

// 添加对象监听

let callback=(food,food2)=&gt;{

&nbsp;&nbsp;&nbsp;&nbsp;console.log('eat'+food+food2);

}</code></pre>

<p>然后，愉快的调用</p>

<pre class="has"><code class="language-javascript">myEmitter.on('eat',callback);//eat是事件名
myEmitter.emit('eat','aaaaa','bbbb')//可以传参
myEmitter.removeAllListeners()//移除所有的事件
myEmitter.removeListener('eat',callback);//移除某个事件</code></pre>

<h1>Stream流</h1>

<p>首先需要引入：const fs=require('fs');</p>

<pre class="has"><code class="language-javascript">let read=fs.createReadStream('./events.js')// 创建可读的流
let  write=fs.createWriteStream('./events3.js')// 创建可写的流</code></pre>

<p>读取Stream流并复制图片的例子&nbsp;</p>

<pre class="has"><code class="language-javascript">const fs = require('fs');
let read = fs.createReadStream('./file/test1.png');//新建可读Stream流文件
let data = '';//外置容器加载数据
read.setEncoding('binary');//转换成图片的格式，默认utf8
read.on('data',(d)=&gt;{
    data+=d;//每次流式传输数据
});
read.on('end',()=&gt;{
    fs.writeFileSync('./file/test2.png',data,'binary');//将数据写入至文件
});</code></pre>

<p>&nbsp;</p>

<p>&nbsp;读取Stream流并以可写流方式复制图片的例子&nbsp;</p>

<pre class="has"><code class="language-javascript">const fs = require('fs');
let read = fs.createReadStream('./file/test1.png');//新建可读Stream流文件
let change = fs.createWriteStream('./file/test3.png','binary');//新建可写Stream流文件
read.setEncoding('binary');//转换格式（图片）
read.on('data',(d)=&gt;{
    change.write(d);//流式存储,无需等到数据加载完，一边加载一边存储
});</code></pre>

<p>读取加写入配合pipe完成复制</p>

<pre class="has"><code class="language-javascript">//达到文件流式复制
const fs=require('fs')
let read = fs.createReadStream('./file/test1.png', 'binary'); //新建可读Stream流文件
let change = fs.createWriteStream('./file/test4.png', 'binary'); //新建可写Stream流文件
read.pipe(change);//将可读流传输至可写流文件中</code></pre>

<h1>Zlib模块</h1>

<p>引入：const zip = require('zlib');和</p>

<p>const fs = require('fs');</p>

<pre class="has"><code class="language-javascript">const gzip = zip.createGzip();//新建文件压缩
let input = fs.ReadStream('./test1.png');//传入的文件
let output = fs.WriteStream('./test1.gzip');//将压缩好的文件生成
input.pipe(gzip).pipe(output);//pipe流式传输</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（五）File System小案例（删除文件夹及下面的所有文件）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/28/10193698.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Wed, 28 Nov 2018 02:33:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/28/10193698.html</guid><description><![CDATA[
                <p>附上代码，注释已加上（注意：要用同步的方式写，由于文件夹数不确定，所以需要所有的文件删除后才能删除文件夹，亲身经历，就是因为这个小问题，整了很久）</p>

<pre class="has"><code class="language-javascript">const fs = require('fs');
//封装一个立即执行函数，返回对象
let delDir = (() =&gt; {
    return {
//入口函数
        init: function (url) {
            this.del(url);
        },
//删除函数，传入当前的文件夹作为参数，注意：要用同步，不然会报错（因为当文件夹内文件数不为0时，文件夹无法被删除）
        del: function (url) {
//新建一个数组用来存放遍历到的同层文件或文件夹
            var files = [];
            files = fs.readdirSync(url);
            for (var i = 0; i &lt; files.length; i++) {
                var path = url + '/' + files[i];
//判断遍历到的某一项是文件还是文件夹，若为文件，则将其删除，若为文件夹，再次递归删除函数（直到所有的文件删除后才对文件夹进行操作（因为用了同步））
                if (fs.statSync(path).isFile()) {
                    fs.unlinkSync(path);
                } else {
                    this.del(path);
                }
            }
            fs.rmdirSync(url);
        }
    };
})();
//抛出模块对象
module.exports = delDir;</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node（四）内置模块之File System</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/28/10193699.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Wed, 28 Nov 2018 01:06:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/28/10193699.html</guid><description><![CDATA[
                <h1><strong>文件和文件夹的操作（fs模块）</strong></h1>

<p><br>
下面是fs的几种功能：<br>
首先在js文件最上方引入模块<br>
&nbsp;</p>

<pre class="has"><code class="language-javascript">const fs = require("fs");</code></pre>

<h2>对文件夹操作：</h2>

<h3>1.新建文件夹</h3>

<pre class="has"><code class="language-javascript">//mkdirSync里的参数是文件路径和回调函数，Sync表示同步执行，若无Sync，则表示异步执行（下同）
fs.mkdirSync('./files/third',(err)=&gt;{
//参数是报错内容，若无错误则没有
&nbsp; &nbsp; if (err) {
&nbsp; &nbsp; &nbsp; &nbsp; console.log("Error");
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; console.log("OK");
&nbsp; &nbsp; }
});</code></pre>

<h3><br>
2.删除文件夹</h3>

<p><br>
&nbsp;</p>

<pre class="has"><code class="language-javascript">fs.rmdirSync('./files',(err)=&gt;{
&nbsp; &nbsp; if (err) {
&nbsp; &nbsp; &nbsp; &nbsp; console.log("Error");
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; console.log("OK");
&nbsp; &nbsp; }
});</code></pre>

<h3><br>
3.读取文件夹</h3>

<pre class="has"><code class="language-javascript">fs.readdir('./files',(err,file)=&gt;{
&nbsp; &nbsp; if (err) {
&nbsp; &nbsp; &nbsp; &nbsp; console.log("Error");
&nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; console.log(file);
&nbsp; &nbsp; }
});</code></pre>

<h3>4.查看文件夹的属性及状态</h3>

<p>&nbsp;</p>

<pre class="has"><code class="language-javascript">//stats是返回的文件夹的属性
fs.stat('./files',(err,stats)=&gt;{
&nbsp; &nbsp; if (err) {
&nbsp; &nbsp; &nbsp; &nbsp; console.log("Error");
&nbsp; &nbsp; } else {
&nbsp; &nbsp; //stats.isDirectory（）判断是否是文件夹；stats.isFile（）判断是否是文件
&nbsp; &nbsp; &nbsp; &nbsp; console.log(stats);
&nbsp; &nbsp; &nbsp; &nbsp; console.log(stats.isDirectory());
&nbsp; &nbsp; &nbsp; &nbsp; console.log(stats.isFile());
&nbsp; &nbsp; }
});</code></pre>

<h2><br>
&nbsp;对文件操作：</h2>

<h3><br>
&nbsp;1.新建文件</h3>

<p>&nbsp;</p>

<pre class="has"><code class="language-javascript">//参数是新建文件的路径，文件内容，成功后回调函数
fs.writeFile('./files/second/e.txt','Hello_World',(OK)=&gt;{
&nbsp; &nbsp; &nbsp; &nbsp; console.log("OK");
});
</code></pre>

<h3>2.读取文件内容</h3>

<pre class="has"><code class="language-javascript">fs.readFile('./files/second/e.txt',(OK,data)=&gt;{
    // 转换的是buffer，要用toString转换
        console.log(data.toString());
});

//或用下面的
fs.readFile('./files/a.txt','utf8',(OK,data)=&gt;{
    // 转换的是buffer，或者用utf8转换
        console.log(data);
});</code></pre>

<h3>3.在文件后插入内容</h3>

<pre class="has"><code class="language-javascript">fs.appendFile('./files/b.txt','hello~',(OK)=&gt;{
        console.log('ok');
});</code></pre>

<h3>4.删除文件</h3>

<pre class="has"><code class="language-javascript">const fs = require("fs");
fs.unlink('./files/f.txt',(OK)=&gt;{
        console.log('ok');
});</code></pre>

<p>&nbsp;</p>            ]]></description></item><item><title>Node.js(三)发送邮件模块（第三方模块）</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/27/10193700.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 27 Nov 2018 08:15:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/27/10193700.html</guid><description><![CDATA[
                <p>模块文件：首先用Npm下载一个由Andris Reinman大佬的第三方模块nodemailer</p>

<p>修改了一下他的模块生成一个js文件：</p>

<pre class="has"><code class="language-javascript">//引入模块

const nodemailer = require("nodemailer");

//新建对象

let obj = {

transporter: nodemailer.createTransport({

service: "qq", // 运营商 qq邮箱 网易//

port: 465,

secure: true,

auth: {

user: "**********@qq.com", //发送方的邮箱

pass: "***************" // pop3 授权码

}

}),

//传参（对方的mail地址,内容）

send: function(mail, content) {

mailOptions = {

//发送方的邮箱地址

from: '"Hello World~" &lt;***********@qq.com&gt;',

to: mail,

subject: content,

text: content,

html: "&lt;h1&gt;" + content + "&lt;/h1&gt;"

};

this.transporter.sendMail(mailOptions, (error, info) =&gt; {

if (error) {

return console.log(error);

}

console.log("Message sent: %s", info.messageId);

});

}

};

//抛出对象以接收

module.exports = obj;</code></pre>

<p>&nbsp;</p>

<p>//然后再新建一个js文件用来调用模块</p>

<pre class="has"><code class="language-javascript">const sendMassage = require("./send.js");

sendMassage.send("*********@qq.com","Hello World~");</code></pre>

<p>运行这个js文件，就可以给对方发送电子邮件啦</p>

<p>&nbsp;</p>            ]]></description></item><item><title>Node.js（二）模块使用</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/27/10193701.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 27 Nov 2018 07:37:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/27/10193701.html</guid><description><![CDATA[
                <p>节点有三种模块：内置模块（节点文档里有），第三方模块（大佬们自己写的模块），自定义模块（成为大佬的必经之路）;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>1.创建自定义模块的方式：</p>

<p>新建一个JS文件，如：</p>

<pre class="has"><code class="language-javascript">let obj = {

&nbsp; &nbsp; name： 'AAA'，

&nbsp; &nbsp; SayHello：function（）{

&nbsp; &nbsp; &nbsp; &nbsp;console.log（ “你好” + this.name）

&nbsp;&nbsp;&nbsp;&nbsp;}

}
//抛出该对象

module.exports = obj </code></pre>

<p>&nbsp;</p>

<p>使用自定义模块的方式：</p>

<p>之后在要调用的JS文件中</p>

<pre class="has"><code class="language-javascript">//新建一个对象接收模块对象

const obj = require（'./ module.js'）//这是开始那个js文件的路径

执行console.log（obj）

obj.sayhello（）;</code></pre>

<p><br><br>
2.内置模块使用</p>

<p>const obj = require（'模块名'）</p>

<p>根据官方文档直接调用</p>

<p>3.第三方模块</p>

<p>先使用NPM或CNPM下载相关模块</p>

<p>使用const obj = require（'模块名'）引入;</p>

<p>之后根据第三方文档使用</p>            ]]></description></item><item><title>Node（一）初识</title><link>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/27/10193702.html</link><dc:creator>___Hello___World</dc:creator><author>___Hello___World</author><pubDate>Tue, 27 Nov 2018 06:45:00 GMT</pubDate><guid>http://www.cnblogs.com/HelloWorld-Yu/archive/2018/11/27/10193702.html</guid><description><![CDATA[
                <p>Node是一个JavaScript的运行环境（平台）；不是一个框架或语言。<br>
配置环境：可以先下载一个NVM（Node版本管理工具），GitHub上有下，附上地址（<a href="https://github.com/coreybutler/nvm-windows/releases" rel="nofollow">https://github.com/coreybutler/nvm-windows/releases</a>）。<br>
下载安装之后先在安装的根目录配置TXT文件（settings.txt）<br><code>root 配置为当前 nvm.exe 所在目录<br>
path 配置为 node 快捷方式所在的目录<br>
arch 配置为当前操作系统的位数（32/64)</code></p>

<p>然后配置环境变量（有时安装后自动配置了）；</p>

<p>通过 window+r 输入 sysdm.cpl；</p>

<p>在path中添加：</p>

<p><code>NVM_HOME = 当前 nvm.exe 所在目录</code></p>

<p><code>NVM_SYMLINK = node 快捷方式所在的目录</code></p>

<p><code>PATH += %NVM_HOME%;%NVM_SYMLINK%;</code></p>

<p>安装完成后在CMD中输入nvm -v查看是否安装成功。</p>

<p>然后就可以安装node.js了：nvm install node@版本号（会自动安装npm）</p>

<p>之后用nvm -ls查看当前nvm管理的node版本，用nvm use node版本号来切换版本<br>
用nvm uninstall 版本号删除相应的node；</p>

<p>安装好了之后就可以开始上路啦~</p>

<p>&nbsp;</p>            ]]></description></item></channel></rss>